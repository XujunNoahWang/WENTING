

// åº”ç”¨é…ç½®
window.APP_CONFIG = {

    // å¤©æ°”é…ç½® - åˆå§‹çŠ¶æ€ï¼Œç­‰å¾…çœŸå®æ•°æ®
    weather: {
        location: 'è·å–ä½ç½®ä¸­...',
        icon: 'ğŸŒ',
        condition: 'åŠ è½½ä¸­',
        temperature: '--Â°C',
        wind: {
            level: '--',
            label: 'é£åŠ›'
        },
        humidity: {
            value: '--%',
            label: 'æ¹¿åº¦'
        }
    }
};


// å·¥å…·å‡½æ•°
const Utils = {
    // DOMé€‰æ‹©å™¨ - å•ä¸ªå…ƒç´ 
    $: (selector) => {
        return document.querySelector(selector);
    },

    // DOMé€‰æ‹©å™¨ - å¤šä¸ªå…ƒç´ 
    $$: (selector) => {
        return Array.from(document.querySelectorAll(selector));
    },

    // æ ¼å¼åŒ–æ—¥æœŸ
    formatDate: (date) => {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        return {
            month: months[date.getMonth()],
            date: date.getDate(),
            weekday: weekdays[date.getDay()],
            full: `${months[date.getMonth()]} ${date.getDate()}`
        };
    },

    // è®¡ç®—æ—¥æœŸèŒƒå›´
    calculateDateRange: (periodText) => {
        const now = new Date();
        let endDate = new Date(now);
        
        if (periodText.includes('å‘¨')) {
            const weeks = parseInt(periodText);
            endDate.setDate(now.getDate() + weeks * 7 - 1);
        } else if (periodText.includes('ä¸ªæœˆ')) {
            const months_count = parseInt(periodText);
            endDate.setMonth(now.getMonth() + months_count);
            endDate.setDate(now.getDate() - 1);
        } else {
            return ''; // å¯¹äº"æ¯æ—¥"ç­‰ä¸éœ€è¦æ˜¾ç¤ºæ—¥æœŸèŒƒå›´
        }
        
        const startMonth = now.getMonth() + 1;
        const startDay = now.getDate();
        const endMonth = endDate.getMonth() + 1;
        const endDay = endDate.getDate();
        
        return `${startMonth}/${startDay}-${endMonth}/${endDay}`;
    },

    // ç”Ÿæˆå”¯ä¸€ID
    generateId: () => {
        return 'id_' + Math.random().toString(36).substr(2, 9);
    },

    // é˜²æŠ–å‡½æ•°
    debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    // æ·±æ‹·è´
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Array) return obj.map(item => Utils.deepClone(item));
        if (typeof obj === 'object') {
            const clonedObj = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    clonedObj[key] = Utils.deepClone(obj[key]);
                }
            }
            return clonedObj;
        }
    },

    // èŠ‚æµå‡½æ•°
    throttle: (func, limit) => {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },

    // HTMLè½¬ä¹‰å‡½æ•°ï¼Œé˜²æ­¢XSSæ”»å‡»
    escapeHtml: (text) => {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.Utils = Utils;


// è®¾å¤‡ç®¡ç†å™¨ - åŸºäºè®¾å¤‡æŒ‡çº¹çš„è®¾å¤‡è¯†åˆ«
const DeviceManager = {
    deviceId: null,
    deviceInfo: null,

    // åˆå§‹åŒ–è®¾å¤‡ç®¡ç†å™¨
    async init() {
        console.log('ğŸ”§ åˆå§‹åŒ–è®¾å¤‡ç®¡ç†å™¨...');
        this.deviceId = this.getOrCreateDeviceId();
        this.deviceInfo = this.getDeviceInfo();
        
        console.log('ğŸ“± è®¾å¤‡ID:', this.deviceId);
        console.log('ğŸ“Š è®¾å¤‡ä¿¡æ¯:', this.deviceInfo);
        
        // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºè®¾å¤‡ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
        this.displayDeviceInfo();
        
        // ç¡®ä¿æ–°ç”¨æˆ·çš„è®¾å¤‡IDåŒæ­¥åˆ°æ•°æ®åº“
        const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        if (currentAppUser && this.deviceId) {
            console.log('ğŸ”„ ä¸ºæ–°ç”¨æˆ·åŒæ­¥è®¾å¤‡IDåˆ°æ•°æ®åº“...');
            // å¼‚æ­¥åŒæ­¥ï¼Œä¸é˜»å¡åˆå§‹åŒ–
            setTimeout(() => {
                this.syncDeviceIdToDatabase();
            }, 1000);
        }
        
        return this.deviceId;
    },

    // è·å–æˆ–åˆ›å»ºè®¾å¤‡ID
    getOrCreateDeviceId() {
        // å…ˆå°è¯•ä»localStorageè·å–å·²å­˜åœ¨çš„è®¾å¤‡ID
        let deviceId = localStorage.getItem('wenting_device_id');
        
        if (deviceId) {
            console.log('ğŸ“± æ‰¾åˆ°å·²å­˜åœ¨çš„è®¾å¤‡ID:', deviceId);
            return deviceId;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å½“å‰ç™»å½•ç”¨æˆ·ï¼Œå¦‚æœæœ‰ï¼Œå°è¯•ä»æ•°æ®åº“è·å–è¯¥ç”¨æˆ·çš„è®¾å¤‡ID
        const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        if (currentAppUser) {
            console.log('ğŸ” æ£€æµ‹åˆ°å·²ç™»å½•ç”¨æˆ·:', currentAppUser, 'å°è¯•è·å–å…¶è®¾å¤‡ID...');
            const existingDeviceId = this.tryGetExistingDeviceId(currentAppUser);
            if (existingDeviceId) {
                console.log('âœ… æ‰¾åˆ°ç°æœ‰è®¾å¤‡ID:', existingDeviceId);
                localStorage.setItem('wenting_device_id', existingDeviceId);
                return existingDeviceId;
            }
        }
        
        // å¦‚æœæ²¡æœ‰ï¼Œåˆ™ç”Ÿæˆæ–°çš„è®¾å¤‡ID
        deviceId = this.generateDeviceId();
        localStorage.setItem('wenting_device_id', deviceId);
        
        console.log('ğŸ†• ç”Ÿæˆæ–°çš„è®¾å¤‡ID:', deviceId);
        return deviceId;
    },

    // ç”Ÿæˆè®¾å¤‡æŒ‡çº¹ID
    generateDeviceId() {
        const fingerprint = this.generateDeviceFingerprint();
        
        // ä½¿ç”¨æŒ‡çº¹ç”Ÿæˆä¸€ä¸ªç›¸å¯¹ç¨³å®šçš„è®¾å¤‡ID
        const deviceId = this.hashString(fingerprint);
        
        console.log('ğŸ” è®¾å¤‡æŒ‡çº¹:', fingerprint);
        console.log('ğŸ†” ç”Ÿæˆçš„è®¾å¤‡ID:', deviceId);
        
        return deviceId;
    },

    // ç”Ÿæˆè®¾å¤‡æŒ‡çº¹
    generateDeviceFingerprint() {
        const components = [];
        
        // 1. ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²
        components.push(navigator.userAgent);
        
        // 2. å±å¹•åˆ†è¾¨ç‡
        components.push(`${screen.width}x${screen.height}`);
        
        // 3. å±å¹•è‰²æ·±
        components.push(screen.colorDepth.toString());
        
        // 4. æ—¶åŒºåç§»
        components.push(new Date().getTimezoneOffset().toString());
        
        // 5. è¯­è¨€è®¾ç½®
        components.push(navigator.language || navigator.userLanguage || 'unknown');
        
        // 6. å¹³å°ä¿¡æ¯
        components.push(navigator.platform);
        
        // 7. æ˜¯å¦æ”¯æŒè§¦æ‘¸
        components.push(('ontouchstart' in window).toString());
        
        // 8. è®¾å¤‡å†…å­˜ï¼ˆå¦‚æœæ”¯æŒï¼‰
        if (navigator.deviceMemory) {
            components.push(navigator.deviceMemory.toString());
        }
        
        // 9. ç¡¬ä»¶å¹¶å‘æ•°
        if (navigator.hardwareConcurrency) {
            components.push(navigator.hardwareConcurrency.toString());
        }
        
        // 10. CanvasæŒ‡çº¹ï¼ˆç®€åŒ–ç‰ˆï¼‰
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Device fingerprint test ğŸ”', 2, 2);
            components.push(canvas.toDataURL());
        } catch (e) {
            components.push('canvas-error');
        }
        
        return components.join('|');
    },

    // ç®€å•çš„å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°
    hashString(str) {
        let hash = 0;
        if (str.length === 0) return hash.toString();
        
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
        }
        
        // è½¬æ¢ä¸ºæ­£æ•°å¹¶æ·»åŠ å‰ç¼€
        const deviceId = 'device_' + Math.abs(hash).toString(16);
        return deviceId;
    },

    // è·å–è®¾å¤‡ä¿¡æ¯
    getDeviceInfo() {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTablet = /iPad|Android(?!.*Mobile)/i.test(navigator.userAgent);
        
        let deviceType = 'desktop';
        if (isTablet) {
            deviceType = 'tablet';
        } else if (isMobile) {
            deviceType = 'mobile';
        }
        
        return {
            type: deviceType,
            isMobile: isMobile,
            isTablet: isTablet,
            isDesktop: !isMobile && !isTablet,
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            screen: {
                width: screen.width,
                height: screen.height,
                colorDepth: screen.colorDepth
            },
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };
    },

    // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºè®¾å¤‡ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
    displayDeviceInfo() {
        // åœ¨å¤©æ°”æ æ·»åŠ è®¾å¤‡æ ‡è¯†
        const locationElement = document.querySelector('.weather-location');
        if (locationElement && this.deviceInfo) {
            const deviceTypeIcon = this.getDeviceTypeIcon();
            const shortDeviceId = this.deviceId.substring(this.deviceId.length - 6);
            
            // åœ¨ä½ç½®ä¿¡æ¯åæ·»åŠ è®¾å¤‡æ ‡è¯†
            const originalTitle = locationElement.title || '';
            locationElement.title = `${originalTitle}\nè®¾å¤‡: ${deviceTypeIcon} ${this.deviceInfo.type} (${shortDeviceId})`;
            
            // å¯é€‰ï¼šåœ¨ä½ç½®æ–‡æœ¬åæ·»åŠ è®¾å¤‡å›¾æ ‡
            if (locationElement.textContent && !locationElement.textContent.includes('ğŸ“±') && !locationElement.textContent.includes('ğŸ’»')) {
                locationElement.textContent += ` ${deviceTypeIcon}`;
            }
        }
        
        console.log('ğŸ“± è®¾å¤‡ä¿¡æ¯å·²æ˜¾ç¤ºåœ¨å¤©æ°”æ ');
    },

    // è·å–è®¾å¤‡ç±»å‹å›¾æ ‡
    getDeviceTypeIcon() {
        switch (this.deviceInfo.type) {
            case 'mobile':
                return 'ğŸ“±';
            case 'tablet':
                return 'ğŸ“±';
            case 'desktop':
            default:
                return 'ğŸ’»';
        }
    },

    // è·å–å½“å‰è®¾å¤‡ID
    getCurrentDeviceId() {
        return this.deviceId;
    },

    // è·å–è®¾å¤‡ä¿¡æ¯
    getDeviceInformation() {
        return this.deviceInfo;
    },

    // é‡ç½®è®¾å¤‡IDï¼ˆè°ƒè¯•ç”¨ï¼‰
    resetDeviceId() {
        localStorage.removeItem('wenting_device_id');
        console.log('ğŸ”„ è®¾å¤‡IDå·²é‡ç½®ï¼Œè¯·åˆ·æ–°é¡µé¢');
        return this.init();
    },

    // æ£€æŸ¥æ˜¯å¦ä¸ºæ–°è®¾å¤‡
    isNewDevice() {
        return !localStorage.getItem('wenting_device_id');
    },

    // å°è¯•ä»åç«¯è·å–ç°æœ‰ç”¨æˆ·çš„è®¾å¤‡ID
    tryGetExistingDeviceId(appUserId) {
        try {
            // è¿™æ˜¯ä¸€ä¸ªåŒæ­¥æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦ç”¨å¼‚æ­¥æ–¹å¼å¤„ç†
            // å…ˆè¿”å›nullï¼Œç„¶åé€šè¿‡äº‹ä»¶ç³»ç»Ÿå¤„ç†
            setTimeout(() => {
                this.fetchExistingDeviceIdAsync(appUserId);
            }, 100);
            return null;
        } catch (error) {
            console.error('è·å–ç°æœ‰è®¾å¤‡IDå¤±è´¥:', error);
            return null;
        }
    },

    // å¼‚æ­¥è·å–ç°æœ‰è®¾å¤‡ID
    async fetchExistingDeviceIdAsync(appUserId) {
        try {
            // ä½¿ç”¨ApiClientçš„åŠ¨æ€URLæ„å»ºé€»è¾‘
            if (!window.ApiClient) {
                console.error('âŒ ApiClientæœªåˆå§‹åŒ–');
                return;
            }
            
            // è°ƒç”¨åç«¯APIè·å–è¯¥ç”¨æˆ·çš„è®¾å¤‡ID
            const data = await window.ApiClient.get(`/auth/device-info/${encodeURIComponent(appUserId)}`);
            if (data.success && data.data && data.data.device_id) {
                const existingDeviceId = data.data.device_id;
                console.log('ğŸ”„ ä»æœåŠ¡å™¨è·å–åˆ°è®¾å¤‡ID:', existingDeviceId);
                
                // æ›´æ–°localStorageä¸­çš„è®¾å¤‡ID
                localStorage.setItem('wenting_device_id', existingDeviceId);
                this.deviceId = existingDeviceId;
                
                // è§¦å‘è®¾å¤‡IDæ›´æ–°äº‹ä»¶
                window.dispatchEvent(new CustomEvent('deviceIdUpdated', {
                    detail: { deviceId: existingDeviceId }
                }));
                
                console.log('âœ… è®¾å¤‡IDå·²åŒæ­¥ï¼Œè¯·åˆ·æ–°é¡µé¢æˆ–é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®');
            }
        } catch (error) {
            console.error('å¼‚æ­¥è·å–è®¾å¤‡IDå¤±è´¥:', error);
        }
    },

    // æ‰‹åŠ¨è®¾ç½®è®¾å¤‡IDï¼ˆè°ƒè¯•ç”¨ï¼‰
    setDeviceId(newDeviceId) {
        console.log('ğŸ”§ æ‰‹åŠ¨è®¾ç½®è®¾å¤‡ID:', newDeviceId);
        localStorage.setItem('wenting_device_id', newDeviceId);
        this.deviceId = newDeviceId;
        
        // è§¦å‘è®¾å¤‡IDæ›´æ–°äº‹ä»¶
        window.dispatchEvent(new CustomEvent('deviceIdUpdated', {
            detail: { deviceId: newDeviceId }
        }));
        
        return newDeviceId;
    },

    // åŒæ­¥è®¾å¤‡IDåˆ°æ•°æ®åº“ä¸­çš„ç”¨æˆ·è®°å½•
    async syncDeviceIdToDatabase() {
        const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        if (!currentAppUser || !this.deviceId) {
            return;
        }
        
        try {
            console.log('ğŸ”„ å°è¯•å°†è®¾å¤‡IDåŒæ­¥åˆ°æ•°æ®åº“ç”¨æˆ·è®°å½•...');
            
            // ä½¿ç”¨ApiClientçš„åŠ¨æ€URLæ„å»ºé€»è¾‘
            if (!window.ApiClient) {
                console.error('âŒ ApiClientæœªåˆå§‹åŒ–');
                return;
            }
            
            const data = await window.ApiClient.post('/auth/update-device-id', {
                app_user_id: currentAppUser,
                device_id: this.deviceId
            });
            
            console.log('âœ… è®¾å¤‡IDåŒæ­¥æˆåŠŸ:', data);
        } catch (error) {
            console.error('è®¾å¤‡IDåŒæ­¥å¤±è´¥:', error);
        }
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.DeviceManager = DeviceManager;

// è°ƒè¯•æ–¹æ³•
window.debugResetDevice = function() {
    console.log('ğŸ”§ è°ƒè¯•ï¼šé‡ç½®è®¾å¤‡ID');
    DeviceManager.resetDeviceId();
    location.reload();
};

window.debugShowDeviceInfo = function() {
    console.log('ğŸ“± å½“å‰è®¾å¤‡ä¿¡æ¯:');
    console.log('  è®¾å¤‡ID:', DeviceManager.getCurrentDeviceId());
    console.log('  è®¾å¤‡ä¿¡æ¯:', DeviceManager.getDeviceInformation());
};

window.debugSetDeviceId = function(deviceId) {
    console.log('ğŸ”§ è°ƒè¯•ï¼šæ‰‹åŠ¨è®¾ç½®è®¾å¤‡ID');
    DeviceManager.setDeviceId(deviceId);
    console.log('âœ… è®¾å¤‡IDå·²è®¾ç½®ï¼Œè¯·åˆ·æ–°é¡µé¢');
};

window.debugSyncDeviceId = function() {
    console.log('ğŸ”„ è°ƒè¯•ï¼šåŒæ­¥è®¾å¤‡IDåˆ°æ•°æ®åº“');
    DeviceManager.syncDeviceIdToDatabase();
};


// APIå®¢æˆ·ç«¯ - è¿æ¥å‰ç«¯å’Œåç«¯
const ApiClient = {
    // åŠ¨æ€è·å–APIåŸºç¡€URL
    get baseURL() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol;
        let apiHost;

        // è‡ªåŠ¨é€‚é… cloudflare tunnel çš„ https åŸŸå
        if (protocol === 'https:' && hostname.endsWith('.trycloudflare.com')) {
            // ç›´æ¥ç”¨å½“å‰åŸŸåçš„ httpsï¼Œä¸”ä¸åŠ ç«¯å£
            apiHost = `https://${hostname}`;
        } else if (hostname === '192.168.3.5') {
            apiHost = 'http://192.168.3.5:3001';
        } else if (hostname === 'localhost' || hostname === '127.0.0.1') {
            apiHost = 'http://localhost:3001';
        } else {
            // é»˜è®¤ä½¿ç”¨å½“å‰ä¸»æœºçš„3001ç«¯å£
            apiHost = `http://${hostname}:3001`;
        }

        return `${apiHost}/api`;
    },
    
    // é€šç”¨è¯·æ±‚æ–¹æ³•
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        
        // æ·»åŠ è®¾å¤‡IDå’Œå½“å‰ç™»å½•ç”¨æˆ·åˆ°è¯·æ±‚å¤´
        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const currentAppUser = localStorage.getItem('wenting_current_app_user');
        
        const config = {
            headers: {
                'Content-Type': 'application/json',
                'X-Device-ID': deviceId,
                'X-App-User': currentAppUser,
                ...options.headers
            },
            ...options
        };

        if (config.body && typeof config.body === 'object') {
            config.body = JSON.stringify(config.body);
        }

        try {
            console.log('ğŸŒ å‘é€APIè¯·æ±‚:', url, config);
            const response = await fetch(url, config);
            console.log('ğŸ“¡ æ”¶åˆ°å“åº”:', response.status, response.statusText);
            
            let data;
            try {
                data = await response.json();
                console.log('ğŸ“„ å“åº”æ•°æ®:', data);
            } catch (jsonError) {
                console.error('JSONè§£æå¤±è´¥:', jsonError);
                throw new Error('æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯');
            }
            
            if (!response.ok) {
                let errorMessage = data.message || `HTTP error! status: ${response.status}`;
                
                // å¦‚æœæœ‰è¯¦ç»†çš„éªŒè¯é”™è¯¯ï¼Œæ˜¾ç¤ºå®ƒä»¬
                if (data.errors && Array.isArray(data.errors)) {
                    errorMessage += ': ' + data.errors.join(', ');
                }
                
                console.error('âŒ APIè¯·æ±‚å¤±è´¥:', errorMessage);
                console.error('âŒ å®Œæ•´é”™è¯¯ä¿¡æ¯:', data);
                throw new Error(errorMessage);
            }
            
            return data;
        } catch (error) {
            console.error('âŒ APIè¯·æ±‚å¼‚å¸¸:', error);
            
            // å¤„ç†ç½‘ç»œé”™è¯¯
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
                throw new Error('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦è¿è¡Œ');
            }
            
            throw error;
        }
    },

    // GETè¯·æ±‚
    async get(endpoint) {
        return this.request(endpoint, { method: 'GET' });
    },

    // POSTè¯·æ±‚
    async post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            body: data
        });
    },

    // PUTè¯·æ±‚
    async put(endpoint, data) {
        return this.request(endpoint, {
            method: 'PUT',
            body: data
        });
    },

    // DELETEè¯·æ±‚
    async delete(endpoint) {
        return this.request(endpoint, { method: 'DELETE' });
    },

    // ç”¨æˆ·ç›¸å…³API
    users: {
        // è·å–æ‰€æœ‰ç”¨æˆ·ï¼ˆæ”¯æŒè·¨è®¾å¤‡è®¿é—®ï¼‰
        async getAll() {
            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            
            console.log('ğŸ” ApiClient.users.getAll è°ƒè¯•ä¿¡æ¯:');
            console.log('  - deviceId:', deviceId);
            console.log('  - appUserId:', appUserId);
            console.log('  - localStorage keys:', Object.keys(localStorage));
            
            if (!appUserId) {
                console.error('âŒ ç”¨æˆ·æœªç™»å½•ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ');
                // è‡ªåŠ¨è·³è½¬åˆ°ç™»å½•é¡µ
                window.location.href = 'login.html';
                throw new Error('ç”¨æˆ·æœªç™»å½•ï¼Œæ­£åœ¨è·³è½¬åˆ°ç™»å½•é¡µ...');
            }
            
            // ä½¿ç”¨è·¨è®¾å¤‡æŸ¥è¯¢æ¨¡å¼ï¼ˆæ¨èï¼‰
            let url = `/users?app_user_id=${encodeURIComponent(appUserId)}`;
            
            // å¦‚æœæœ‰è®¾å¤‡IDï¼Œä¹Ÿä¼ é€’ç»™åç«¯ï¼ˆç”¨äºå®¡è®¡å’Œå…¼å®¹æ€§ï¼‰
            if (deviceId) {
                url += `&device_id=${encodeURIComponent(deviceId)}`;
            }
            
            console.log('ğŸ“¡ å‘é€ç”¨æˆ·åˆ—è¡¨è¯·æ±‚ï¼ˆè·¨è®¾å¤‡æ¨¡å¼ï¼‰:', url);
            
            return ApiClient.get(url);
        },

        // æ ¹æ®IDè·å–ç”¨æˆ·
        async getById(id) {
            return ApiClient.get(`/users/${id}`);
        },

        // åˆ›å»ºç”¨æˆ·
        async create(userData) {
            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            
            console.log('ğŸ” ApiClient.users.create è°ƒè¯•ä¿¡æ¯:');
            console.log('  - deviceId:', deviceId);
            console.log('  - appUserId:', appUserId);
            
            if (!deviceId) {
                console.error('âŒ è®¾å¤‡IDæœªåˆå§‹åŒ–');
                throw new Error('è®¾å¤‡IDæœªåˆå§‹åŒ–ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
            
            if (!appUserId) {
                console.error('âŒ ç”¨æˆ·æœªç™»å½•ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ');
                // è‡ªåŠ¨è·³è½¬åˆ°ç™»å½•é¡µ
                window.location.href = 'login.html';
                throw new Error('ç”¨æˆ·æœªç™»å½•ï¼Œæ­£åœ¨è·³è½¬åˆ°ç™»å½•é¡µ...');
            }
            
            // æ·»åŠ è®¾å¤‡IDå’Œæ³¨å†Œç”¨æˆ·IDåˆ°ç”¨æˆ·æ•°æ®
            const userDataWithDevice = {
                ...userData,
                device_id: deviceId,
                app_user_id: appUserId
            };
            
            console.log('ğŸ“¤ å‘é€åˆ›å»ºç”¨æˆ·è¯·æ±‚ï¼Œæ•°æ®:', userDataWithDevice);
            
            return ApiClient.post('/users', userDataWithDevice);
        },

        // æ›´æ–°ç”¨æˆ·
        async update(id, userData) {
            return ApiClient.put(`/users/${id}`, userData);
        },

        // åˆ é™¤ç”¨æˆ·
        async delete(id) {
            return ApiClient.delete(`/users/${id}`);
        },

        // è·å–ç”¨æˆ·è®¾ç½®
        async getSettings(id) {
            return ApiClient.get(`/users/${id}/settings`);
        },

        // æ›´æ–°ç”¨æˆ·è®¾ç½®
        async updateSettings(id, settings) {
            return ApiClient.put(`/users/${id}/settings`, settings);
        }
    },

    // TODOç›¸å…³API
    todos: {
        // è·å–ç”¨æˆ·çš„æ‰€æœ‰TODO
        async getByUserId(userId) {
            return ApiClient.get(`/todos/user/${userId}`);
        },

        // è·å–ç”¨æˆ·ä»Šæ—¥TODO
        async getTodayTodos(userId) {
            return ApiClient.get(`/todos/user/${userId}/today`);
        },

        // è·å–ç”¨æˆ·æŒ‡å®šæ—¥æœŸçš„TODO
        async getTodosForDate(userId, date) {
            return ApiClient.get(`/todos/user/${userId}/date/${date}`);
        },

        // æ ¹æ®IDè·å–TODO
        async getById(id) {
            return ApiClient.get(`/todos/${id}`);
        },

        // åˆ›å»ºTODO
        async create(todoData) {
            return ApiClient.post('/todos', todoData);
        },

        // æ›´æ–°TODO
        async update(id, todoData) {
            return ApiClient.put(`/todos/${id}`, todoData);
        },

        // åˆ é™¤TODO
        async delete(id, deletionType = 'all', deletionDate = null) {
            return ApiClient.request(`/todos/${id}`, {
                method: 'DELETE',
                body: { deletion_type: deletionType, deletion_date: deletionDate }
            });
        },

        // å®ŒæˆTODO
        async complete(id, userId, date, notes = '') {
            return ApiClient.post(`/todos/${id}/complete`, {
                user_id: userId,
                date: date,
                notes
            });
        },

        // å–æ¶ˆå®ŒæˆTODO
        async uncomplete(id, date, userId) {
            return ApiClient.post(`/todos/${id}/uncomplete`, {
                date: date,
                user_id: userId
            });
        }
    },

    // é‡å¤æ¨¡å¼ç›¸å…³API
    patterns: {
        // è·å–æ‰€æœ‰é‡å¤æ¨¡å¼
        async getAll() {
            return ApiClient.get('/patterns');
        },

        // è·å–é¢„è®¾é‡å¤æ¨¡å¼
        async getPresets() {
            return ApiClient.get('/patterns/presets');
        },

        // æ ¹æ®IDè·å–é‡å¤æ¨¡å¼
        async getById(id) {
            return ApiClient.get(`/patterns/${id}`);
        },

        // åˆ›å»ºé‡å¤æ¨¡å¼
        async create(patternData) {
            return ApiClient.post('/patterns', patternData);
        },

        // åˆ›å»ºé¢„è®¾é‡å¤æ¨¡å¼
        async createPreset(name) {
            return ApiClient.post(`/patterns/presets/${name}`);
        },

        // æ£€æŸ¥æ—¥æœŸæ˜¯å¦åŒ¹é…æ¨¡å¼
        async checkDateMatch(id, targetDate, startDate) {
            return ApiClient.post(`/patterns/${id}/check`, {
                targetDate,
                startDate
            });
        },

        // è·å–ä¸‹ä¸€ä¸ªåŒ¹é…æ—¥æœŸ
        async getNextMatchDate(id, currentDate, startDate) {
            return ApiClient.post(`/patterns/${id}/next`, {
                currentDate,
                startDate
            });
        },

        // è·å–æ—¶é—´èŒƒå›´å†…çš„åŒ¹é…æ—¥æœŸ
        async getMatchDatesInRange(id, startDate, rangeStart, rangeEnd) {
            return ApiClient.post(`/patterns/${id}/range`, {
                startDate,
                rangeStart,
                rangeEnd
            });
        }
    },

    // Notesç›¸å…³API
    notes: {
        // è·å–ç”¨æˆ·çš„æ‰€æœ‰Notes
        async getByUserId(userId) {
            return ApiClient.get(`/notes/user/${userId}`);
        },

        // æ ¹æ®IDè·å–Note
        async getById(id) {
            return ApiClient.get(`/notes/${id}`);
        },

        // åˆ›å»ºNote
        async create(noteData) {
            return ApiClient.post('/notes', noteData);
        },

        // æ›´æ–°Note
        async update(id, noteData) {
            return ApiClient.put(`/notes/${id}`, noteData);
        },

        // åˆ é™¤Note
        async delete(id) {
            return ApiClient.delete(`/notes/${id}`);
        },

        // æœç´¢Notes
        async search(searchTerm, userId = null) {
            const params = userId ? `?userId=${userId}` : '';
            return ApiClient.get(`/notes/search/${encodeURIComponent(searchTerm)}${params}`);
        },

        // ç”ŸæˆAIå»ºè®®ï¼ˆä¼ é€’çœŸå®å¤©æ°”æ•°æ®ï¼‰
        async generateAISuggestions(id) {
            // è·å–ç”¨æˆ·ä½ç½®ä¿¡æ¯
            console.log('ğŸ” å¼€å§‹è·å–ç”¨æˆ·ä½ç½®å’Œå¤©æ°”ä¿¡æ¯...');
            
            let userLocation = null;
            
            // æ£€æŸ¥WeatherManageræ˜¯å¦å­˜åœ¨å’Œåˆå§‹åŒ–
            if (!window.WeatherManager) {
                console.log('âŒ WeatherManageræœªåˆå§‹åŒ–ï¼Œæ— æ³•è·å–ä½ç½®ä¿¡æ¯');
            } else {
                console.log('âœ… WeatherManagerå·²åˆå§‹åŒ–ï¼ŒçŠ¶æ€:', {
                    locationReady: window.WeatherManager.locationReady,
                    hasUserLocation: !!window.WeatherManager.userLocation
                });
                
                if (window.WeatherManager.locationReady && window.WeatherManager.userLocation) {
                    userLocation = window.WeatherManager.userLocation;
                    console.log('ğŸ“ ç›´æ¥è·å–åˆ°ç”¨æˆ·ä½ç½®:', userLocation);
                } else {
                    console.log('â³ ç”¨æˆ·ä½ç½®è¿˜æœªå‡†å¤‡å¥½ï¼Œå°è¯•ç­‰å¾…è·å–...');
                    
                    // ç­‰å¾…ä½ç½®è·å–å®Œæˆï¼Œæœ€å¤šç­‰å¾…5ç§’
                    let attempts = 0;
                    const MAX_ATTEMPTS = 10; // 5ç§’å†…æ£€æŸ¥10æ¬¡
                    
                    while (attempts < MAX_ATTEMPTS && !userLocation) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        if (window.WeatherManager.locationReady && window.WeatherManager.userLocation) {
                            userLocation = window.WeatherManager.userLocation;
                            console.log('ğŸ“ ç­‰å¾…åè·å–åˆ°ç”¨æˆ·ä½ç½®:', userLocation);
                            break;
                        }
                        
                        attempts++;
                        console.log(`â³ ä½ç½®è·å–å°è¯• ${attempts}/${MAX_ATTEMPTS}`);
                    }
                    
                    if (!userLocation) {
                        console.log('âŒ ç­‰å¾…è¶…æ—¶ï¼Œæ— æ³•è·å–ç”¨æˆ·ä½ç½®');
                        console.log('ğŸ” æœ€ç»ˆWeatherManagerçŠ¶æ€:', {
                            locationReady: window.WeatherManager.locationReady,
                            userLocation: window.WeatherManager.userLocation
                        });
                    }
                }
            }
            
            // è·å–å¤©æ°”æ•°æ®
            console.log('ğŸŒ¤ï¸ å¼€å§‹è·å–å¤©æ°”æ•°æ®...');
            let weatherData = null;
            
            if (window.WeatherManager && window.WeatherManager.weatherData) {
                weatherData = window.WeatherManager.weatherData;
                console.log('ğŸŒ¤ï¸ è·å–åˆ°å¤©æ°”æ•°æ®:', weatherData);
            } else {
                console.log('âŒ WeatherManagerä¸­æ— å¤©æ°”æ•°æ®');
            }
            
            console.log('ğŸ“ æœ€ç»ˆå‘é€ç»™AIæœåŠ¡çš„ä½ç½®:', userLocation);
            console.log('ğŸŒ¤ï¸ æœ€ç»ˆå‘é€ç»™AIæœåŠ¡çš„å¤©æ°”æ•°æ®:', weatherData);
            
            return ApiClient.post(`/notes/${id}/ai-suggestions`, {
                userLocation: userLocation,
                weatherData: weatherData
            });
        }
    },

    // è®¤è¯ç›¸å…³API
    auth: {
        // æ³¨å†Œ
        async register(username, password) {
            // è®¤è¯APIä¸éœ€è¦åœ¨headersä¸­æ·»åŠ å½“å‰ç”¨æˆ·ä¿¡æ¯
            return fetch(`${ApiClient.baseURL}/auth/register`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            }).then(response => response.json());
        },

        // ç™»å½•
        async login(username, password) {
            return fetch(`${ApiClient.baseURL}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            }).then(response => response.json());
        },

        // éªŒè¯ç™»å½•çŠ¶æ€
        async verify(username) {
            return fetch(`${ApiClient.baseURL}/auth/verify?username=${encodeURIComponent(username)}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());
        },

        // è·å–ç”¨æˆ·èµ„æ–™ï¼ˆç”¨äºProfileé¡µé¢ï¼‰
        async getProfile(username) {
            return fetch(`${ApiClient.baseURL}/auth/profile/${encodeURIComponent(username)}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());
        }
    },

    // å¥åº·æ£€æŸ¥
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseURL.replace('/api', '')}/health`);
            return await response.json();
        } catch (error) {
            console.error('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
            return { success: false, message: 'æœåŠ¡å™¨è¿æ¥å¤±è´¥' };
        }
    },

    // æµ‹è¯•è¿æ¥
    async testConnection() {
        try {
            const health = await this.healthCheck();
            if (health.success) {
                console.log('âœ… åç«¯æœåŠ¡è¿æ¥æˆåŠŸ');
                return true;
            } else {
                console.warn('âš ï¸ åç«¯æœåŠ¡å“åº”å¼‚å¸¸:', health.message);
                return false;
            }
        } catch (error) {
            console.error('âŒ åç«¯æœåŠ¡è¿æ¥å¤±è´¥:', error.message);
            return false;
        }
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.ApiClient = ApiClient;


// WebSocketå®¢æˆ·ç«¯ - å®æ—¶é€šä¿¡ç®¡ç†
const WebSocketClient = {
    ws: null,
    isConnected: false,
    reconnectAttempts: 0,
    MAX_RECONNECT_ATTEMPTS: 5,
    RECONNECT_INTERVAL: 2000,
    HEARTBEAT_INTERVAL: null,
    REQUEST_TIMEOUT: 120000, // 120ç§’è¶…æ—¶
    REGISTRATION_TIMEOUT: 5000, // 5ç§’æ³¨å†Œè¶…æ—¶
    messageHandlers: new Map(),
    lastDataStatus: {
        lastTodoUpdate: null,
        lastNoteUpdate: null,
        hasLinkedData: false
    },
    
    // è·å–WebSocket URL
    getWebSocketURL() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        let wsHost;

        // è‡ªåŠ¨é€‚é… cloudflare tunnel çš„åŸŸå
        if (protocol === 'wss:' && hostname.endsWith('.trycloudflare.com')) {
            wsHost = `wss://${hostname}`;
        } else if (hostname === '192.168.3.5') {
            wsHost = 'ws://192.168.3.5:3001';
        } else if (hostname === 'localhost' || hostname === '127.0.0.1') {
            wsHost = 'ws://localhost:3001';
        } else {
            wsHost = `ws://${hostname}:3001`;
        }

        return `${wsHost}/ws`;
    },

    // åˆå§‹åŒ–WebSocketè¿æ¥
    async init() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            console.log('âš ï¸ WebSocketå·²è¿æ¥ï¼Œæ— éœ€é‡å¤åˆå§‹åŒ–');
            return true;
        }

        return new Promise((resolve, reject) => {
            try {
                const wsUrl = this.getWebSocketURL();
                console.log('ğŸ”„ æ­£åœ¨è¿æ¥WebSocket:', wsUrl);
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('âœ… WebSocketè¿æ¥æˆåŠŸ');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.startHeartbeat();
                    
                    // è¿æ¥å»ºç«‹åç«‹å³å‘é€æ³¨å†Œæ¶ˆæ¯
                    this.sendRegistrationMessage();
                    
                    resolve(true);
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        console.error('âŒ WebSocketæ¶ˆæ¯è§£æå¤±è´¥:', error);
                    }
                };

                this.ws.onclose = (event) => {
                    console.log('ğŸ”Œ WebSocketè¿æ¥å…³é—­:', event.code, event.reason);
                    this.isConnected = false;
                    this.stopHeartbeat();
                    
                    // å¦‚æœä¸æ˜¯ä¸»åŠ¨å…³é—­ï¼Œå°è¯•é‡è¿
                    if (event.code !== 1000 && this.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
                        this.scheduleReconnect();
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('âŒ WebSocketè¿æ¥é”™è¯¯:', error);
                    this.isConnected = false;
                    reject(error);
                };

            } catch (error) {
                console.error('âŒ WebSocketåˆå§‹åŒ–å¤±è´¥:', error);
                reject(error);
            }
        });
    },

    // å‘é€æ¶ˆæ¯
    async sendMessage(type, data = {}) {
        if (!this.isConnected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocketæœªè¿æ¥');
        }

        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const userId = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;

        const message = {
            type,
            deviceId,
            userId,
            appUserId,
            data,
            timestamp: Date.now()
        };

        return new Promise((resolve, reject) => {
            try {
                // æ³¨å†Œå“åº”å¤„ç†å™¨
                const responseType = `${type}_RESPONSE`;
                const errorType = `${type}_ERROR`;
                
                const timeout = setTimeout(() => {
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    console.warn(`âš ï¸ WebSocketè¯·æ±‚è¶…æ—¶: ${type}`, data);
                    reject(new Error('è¯·æ±‚è¶…æ—¶'));
                }, this.REQUEST_TIMEOUT);

                this.messageHandlers.set(responseType, (response) => {
                    clearTimeout(timeout);
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    resolve(response);
                });

                this.messageHandlers.set(errorType, (error) => {
                    clearTimeout(timeout);
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    reject(new Error(error.error || 'è¯·æ±‚å¤±è´¥'));
                });

                // å‘é€æ¶ˆæ¯
                this.ws.send(JSON.stringify(message));
                console.log('ğŸ“¤ å‘é€WebSocketæ¶ˆæ¯:', type, data);
                
            } catch (error) {
                reject(error);
            }
        });
    },

    // å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
    handleMessage(message) {
        const { type } = message;
        this._logMessageReceived(type, message);
        
        if (this._handleSpecialMessages(type, message)) return;
        if (this._handleRegisteredHandlers(type, message)) return;
        if (this._handleHeartbeatMessages(type, message)) return;
        if (this._handleSyncMessages(type, message)) return;
        if (this._handleBroadcastMessages(type, message)) return;
        if (this._handleLinkMessages(type, message)) return;
        if (this._handleResponseMessages(type, message)) return;
        
        console.log('âš ï¸ æœªå¤„ç†çš„æ¶ˆæ¯ç±»å‹:', type);
    },

    // è®°å½•æ¶ˆæ¯æ¥æ”¶
    _logMessageReceived(type, message) {
        console.log('ğŸ“¥ æ”¶åˆ°WebSocketæ¶ˆæ¯:', type, message);
        
        const currentAppUser = localStorage.getItem('wenting_current_app_user');
        console.log(`ğŸ” [WebSocket] æ¶ˆæ¯æ¥æ”¶è°ƒè¯•:`, {
            messageType: type,
            currentAppUser: currentAppUser,
            timestamp: new Date().toISOString(),
            messageData: message
        });
    },

    // å¤„ç†ç‰¹æ®Šæ¶ˆæ¯
    _handleSpecialMessages(type, message) {
        if (type === 'USER_REGISTRATION_RESPONSE') {
            this._handleRegistrationResponse(message);
            return true;
        }
        return false;
    },

    // å¤„ç†æ³¨å†Œå“åº”
    _handleRegistrationResponse(message) {
        if (this.registrationTimeout) {
            clearTimeout(this.registrationTimeout);
            this.registrationTimeout = null;
        }
        console.log('âœ… WebSocketæ³¨å†Œç¡®è®¤æ”¶åˆ°:', message);
    },

    // å¤„ç†å·²æ³¨å†Œçš„å¤„ç†å™¨
    _handleRegisteredHandlers(type, message) {
        if (this.messageHandlers.has(type)) {
            const handler = this.messageHandlers.get(type);
            handler(message);
            return true;
        }
        return false;
    },

    // å¤„ç†å¿ƒè·³æ¶ˆæ¯
    _handleHeartbeatMessages(type, message) {
        if (type === 'PONG' || type === 'PING_RESPONSE') {
            console.log('ğŸ’— æ”¶åˆ°å¿ƒè·³å“åº”');
            this.handleHeartbeatResponse(message);
            return true;
        }
        return false;
    },

    // å¤„ç†åŒæ­¥æ¶ˆæ¯
    _handleSyncMessages(type, message) {
        if (type === 'TODO_SYNC_UPDATE' || type === 'NOTES_SYNC_UPDATE' || type === 'DATA_SYNC_UPDATE') {
            this._logSyncMessage(type, message);
            this.handleSyncMessage(message);
            return true;
        }
        return false;
    },


    // è®°å½•NotesåŒæ­¥
    _logNotesSync(message) {
        console.log(`ğŸ“ [NOTES_SYNC] blackbladeæ”¶åˆ°NotesåŒæ­¥æ¶ˆæ¯:`, {
            fromUser: message.sync?.fromUser,
            operation: message.operation,
            userId: message.sync?.userId,
            currentAppUser: localStorage.getItem('wenting_current_app_user'),
            timestamp: new Date().toISOString()
        });
    },

    // å¤„ç†å¹¿æ’­æ¶ˆæ¯
    _handleBroadcastMessages(type, message) {
        if (type.endsWith('_BROADCAST')) {
            this.handleBroadcast(message);
            return true;
        }
        return false;
    },

    // å¤„ç†Linkæ¶ˆæ¯
    _handleLinkMessages(type, message) {
        if (type.startsWith('LINK_')) {
            this.handleLinkNotification(message);
            return true;
        }
        return false;
    },

    // å¤„ç†å“åº”æ¶ˆæ¯
    _handleResponseMessages(type, message) {
        if (type.endsWith('_RESPONSE')) {
            console.log(`ğŸ“¨ æ”¶åˆ°å“åº”æ¶ˆæ¯: ${type}`, message.success ? 'âœ…' : 'âŒ');
            return true;
        }
        return false;
    },

    // ğŸ”¥ æ–°å¢ï¼šç»Ÿä¸€çš„åŒæ­¥æ¶ˆæ¯å¤„ç†æ–¹æ³•
    handleSyncMessage(message) {
        const syncContext = this._parseSyncMessage(message);
        const isRelevantPage = this._isRelevantPageForSync(syncContext);
        
        this._logSyncMessage(syncContext, isRelevantPage);
        this._performDataSync(syncContext);
        this._showSyncNotification(syncContext, isRelevantPage);
        this._notifyManagersForSync(syncContext, message);
    },

    // è§£æåŒæ­¥æ¶ˆæ¯
    _parseSyncMessage(message) {
        const { type, operation, sync } = message;
        const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : 'unknown';
        
        return {
            type,
            operation,
            sync,
            currentModule,
            dataType: this._getDataTypeFromSyncType(type)
        };
    },

    // è·å–æ•°æ®ç±»å‹
    _getDataTypeFromSyncType(syncType) {
        if (syncType === 'TODO_SYNC_UPDATE') return 'todos';
        if (syncType === 'NOTES_SYNC_UPDATE') return 'notes';
        return 'all';
    },

    // æ£€æŸ¥æ˜¯å¦ä¸ºç›¸å…³é¡µé¢
    _isRelevantPageForSync(syncContext) {
        const { type, currentModule } = syncContext;
        return (type === 'TODO_SYNC_UPDATE' && currentModule === 'todo') ||
               (type === 'NOTES_SYNC_UPDATE' && currentModule === 'notes');
    },

    // è®°å½•åŒæ­¥æ¶ˆæ¯
    _logSyncMessage(syncContext, isRelevantPage) {
        const { type, operation, currentModule, sync } = syncContext;
        
        console.log(`ğŸ”„ [SYNC] å¤„ç†åŒæ­¥æ¶ˆæ¯:`, {
            type,
            operation,
            currentModule,
            fromUser: sync?.fromUser,
            userId: sync?.userId
        });

        if (!isRelevantPage) {
            console.log(`â¸ï¸ [SYNC] å½“å‰é¡µé¢(${currentModule})ä¸åŒæ­¥ç±»å‹(${type})ä¸åŒ¹é…ï¼Œåªè¿›è¡Œåå°æ•°æ®åŒæ­¥`);
        }
    },

    // æ‰§è¡Œæ•°æ®åŒæ­¥
    _performDataSync(syncContext) {
        this.reloadApplicationData(syncContext.dataType, true);
    },

    // æ˜¾ç¤ºåŒæ­¥é€šçŸ¥
    _showSyncNotification(syncContext, isRelevantPage) {
        const { operation, type, sync } = syncContext;
        
        if (sync && sync.fromUser) {
            const operationText = this._getOperationText(operation);
            const itemType = type.includes('TODO') ? 'å¾…åŠäº‹é¡¹' : 'ç¬”è®°';
            const syncType = isRelevantPage ? 'å·²åŒæ­¥' : 'åå°åŒæ­¥';
            
            this.showSyncNotification(
                `${sync.fromUser} ${operationText}äº†${itemType} (${syncType})`, 
                isRelevantPage ? 'success' : 'info'
            );
        }
    },

    // è·å–æ“ä½œæ–‡æœ¬
    _getOperationText(operation) {
        const operationTexts = {
            'COMPLETE': 'å®Œæˆ',
            'UNCOMPLETE': 'å–æ¶ˆå®Œæˆ',
            'CREATE': 'åˆ›å»º',
            'UPDATE': 'æ›´æ–°',
            'DELETE': 'åˆ é™¤'
        };
        return operationTexts[operation] || operation;
    },

    // é€šçŸ¥ç®¡ç†å™¨å¤„ç†åŒæ­¥
    _notifyManagersForSync(syncContext, message) {
        const { type } = syncContext;
        
        if (type === 'TODO_SYNC_UPDATE' && window.TodoManager) {
            window.TodoManager.handleWebSocketBroadcast('TODO_SYNC_UPDATE', message);
        } else if (type === 'NOTES_SYNC_UPDATE' && window.NotesManager) {
            console.log('ğŸ”„ [WebSocket] è°ƒç”¨NotesManagerå¤„ç†åŒæ­¥æ¶ˆæ¯');
            window.NotesManager.handleWebSocketBroadcast('NOTES_SYNC_UPDATE', message);
        }
    },

    // å¤„ç†å¹¿æ’­æ¶ˆæ¯ï¼ˆå…¶ä»–è®¾å¤‡çš„æ“ä½œï¼‰
    handleBroadcast(message) {
        const { type, data } = message;
        console.log('ğŸ“¡ å¤„ç†å¹¿æ’­æ¶ˆæ¯:', type);

        // æ ¹æ®æ¶ˆæ¯ç±»å‹æ›´æ–°ç•Œé¢
        switch (type) {
            case 'TODO_CREATE_BROADCAST':
            case 'TODO_UPDATE_BROADCAST':
            case 'TODO_DELETE_BROADCAST':
            case 'TODO_COMPLETE_BROADCAST':
            case 'TODO_UNCOMPLETE_BROADCAST':
                // é€šçŸ¥TODOç®¡ç†å™¨æ›´æ–°ç•Œé¢
                if (window.TodoManager) {
                    window.TodoManager.handleWebSocketBroadcast(type, data);
                }
                break;
                
            case 'NOTES_CREATE_BROADCAST':
            case 'NOTES_UPDATE_BROADCAST':
            case 'NOTES_DELETE_BROADCAST':
                // é€šçŸ¥Notesç®¡ç†å™¨æ›´æ–°ç•Œé¢
                if (window.NotesManager) {
                    window.NotesManager.handleWebSocketBroadcast(type, data);
                }
                break;
                
        }
    },

    // å¤„ç†Linkç›¸å…³é€šçŸ¥æ¶ˆæ¯
    handleLinkNotification(message) {
        const { type, data } = message;
        console.log('ğŸ”— [WebSocket] å¤„ç†Linké€šçŸ¥:', type, data);

        const handler = this._getLinkNotificationHandler(type);
        if (handler) {
            handler(data, type);
        } else {
            console.log('âš ï¸ [WebSocket] æœªå¤„ç†çš„Linké€šçŸ¥ç±»å‹:', type);
        }
    },

    // è·å–Linké€šçŸ¥å¤„ç†å™¨
    _getLinkNotificationHandler(type) {
        const handlers = {
            'LINK_REQUEST_RECEIVED': this._handleLinkRequestReceived.bind(this),
            'LINK_INVITATION_ACCEPTED': this._handleLinkStatusChange.bind(this),
            'LINK_INVITATION_REJECTED': this._handleLinkStatusChange.bind(this),
            'LINK_ACCEPTED': this._handleLinkStatusChange.bind(this),
            'LINK_CANCELLED': this._handleLinkStatusChange.bind(this),
            'LINK_ESTABLISHED': this._handleLinkEstablished.bind(this),
            'DATA_SYNC_UPDATE': this._handleDataSyncUpdate.bind(this)
        };
        
        return handlers[type];
    },

    // å¤„ç†Linkè¯·æ±‚æ¥æ”¶
    _handleLinkRequestReceived(data) {
        console.log('ğŸ“¨ [WebSocket] æ”¶åˆ°å…³è”é‚€è¯·:', data);
        this._callAppMethod('showLinkInvitationDialog', data);
    },

    // å¤„ç†LinkçŠ¶æ€å˜æ›´
    _handleLinkStatusChange(data, type) {
        console.log(`ğŸ”— [WebSocket] LinkçŠ¶æ€å˜æ›´:`, type || 'unknown', data);
        this._callAppMethod('handleLinkStatusChange', type, data);
    },

    // å¤„ç†Linkå»ºç«‹æˆåŠŸ
    _handleLinkEstablished(data) {
        console.log(`ğŸ”— [WebSocket] Linkå»ºç«‹æˆåŠŸ:`, data);
        console.log('ğŸ”„ [WebSocket] è§¦å‘åº”ç”¨æ•°æ®åˆ·æ–°...');
        this._callAppMethod('refreshApplicationAfterLink');
    },

    // å¤„ç†æ•°æ®åŒæ­¥æ›´æ–°
    _handleDataSyncUpdate(data) {
        console.log('ğŸ”„ [WebSocket] æ•°æ®åŒæ­¥æ›´æ–°:', data);
        this._callAppMethod('handleDataSyncUpdate', data);
    },

    // å®‰å…¨è°ƒç”¨Appæ–¹æ³•
    _callAppMethod(methodName, ...args) {
        if (window.App && typeof window.App[methodName] === 'function') {
            window.App[methodName](...args);
        } else {
            console.error(`âŒ App.${methodName} æ–¹æ³•ä¸å­˜åœ¨`);
        }
    },

    // å¤„ç†æ•°æ®åŒæ­¥æ›´æ–°æ¶ˆæ¯
    handleDataSyncUpdate(message) {
        const { data } = message;
        console.log('ğŸ”„ [WebSocket] å¤„ç†æ•°æ®åŒæ­¥æ›´æ–°:', data);
        
        if (window.App && window.App.handleDataSyncUpdate) {
            window.App.handleDataSyncUpdate(data);
        } else {
            console.error('âŒ App.handleDataSyncUpdate æ–¹æ³•ä¸å­˜åœ¨');
        }
    },

    // å¿ƒè·³æ£€æµ‹
    startHeartbeat() {
        this.HEARTBEAT_INTERVAL = setInterval(() => {
            if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
                const deviceId = window.DeviceManager ? window.DeviceManager.deviceId : null;
                const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;
                
                this.ws.send(JSON.stringify({
                    type: 'PING',
                    timestamp: Date.now(),
                    deviceId: deviceId,
                    userId: currentUser ? currentUser.id : null,
                    appUserId: appUserId
                }));
            }
        }, 30000); // 30ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
    },

    stopHeartbeat() {
        if (this.HEARTBEAT_INTERVAL) {
            clearInterval(this.HEARTBEAT_INTERVAL);
            this.HEARTBEAT_INTERVAL = null;
        }
    },

    // è®¡åˆ’é‡è¿
    scheduleReconnect() {
        this.reconnectAttempts++;
        const delay = this.RECONNECT_INTERVAL * this.reconnectAttempts;
        
        console.log(`ğŸ”„ è®¡åˆ’åœ¨ ${delay}ms åé‡è¿ (å°è¯• ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS})`);
        
        setTimeout(() => {
            console.log(`ğŸ”„ å¼€å§‹ç¬¬ ${this.reconnectAttempts} æ¬¡é‡è¿å°è¯•`);
            this.init().catch(error => {
                console.error('âŒ é‡è¿å¤±è´¥:', error);
                if (this.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
                    this.scheduleReconnect();
                } else {
                    console.error('âŒ è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œæ”¾å¼ƒé‡è¿');
                    // é™çº§åˆ°HTTPæ¨¡å¼
                    this.fallbackToHTTP();
                }
            });
        }, delay);
    },

    // é™çº§åˆ°HTTPæ¨¡å¼
    fallbackToHTTP() {
        console.log('ğŸ“¡ WebSocketä¸å¯ç”¨ï¼Œé™çº§åˆ°HTTPæ¨¡å¼');
        // é€šçŸ¥å„ç®¡ç†å™¨åˆ‡æ¢åˆ°HTTPæ¨¡å¼
        if (window.TodoManager) {
            window.TodoManager.fallbackToHTTP();
        }
        if (window.NotesManager) {
            window.NotesManager.fallbackToHTTP();
        }
    },

    // å…³é—­è¿æ¥
    close() {
        this.stopHeartbeat();
        this.messageHandlers.clear();
        
        if (this.ws) {
            this.ws.close(1000, 'æ­£å¸¸å…³é—­');
            this.ws = null;
        }
        
        this.isConnected = false;
        console.log('ğŸ‘‹ WebSocketè¿æ¥å·²å…³é—­');
    },

    // TODOç›¸å…³APIæ–¹æ³•
    todos: {
        async getTodayTodos(userId) {
            return await WebSocketClient.sendMessage('TODO_GET_TODAY', { userId });
        },

        async getTodosForDate(userId, date) {
            return await WebSocketClient.sendMessage('TODO_GET_BY_DATE', { userId, date });
        },

        async create(todoData) {
            return await WebSocketClient.sendMessage('TODO_CREATE', todoData);
        },

        async update(todoId, updateData) {
            return await WebSocketClient.sendMessage('TODO_UPDATE', { todoId, updateData });
        },

        async delete(todoId, deletionType, deletionDate) {
            return await WebSocketClient.sendMessage('TODO_DELETE', { 
                todoId, deletionType, deletionDate 
            });
        },

        async complete(todoId, userId, date) {
            return await WebSocketClient.sendMessage('TODO_COMPLETE', { 
                todoId, userId, date 
            });
        },

        async uncomplete(todoId, date, userId) {
            return await WebSocketClient.sendMessage('TODO_UNCOMPLETE', { 
                todoId, date, userId 
            });
        }
    },

    // Notesç›¸å…³APIæ–¹æ³•
    notes: {
        async getByUserId(userId) {
            return await WebSocketClient.sendMessage('NOTES_GET_BY_USER', { userId });
        },

        async create(noteData) {
            return await WebSocketClient.sendMessage('NOTES_CREATE', noteData);
        },

        async update(noteId, updateData) {
            return await WebSocketClient.sendMessage('NOTES_UPDATE', { noteId, updateData });
        },

        async delete(noteId) {
            return await WebSocketClient.sendMessage('NOTES_DELETE', { noteId });
        },

        async generateAISuggestions(noteId, userLocation, weatherData) {
            return await WebSocketClient.sendMessage('NOTES_AI_SUGGESTIONS', { 
                noteId, userLocation, weatherData 
            });
        }
    },

    // LinkåŠŸèƒ½ç›¸å…³APIæ–¹æ³•
    links: {
        async checkLinkStatus(appUser) {
            return await WebSocketClient.sendMessage('LINK_CHECK_STATUS', { appUser });
        },

        async sendInvitation(toUser, supervisedUserId, message) {
            return await WebSocketClient.sendMessage('LINK_SEND_INVITATION', { 
                toUser, supervisedUserId, message 
            });
        },

        async acceptInvitation(requestId) {
            return await WebSocketClient.sendMessage('LINK_ACCEPT_INVITATION', { requestId });
        },

        async rejectInvitation(requestId) {
            return await WebSocketClient.sendMessage('LINK_REJECT_INVITATION', { requestId });
        },

        async cancelLink(linkId) {
            return await WebSocketClient.sendMessage('LINK_CANCEL', { linkId });
        }
    },

    // å‘é€æ³¨å†Œæ¶ˆæ¯
    sendRegistrationMessage() {
        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const userId = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;

        console.log('ğŸ” WebSocketæ³¨å†Œä¿¡æ¯è°ƒè¯•:', { deviceId, userId, appUserId });
        console.log('ğŸ” localStorageçŠ¶æ€:', {
            'wenting_current_app_user': localStorage.getItem('wenting_current_app_user'),
            'wenting_current_user': localStorage.getItem('wenting_current_user')
        });

        if (!deviceId) {
            console.error('âŒ ç¼ºå°‘deviceIdï¼Œæ— æ³•æ³¨å†ŒWebSocket');
            console.log('ğŸ’¡ è¯·æ£€æŸ¥ window.DeviceManager.getCurrentDeviceId()');
            // ğŸ”¥ æ–°å¢ï¼šå°è¯•ç”Ÿæˆä¸´æ—¶deviceId
            const tempDeviceId = 'temp_' + Math.random().toString(36).substr(2, 9);
            console.log('ğŸ”„ ç”Ÿæˆä¸´æ—¶deviceId:', tempDeviceId);
            return;
        }
        
        if (!appUserId) {
            console.error('âŒ ç¼ºå°‘appUserIdï¼Œæ— æ³•æ³¨å†ŒWebSocket');
            console.log('ğŸ’¡ å½“å‰localStorageçŠ¶æ€:', {
                'wenting_current_app_user': localStorage.getItem('wenting_current_app_user'),
                'wenting_current_user': localStorage.getItem('wenting_current_user')
            });
            return;
        }

        const registrationMessage = {
            type: 'USER_REGISTRATION',
            deviceId,
            userId,
            appUserId,
            timestamp: Date.now()
        };

        try {
            this.ws.send(JSON.stringify(registrationMessage));
            console.log('ğŸ“ ç”¨æˆ·æ³¨å†Œæ¶ˆæ¯å·²å‘é€:', registrationMessage);
            
            // ğŸ”¥ æ–°å¢ï¼šè®¾ç½®æ³¨å†Œç¡®è®¤è¶…æ—¶
            if (this.registrationTimeout) {
                clearTimeout(this.registrationTimeout);
            }
            this.registrationTimeout = setTimeout(() => {
                console.warn('âš ï¸ WebSocketæ³¨å†Œç¡®è®¤è¶…æ—¶ï¼Œå°è¯•é‡æ–°æ³¨å†Œ');
                this.sendRegistrationMessage();
            }, this.REGISTRATION_TIMEOUT);
            
        } catch (error) {
            console.error('âŒ å‘é€æ³¨å†Œæ¶ˆæ¯å¤±è´¥:', error);
            // é‡è¯•æœºåˆ¶
            setTimeout(() => {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    console.log('ğŸ”„ é‡è¯•å‘é€WebSocketæ³¨å†Œæ¶ˆæ¯...');
                    this.sendRegistrationMessage();
                }
            }, 1000);
        }
    },

    // å¤„ç†å¿ƒè·³å“åº”å¹¶æ£€æŸ¥æ•°æ®å˜åŒ–
    handleHeartbeatResponse(message) {
        try {
            // å¦‚æœæ¶ˆæ¯åŒ…å«æ•°æ®çŠ¶æ€ä¿¡æ¯
            if (message.dataStatus) {
                const newDataStatus = message.dataStatus;
                let reloadTypes = [];
                
                // æ£€æŸ¥TODOæ•°æ®æ˜¯å¦æœ‰å˜åŒ–
                if (newDataStatus.lastTodoUpdate !== this.lastDataStatus.lastTodoUpdate) {
                    console.log('ğŸ“… æ£€æµ‹åˆ°TODOæ•°æ®å˜åŒ–ï¼Œå‡†å¤‡é‡æ–°åŠ è½½');
                    reloadTypes.push('todos');
                }
                
                // æ£€æŸ¥Notesæ•°æ®æ˜¯å¦æœ‰å˜åŒ–
                if (newDataStatus.lastNoteUpdate !== this.lastDataStatus.lastNoteUpdate) {
                    console.log('ğŸ“ æ£€æµ‹åˆ°Notesæ•°æ®å˜åŒ–ï¼Œå‡†å¤‡é‡æ–°åŠ è½½');
                    reloadTypes.push('notes');
                }
                
                // æ£€æŸ¥å…³è”çŠ¶æ€æ˜¯å¦æœ‰å˜åŒ–
                if (newDataStatus.hasLinkedData !== this.lastDataStatus.hasLinkedData) {
                    console.log('ğŸ”— æ£€æµ‹åˆ°LinkçŠ¶æ€å˜åŒ–ï¼Œå‡†å¤‡é‡æ–°åŠ è½½æ‰€æœ‰æ•°æ®');
                    reloadTypes = ['all']; // LinkçŠ¶æ€å˜åŒ–å¯èƒ½å½±å“æ‰€æœ‰æ•°æ®
                }
                
                // æ›´æ–°ç¼“å­˜çš„æ•°æ®çŠ¶æ€
                this.lastDataStatus = {
                    lastTodoUpdate: newDataStatus.lastTodoUpdate,
                    lastNoteUpdate: newDataStatus.lastNoteUpdate,
                    hasLinkedData: newDataStatus.hasLinkedData
                };
                
                // å¦‚æœæ£€æµ‹åˆ°æ•°æ®å˜åŒ–ï¼Œæ ¹æ®å˜åŒ–ç±»å‹ç²¾å‡†é‡æ–°åŠ è½½
                if (reloadTypes.length > 0) {
                    console.log('ğŸ”„ æ•°æ®å˜åŒ–æ£€æµ‹ï¼šè§¦å‘æ•°æ®é‡æ–°åŠ è½½', reloadTypes);
                    for (const dataType of reloadTypes) {
                        this.reloadApplicationData(dataType);
                    }
                }
            }
        } catch (error) {
            console.error('âŒ å¤„ç†å¿ƒè·³å“åº”å¤±è´¥:', error);
        }
    },
    
    // é‡æ–°åŠ è½½åº”ç”¨æ•°æ®
    reloadApplicationData(dataType = 'all', forceReload = false) {
        try {
            console.log('ğŸ”„ [RELOAD] é‡æ–°åŠ è½½åº”ç”¨æ•°æ®:', { dataType, forceReload });
            
            if (this._shouldReloadTodos(dataType)) {
                this._reloadTodoData(forceReload);
            }
            
            if (this._shouldReloadNotes(dataType)) {
                this._reloadNotesData(forceReload);
            }
            
            console.log('âœ… [RELOAD] åº”ç”¨æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
        } catch (error) {
            console.error('âŒ [RELOAD] é‡æ–°åŠ è½½åº”ç”¨æ•°æ®å¤±è´¥:', error);
        }
    },

    // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°åŠ è½½TODOæ•°æ®
    _shouldReloadTodos(dataType) {
        return dataType === 'all' || dataType === 'todos';
    },

    // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°åŠ è½½Notesæ•°æ®
    _shouldReloadNotes(dataType) {
        return dataType === 'all' || dataType === 'notes';
    },

    // é‡æ–°åŠ è½½TODOæ•°æ®
    _reloadTodoData(forceReload) {
        if (!window.TodoManager) {
            console.log('âš ï¸ [RELOAD] TodoManagerä¸å¯ç”¨');
            return;
        }

        console.log('ğŸ§¹ [RELOAD] æ¸…é™¤TODOç¼“å­˜');
        window.TodoManager.clearAllRelatedCache();
        
        const reloadContext = this._getTodoReloadContext(forceReload);
        console.log('ğŸ“… [RELOAD] é‡æ–°åŠ è½½TODOæ•°æ®:', reloadContext);
        
        if (reloadContext.currentUser) {
            this._executeTodoReload(reloadContext);
        } else {
            console.log('âš ï¸ [RELOAD] æ²¡æœ‰å½“å‰ç”¨æˆ·ï¼Œè·³è¿‡TODOæ•°æ®åŠ è½½');
        }
    },

    // è·å–TODOé‡æ–°åŠ è½½ä¸Šä¸‹æ–‡
    _getTodoReloadContext(forceReload) {
        const currentDate = window.DateManager ? window.DateManager.selectedDate : new Date();
        const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : 'unknown';
        
        return {
            currentDate: currentDate.toISOString().split('T')[0],
            currentUser,
            currentModule,
            forceReload
        };
    },

    // æ‰§è¡ŒTODOé‡æ–°åŠ è½½
    _executeTodoReload(reloadContext) {
        window.TodoManager.loadTodosForDate(
            new Date(reloadContext.currentDate), 
            reloadContext.currentUser, 
            false
        ).then(() => {
            console.log('âœ… [RELOAD] TODOæ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
            this._renderTodoIfNeeded(reloadContext);
        }).catch(error => {
            console.error('âŒ [RELOAD] TODOæ•°æ®é‡æ–°åŠ è½½å¤±è´¥:', error);
        });
    },

    // å¦‚éœ€è¦åˆ™æ¸²æŸ“TODOç•Œé¢
    _renderTodoIfNeeded(reloadContext) {
        if (reloadContext.currentModule === 'todo') {
            console.log('ğŸ¨ [RELOAD] é‡æ–°æ¸²æŸ“TODOç•Œé¢');
            window.TodoManager.renderTodoPanel(reloadContext.currentUser);
        }
    },

    // é‡æ–°åŠ è½½Notesæ•°æ®
    _reloadNotesData(forceReload) {
        if (!this._isNotesManagerAvailable()) {
            return;
        }

        console.log('ğŸ”„ [RELOAD] é‡æ–°åŠ è½½Notesæ•°æ®');
        
        const notesContext = this._getNotesReloadContext(forceReload);
        console.log('ğŸ“ [RELOAD] Notesé‡æ–°åŠ è½½ä¿¡æ¯:', notesContext);
        
        const shouldAutoRender = notesContext.currentModule === 'notes';
        window.NotesManager.loadNotesFromAPI(shouldAutoRender, notesContext.currentUser);
        
        if (!shouldAutoRender) {
            console.log('â¸ï¸ [RELOAD] å½“å‰ä¸åœ¨Notesé¡µé¢ï¼Œåªè¿›è¡Œåå°æ•°æ®åŒæ­¥');
        }
    },

    // æ£€æŸ¥NotesManageræ˜¯å¦å¯ç”¨
    _isNotesManagerAvailable() {
        if (window.NotesManager && typeof window.NotesManager.loadNotesFromAPI === 'function') {
            return true;
        } else if (window.NotesManager) {
            console.log('âš ï¸ [RELOAD] NotesManagerå­˜åœ¨ä½†loadNotesFromAPIæ–¹æ³•ä¸å¯ç”¨');
        }
        return false;
    },

    // è·å–Notesé‡æ–°åŠ è½½ä¸Šä¸‹æ–‡
    _getNotesReloadContext(forceReload) {
        const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : 'unknown';
        const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        
        return {
            currentModule,
            currentUser,
            forceReload
        };
    },
    
    // æ˜¾ç¤ºåŒæ­¥é€šçŸ¥
    showSyncNotification(message, type = 'info') {
        try {
            // å°è¯•ä½¿ç”¨TodoManagerçš„é€šçŸ¥æ–¹æ³•
            if (window.TodoManager && typeof window.TodoManager.showSyncStatusToast === 'function') {
                window.TodoManager.showSyncStatusToast(message, type);
                return;
            }
            
            // å¦‚æœæ²¡æœ‰ä¸“é—¨çš„é€šçŸ¥æ–¹æ³•ï¼Œä½¿ç”¨ç®€å•çš„æ§åˆ¶å°è¾“å‡º
            console.log(`ğŸ”” åŒæ­¥é€šçŸ¥: ${message}`);
            
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å…¶ä»–é€šçŸ¥æ–¹å¼ï¼Œæ¯”å¦‚æ˜¾ç¤ºä¸´æ—¶æ¶ˆæ¯ç­‰
        } catch (error) {
            console.error('âŒ æ˜¾ç¤ºåŒæ­¥é€šçŸ¥å¤±è´¥:', error);
        }
    },

    // è·å–è¿æ¥çŠ¶æ€
    getConnectionStatus() {
        return {
            isConnected: this.isConnected,
            reconnectAttempts: this.reconnectAttempts,
            wsState: this.ws ? this.ws.readyState : null,
            lastDataStatus: this.lastDataStatus
        };
    }
};

// é¡µé¢å¸è½½æ—¶å…³é—­è¿æ¥
window.addEventListener('beforeunload', () => {
    WebSocketClient.close();
});

// å¯¼å‡ºåˆ°å…¨å±€
window.WebSocketClient = WebSocketClient;


// å…¨å±€ç”¨æˆ·çŠ¶æ€ç®¡ç†å™¨
const GlobalUserState = {
    currentUserId: null,
    currentModule: 'todo', // 'todo' æˆ– 'notes'
    listeners: [],

    // åˆå§‹åŒ–
    init() {
        console.log('ğŸŒ åˆå§‹åŒ–å…¨å±€ç”¨æˆ·çŠ¶æ€ç®¡ç†å™¨');
        
        // åªæ¢å¤æ¨¡å—çŠ¶æ€ï¼Œç”¨æˆ·çŠ¶æ€ç”±TodoManagerçš„setDefaultUserå†³å®š
        const savedModule = localStorage.getItem('wenting_current_module');
        
        if (savedModule) {
            this.currentModule = savedModule;
        }
        
        // ä¸ä»localStorageæ¢å¤ç”¨æˆ·IDï¼Œè®©TodoManagerå†³å®šé»˜è®¤ç”¨æˆ·
        console.log('ğŸ“ åˆå§‹åŒ–çŠ¶æ€:', {
            currentUserId: this.currentUserId,
            currentModule: this.currentModule
        });
        console.log('ğŸ”„ ç”¨æˆ·IDå°†ç”±TodoManagerçš„setDefaultUseræ–¹æ³•è®¾ç½®');
    },

    // è®¾ç½®å½“å‰ç”¨æˆ·
    setCurrentUser(userId) {
        console.log('ğŸ‘¤ åˆ‡æ¢å½“å‰ç”¨æˆ·:', this.currentUserId, '->', userId);
        
        if (this.currentUserId !== userId) {
            this.currentUserId = userId;
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('wenting_current_user_id', userId.toString());
            
            // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
            this.notifyListeners('userChanged', { userId: userId });
        }
        
        // æ— è®ºæ˜¯å¦ç›¸åŒï¼Œéƒ½æ›´æ–°UIï¼ˆç¡®ä¿æ ·å¼æ­£ç¡®ï¼‰
        console.log('ğŸ¨ å¼ºåˆ¶æ›´æ–°ç”¨æˆ·é€‰æ‹©å™¨UI...');
        this.updateUserSelectorUI();
        
        // è§¦å‘ç”¨æˆ·é€‰æ‹©äº‹ä»¶ï¼Œä¼ é€’å®Œæ•´çš„ç”¨æˆ·å¯¹è±¡
        if (window.UserManager && window.UserManager.users) {
            const selectedUser = window.UserManager.users.find(user => user.id === userId);
            console.log('ğŸ” æŸ¥æ‰¾ç”¨æˆ·å¯¹è±¡ï¼Œç”¨æˆ·ID:', userId, 'æ‰¾åˆ°çš„ç”¨æˆ·:', selectedUser);
            
            if (selectedUser) {
                console.log('ğŸ“¢ å‡†å¤‡è§¦å‘userSelectedäº‹ä»¶');
                const userSelectedEvent = new CustomEvent('userSelected', {
                    detail: selectedUser
                });
                document.dispatchEvent(userSelectedEvent);
                console.log('âœ… userSelectedäº‹ä»¶å·²è§¦å‘ï¼Œç”¨æˆ·:', selectedUser.username);
            } else {
                console.warn('âš ï¸ æœªæ‰¾åˆ°ç”¨æˆ·IDä¸º', userId, 'çš„ç”¨æˆ·å¯¹è±¡');
            }
        } else {
            console.warn('âš ï¸ UserManageræˆ–ç”¨æˆ·åˆ—è¡¨æœªå°±ç»ª');
        }
    },

    // è®¾ç½®å½“å‰æ¨¡å—
    setCurrentModule(module) {
        console.log('ğŸ“‹ åˆ‡æ¢å½“å‰æ¨¡å—:', module);
        
        if (this.currentModule !== module) {
            this.currentModule = module;
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('wenting_current_module', module);
            
            // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
            this.notifyListeners('moduleChanged', { module: module });
        }
    },

    // è·å–å½“å‰ç”¨æˆ·ID
    getCurrentUser() {
        // å¦‚æœå½“å‰æ²¡æœ‰ç”¨æˆ·IDï¼Œå°è¯•ä»localStorageæ¢å¤
        if (this.currentUserId === null) {
            const savedUserId = localStorage.getItem('wenting_current_user_id');
            if (savedUserId && !isNaN(parseInt(savedUserId))) {
                this.currentUserId = parseInt(savedUserId);
                console.log('ğŸ’¾ ä»localStorageæ¢å¤ç”¨æˆ·ID:', this.currentUserId);
            }
        }
        return this.currentUserId;
    },

    // è·å–å½“å‰Appç”¨æˆ·ID
    getAppUserId() {
        return localStorage.getItem('wenting_current_app_user');
    },

    // è·å–å½“å‰æ¨¡å—
    getCurrentModule() {
        return this.currentModule;
    },

    // æ·»åŠ ç›‘å¬å™¨
    addListener(callback) {
        this.listeners.push(callback);
    },

    // ç§»é™¤ç›‘å¬å™¨
    removeListener(callback) {
        const index = this.listeners.indexOf(callback);
        if (index > -1) {
            this.listeners.splice(index, 1);
        }
    },

    // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
    notifyListeners(type, data) {
        console.log('ğŸ“¢ é€šçŸ¥ç›‘å¬å™¨:', type, data);
        this.listeners.forEach(callback => {
            try {
                callback(type, data);
            } catch (error) {
                console.error('âŒ ç›‘å¬å™¨å›è°ƒé”™è¯¯:', error);
            }
        });
    },

    // æ›´æ–°ç”¨æˆ·é€‰æ‹©å™¨UI
    updateUserSelectorUI() {
        console.log('ğŸ¨ æ›´æ–°ç”¨æˆ·é€‰æ‹©å™¨UIï¼Œå½“å‰ç”¨æˆ·:', this.currentUserId);
        
        // ç›´æ¥æ›´æ–°æ ·å¼ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªHTMLï¼ˆé¿å…ä¸¢å¤±çŠ¶æ€ï¼‰
        console.log('ğŸ“ ç›´æ¥æ›´æ–°ç”¨æˆ·æ ‡ç­¾æ ·å¼');
        const userTabs = document.querySelectorAll('.sidebar-tab');
        console.log('ğŸ” æ‰¾åˆ°', userTabs.length, 'ä¸ªç”¨æˆ·æ ‡ç­¾');
        
        userTabs.forEach(tab => {
            const tabUserId = parseInt(tab.dataset.tab);
            console.log('ğŸ·ï¸ å¤„ç†æ ‡ç­¾ï¼Œç”¨æˆ·ID:', tabUserId, 'å½“å‰ç”¨æˆ·:', this.currentUserId);
            
            if (tabUserId === this.currentUserId) {
                console.log('âœ… è®¾ç½®ä¸ºé€‰ä¸­çŠ¶æ€:', tabUserId);
                tab.classList.add('active');
                
                // æ›´æ–°CSSå˜é‡ç”¨äºé¢œè‰²æ¡
                if (window.UserManager) {
                    const user = UserManager.getUser(tabUserId);
                    if (user) {
                        tab.style.setProperty('--user-color', user.avatar_color || '#1d9bf0');
                        console.log('ğŸ¨ åº”ç”¨é€‰ä¸­æ ·å¼ï¼Œé¢œè‰²æ¡:', user.avatar_color);
                    }
                }
            } else {
                console.log('âŒ è®¾ç½®ä¸ºæœªé€‰ä¸­çŠ¶æ€:', tabUserId);
                tab.classList.remove('active');
                
                // ä¿æŒé¢œè‰²æ¡é¢œè‰²ä¸å˜
                if (window.UserManager) {
                    const user = UserManager.getUser(tabUserId);
                    if (user) {
                        tab.style.setProperty('--user-color', user.avatar_color || '#1d9bf0');
                    }
                }
            }
        });
    },

    // ç»‘å®šç”¨æˆ·é€‰æ‹©å™¨äº‹ä»¶
    bindUserSelectorEvents() {
        console.log('ğŸ”— å¼€å§‹ç»‘å®šç”¨æˆ·é€‰æ‹©å™¨äº‹ä»¶...');
        
        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œé¿å…é‡å¤ç»‘å®šé—®é¢˜
        const sidebar = document.querySelector('.left-sidebar');
        if (sidebar) {
            // ç§»é™¤å·²å­˜åœ¨çš„äº‹ä»¶ç›‘å¬å™¨
            sidebar.removeEventListener('click', this._sidebarClickHandler);
            
            // ç»‘å®šäº‹ä»¶å§”æ‰˜
            this._sidebarClickHandler = (e) => {
                const tab = e.target.closest('.sidebar-tab');
                if (tab) {
                    e.preventDefault();
                    e.stopPropagation();
                    const userId = parseInt(tab.dataset.tab);
                    if (userId && !isNaN(userId)) {
                        console.log('ğŸ–±ï¸ ç”¨æˆ·æŒ‰é’®ç‚¹å‡»ï¼Œåˆ‡æ¢åˆ°ç”¨æˆ·:', userId);
                        this.setCurrentUser(userId);
                    }
                }
            };
            
            sidebar.addEventListener('click', this._sidebarClickHandler);
            console.log('ğŸ”— ç”¨æˆ·é€‰æ‹©å™¨äº‹ä»¶å§”æ‰˜ç»‘å®šå®Œæˆ');
        }
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.GlobalUserState = GlobalUserState;


// æ—¥æœŸç®¡ç†æ¨¡å—
const DateManager = {
    selectedDate: new Date(),
    calendarDate: new Date(),
    // æ·»åŠ ä¼˜åŒ–æ ‡è®°
    isChangingDate: false,
    currentDateElements: null,
    
    // è¿›åº¦æ¡æ§åˆ¶
    showLoadingProgress() {
        const progressEl = document.getElementById('loadingProgress');
        if (progressEl) {
            progressEl.style.display = 'block';
        }
    },
    
    hideLoadingProgress() {
        const progressEl = document.getElementById('loadingProgress');
        if (progressEl) {
            progressEl.style.display = 'none';
        }
    },

    init() {
        this.updateCurrentDate();
        this.updateSelectedDate();
        this.bindEvents();
        // é¢„ç¼“å­˜DOMå…ƒç´ 
        this.currentDateElements = Utils.$$('.current-date');
    },

    // æ›´æ–°å½“å‰æ—¥æœŸæ˜¾ç¤º
    updateCurrentDate() {
        const now = new Date();
        const formatted = Utils.formatDate(now);
        
        // æ›´æ–°weatheræ çš„æ—¥æœŸæ˜¾ç¤º
        const currentDateEl = Utils.$('#currentDate');
        const weekdayEl = Utils.$('.weather-date-weekday');
        
        if (currentDateEl) {
            currentDateEl.textContent = formatted.full;
        }
        if (weekdayEl) {
            weekdayEl.textContent = formatted.weekday;
        }
    },

    // æ›´æ–°é€‰æ‹©çš„æ—¥æœŸæ˜¾ç¤ºï¼ˆä¼˜åŒ–ç‰ˆï¼‰
    updateSelectedDate() {
        const formatted = Utils.formatDate(this.selectedDate);
        
        // ä½¿ç”¨ç¼“å­˜çš„DOMå…ƒç´ ï¼Œé¿å…é‡å¤æŸ¥è¯¢
        if (!this.currentDateElements) {
            this.currentDateElements = Utils.$$('.current-date');
        }
        
        if (this.currentDateElements && this.currentDateElements.length > 0) {
            this.currentDateElements.forEach(el => {
                if (el && typeof el.textContent !== 'undefined') {
                    el.textContent = formatted.full;
                }
            });
        }
        
        // å¦‚æœä¸æ˜¯é€šè¿‡changeDateè§¦å‘çš„ï¼Œæ‰æ›´æ–°TODOæ˜¾ç¤º
        // é¿å…åŒé‡æ¸²æŸ“
        if (!this.isChangingDate) {
            this.filterTodosByDate();
        }
    },

    // æ ¹æ®æ—¥æœŸè¿‡æ»¤todoé¡¹ç›®
    filterTodosByDate() {
        // é€šçŸ¥TodoManageré‡æ–°æ¸²æŸ“å½“å‰ç”¨æˆ·çš„TODOé¢æ¿
        // ä½†æ˜¯è¦ç¡®ä¿ç”¨æˆ·æ•°æ®å·²ç»åŠ è½½å®Œæˆï¼Œé¿å…è¿‡æ—©æ¸²æŸ“
        if (typeof TodoManager !== 'undefined' && 
            TodoManager.currentUser && 
            typeof UserManager !== 'undefined' && 
            UserManager.users && 
            UserManager.users.length > 0) {
            
            console.log('ğŸ“… DateManagerè§¦å‘TODOé¢æ¿é‡æ–°æ¸²æŸ“ï¼Œç”¨æˆ·:', TodoManager.currentUser);
            TodoManager.renderTodoPanel(TodoManager.currentUser);
        } else {
            console.log('ğŸ“… DateManagerè·³è¿‡TODOé¢æ¿æ¸²æŸ“ï¼Œæ¡ä»¶ä¸æ»¡è¶³:');
            console.log('  - TodoManagerå­˜åœ¨:', typeof TodoManager !== 'undefined');
            console.log('  - currentUserå­˜åœ¨:', !!TodoManager?.currentUser);
            console.log('  - UserManagerå­˜åœ¨:', typeof UserManager !== 'undefined');
            console.log('  - ç”¨æˆ·æ•°æ®å·²åŠ è½½:', UserManager?.users?.length > 0);
        }
    },

    // æ—¥æœŸåˆ‡æ¢ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
    changeDate(direction) {
        // è®¾ç½®æ ‡è®°ï¼Œé¿å…åŒé‡æ¸²æŸ“
        this.isChangingDate = true;
        
        this.selectedDate.setDate(this.selectedDate.getDate() + direction);
        
        // ç«‹å³æ›´æ–°æ—¥æœŸæ˜¾ç¤ºï¼ˆä¸è§¦å‘TODOæ¸²æŸ“ï¼‰
        this.updateSelectedDate();
        
        // æ£€æŸ¥TodoManagerçš„ç¼“å­˜
        const dateStr = this.selectedDate.toISOString().split('T')[0];
        const currentUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
        const cacheKey = `${currentUser}_${dateStr}`;
        
        let hasCache = false;
        if (window.TodoManager && currentUser && window.TodoManager.todoCache.has(cacheKey)) {
            // ä½¿ç”¨TodoManagerçš„ç¼“å­˜æ•°æ®å¿«é€Ÿæ¸²æŸ“
            const cachedData = window.TodoManager.todoCache.get(cacheKey);
            window.TodoManager.todos[currentUser] = [...cachedData]; // åˆ›å»ºå‰¯æœ¬
            window.TodoManager.renderTodoPanel(currentUser);
            console.log('ğŸ“… DateManagerä½¿ç”¨ç¼“å­˜å¿«é€Ÿæ¸²æŸ“ï¼Œç”¨æˆ·:', currentUser);
            hasCache = true;
        }
        
        // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œæ˜¾ç¤ºåŠ è½½è¿›åº¦æ¡
        if (!hasCache) {
            this.showLoadingProgress();
        }
        
        // å¼‚æ­¥åŠ è½½æœ€æ–°æ•°æ®ï¼ˆä¸é˜»å¡UIï¼‰
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            // ä¼ é€’æ­£ç¡®çš„ç”¨æˆ·IDï¼Œç¡®ä¿åŠ è½½æ­£ç¡®ç”¨æˆ·çš„æ•°æ®
            const targetUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
            // å¦‚æœå·²ç”¨ç¼“å­˜æ¸²æŸ“ï¼Œåˆ™é™é»˜åˆ·æ–°ï¼›å¦åˆ™éœ€è¦æ¸²æŸ“
            const silent = hasCache;
            window.TodoManager.loadTodosForDate(this.selectedDate, targetUser, silent).then(() => {
                // æ•°æ®åŠ è½½å®Œæˆåéšè—è¿›åº¦æ¡
                this.hideLoadingProgress();
            }).catch(() => {
                // å³ä½¿å‡ºé”™ä¹Ÿè¦éšè—è¿›åº¦æ¡
                this.hideLoadingProgress();
            });
        }
        
        // é‡ç½®æ ‡è®°
        this.isChangingDate = false;
    },

    // è¿”å›ä»Šå¤©
    goToToday() {
        console.log('goToTodayè¢«è°ƒç”¨');
        this.selectedDate = new Date();
        console.log('é‡ç½®ä¸ºä»Šå¤©:', this.selectedDate);
        this.updateSelectedDate();
        
        // æ£€æŸ¥ç¼“å­˜å†³å®šæ˜¯å¦æ˜¾ç¤ºè¿›åº¦æ¡
        const dateStr = this.selectedDate.toISOString().split('T')[0];
        const currentUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
        const cacheKey = `${currentUser}_${dateStr}`;
        
        let hasCache = window.TodoManager && currentUser && window.TodoManager.todoCache.has(cacheKey);
        
        // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œæ˜¾ç¤ºåŠ è½½è¿›åº¦æ¡
        if (!hasCache) {
            this.showLoadingProgress();
        }
        
        // é€šçŸ¥TodoManageré‡æ–°åŠ è½½æ•°æ®
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            window.TodoManager.loadTodosForDate(this.selectedDate).then(() => {
                this.hideLoadingProgress();
            }).catch(() => {
                this.hideLoadingProgress();
            });
        }
    },

    // åˆ‡æ¢æ—¥å†æ˜¾ç¤º
    toggleDatePicker() {
        console.log('toggleDatePicker è¢«è°ƒç”¨');
        const picker = Utils.$('#datePicker');
        console.log('æ‰¾åˆ°æ—¥å†å…ƒç´ :', picker);
        const isVisible = picker && picker.classList.contains('show');
        console.log('æ—¥å†å½“å‰å¯è§çŠ¶æ€:', isVisible);
        
        if (isVisible) {
            console.log('éšè—æ—¥å†');
            picker.classList.remove('show');
        } else {
            console.log('æ˜¾ç¤ºæ—¥å†');
            this.calendarDate = new Date(this.selectedDate);
            this.updateCalendar();
            if (picker) {
                picker.classList.add('show');
            }
        }
    },

    // æ›´æ”¹æ—¥å†æœˆä»½
    changeMonth(direction) {
        this.calendarDate.setMonth(this.calendarDate.getMonth() + direction);
        this.updateCalendar();
    },

    // æ›´æ–°æ—¥å†æ˜¾ç¤º
    updateCalendar() {
        const months = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
        const year = this.calendarDate.getFullYear();
        const month = this.calendarDate.getMonth();
        
        // æ›´æ–°æœˆä»½æ ‡é¢˜
        const monthEl = Utils.$('#calendarMonth');
        if (monthEl) {
            monthEl.textContent = `${year}å¹´${months[month]}`;
        }
        
        // ç”Ÿæˆæ—¥å†æ—¥æœŸ
        const firstDay = new Date(year, month, 1);
        const startDate = new Date(firstDay);
        startDate.setDate(startDate.getDate() - firstDay.getDay());
        
        const calendarDays = Utils.$('#calendarDays');
        if (calendarDays) {
            calendarDays.innerHTML = '';
            
            for (let i = 0; i < 42; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                const dayButton = document.createElement('button');
                dayButton.className = 'calendar-day';
                dayButton.textContent = date.getDate();
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰æœˆä»½
                if (date.getMonth() !== month) {
                    dayButton.classList.add('other-month');
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯é€‰ä¸­çš„æ—¥æœŸ
                if (date.toDateString() === this.selectedDate.toDateString()) {
                    dayButton.classList.add('selected');
                }
                
                dayButton.onclick = () => this.selectDate(date);
                calendarDays.appendChild(dayButton);
            }
        }
    },

    // é€‰æ‹©æ—¥æœŸ
    selectDate(date) {
        this.selectedDate = new Date(date);
        this.updateSelectedDate();
        this.toggleDatePicker();
        
        // é€šçŸ¥TodoManageré‡æ–°åŠ è½½æ•°æ®
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            window.TodoManager.loadTodosForDate(this.selectedDate);
        }
    },

    // ç»‘å®šäº‹ä»¶
    bindEvents() {
        // ç‚¹å‡»å¤–éƒ¨å…³é—­æ—¥å†
        document.addEventListener('click', (event) => {
            const picker = Utils.$('#datePicker');
            const pickerBtn = event.target.closest('.date-picker-btn');
            
            if (picker && !picker.contains(event.target) && !pickerBtn) {
                picker.classList.remove('show');
            }
        });

        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œé¿å…é‡å¤ç»‘å®š
        this.bindEventsWithDelegation();
    },

    // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šäº‹ä»¶
    bindEventsWithDelegation() {
        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šä»Šå¤©æŒ‰é’®
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('today-btn')) {
                e.preventDefault();
                e.stopPropagation();
                console.log('ä»Šå¤©æŒ‰é’®è¢«ç‚¹å‡»');
                this.goToToday();
            }
        });

        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šæ—¥æœŸå¯¼èˆªæŒ‰é’®
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('date-nav-btn')) {
                e.preventDefault();
                e.stopPropagation();
                console.log('æ—¥æœŸå¯¼èˆªæŒ‰é’®è¢«ç‚¹å‡»:', e.target.textContent);
                const direction = e.target.textContent === 'â€¹' ? -1 : 1;
                this.changeDate(direction);
            }
        });

        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šæ—¥å†åˆ‡æ¢æŒ‰é’®
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('date-picker-btn')) {
                console.log('æ—¥å†æŒ‰é’®è¢«ç‚¹å‡»ï¼');
                e.preventDefault();
                e.stopPropagation();
                this.toggleDatePicker();
            }
        });

        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šæœˆä»½å¯¼èˆªæŒ‰é’®
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('calendar-nav')) {
                e.preventDefault();
                e.stopPropagation();
                const direction = e.target.textContent === 'â€¹' ? -1 : 1;
                this.changeMonth(direction);
            }
        });
    },

    // ç»‘å®šæ—¥æœŸå¯¼èˆªäº‹ä»¶
    bindDateNavigation() {
        // ç»‘å®šæ—¥æœŸå¯¼èˆªæŒ‰é’®
        const dateNavBtns = Utils.$$('.date-nav-btn');
        console.log('æ‰¾åˆ°æ—¥æœŸå¯¼èˆªæŒ‰é’®:', dateNavBtns.length);
        dateNavBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                console.log('æ—¥æœŸå¯¼èˆªæŒ‰é’®è¢«ç‚¹å‡»:', e.target.textContent);
                const direction = e.target.textContent === 'â€¹' ? -1 : 1;
                this.changeDate(direction);
            });
        });

        // ç»‘å®šæ—¥å†åˆ‡æ¢æŒ‰é’®
        const pickerBtns = Utils.$$('.date-picker-btn');
        console.log('æ‰¾åˆ°æ—¥å†åˆ‡æ¢æŒ‰é’®:', pickerBtns.length);
        pickerBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                this.toggleDatePicker();
            });
        });

        // ç»‘å®šæœˆä»½å¯¼èˆª
        const calendarNavBtns = Utils.$$('.calendar-nav');
        console.log('æ‰¾åˆ°æœˆä»½å¯¼èˆªæŒ‰é’®:', calendarNavBtns.length);
        calendarNavBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const direction = e.target.textContent === 'â€¹' ? -1 : 1;
                this.changeMonth(direction);
            });
        });
    }
};


// å°†DateManageræš´éœ²åˆ°å…¨å±€
window.DateManager = DateManager;


// TODOç®¡ç†æ¨¡å— - å®Œå…¨é‡å†™ç‰ˆæœ¬
const TodoManager = {
    currentUser: 1,
    todos: {},
    selectedDate: new Date(),
    isOnline: false,
    // æ·»åŠ ç¼“å­˜æœºåˆ¶
    todoCache: new Map(),
    lastLoadedDate: null,
    // é‡è¯•é…ç½®
    RETRY_DELAY_BASE: 1000, // åŸºç¡€é‡è¯•å»¶è¿Ÿ1ç§’
    RETRY_DELAY_MULTIPLIER: 2000, // æ•´ä½“é‡è¯•å»¶è¿Ÿ2ç§’

    // åˆå§‹åŒ–
    async init() {
        console.log('ğŸ”„ åˆå§‹åŒ–TODOç®¡ç†å™¨...');
        
        // æ£€æŸ¥åç«¯è¿æ¥ - å¿…é¡»è”ç½‘æ‰èƒ½ä½¿ç”¨
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            this.showOfflineError();
            return;
        }
        
        // ç­‰å¾…ç”¨æˆ·ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
        await this.waitForUserManager();
        
        // åŠ è½½TODOæ•°æ®
        await this.loadTodosFromAPI();
        
        // è®¾ç½®é»˜è®¤ç”¨æˆ·
        this.setDefaultUser();
        
        // ç›‘å¬å…¨å±€ç”¨æˆ·çŠ¶æ€å˜åŒ–ï¼Œä½†ä¸è®¾ç½®æ¨¡å—
        if (window.GlobalUserState) {
            GlobalUserState.addListener(this.handleGlobalStateChange.bind(this));
        }
        
        // ä¸åœ¨è¿™é‡Œæ¸²æŸ“ç•Œé¢ï¼Œç­‰å¾…åº”ç”¨ç•Œé¢æ˜¾ç¤ºåå†æ¸²æŸ“
        // æ¸²æŸ“å°†åœ¨app.jsçš„setTimeoutä¸­è¿›è¡Œ
        
        this.bindEvents();
        
        console.log('âœ… TODOç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
    },

    // ç­‰å¾…ç”¨æˆ·ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
    async waitForUserManager() {
        // è®¾ç½®æœ€å¤§ç­‰å¾…æ—¶é—´ä¸º5ç§’ï¼Œé¿å…æ–°ç”¨æˆ·æ— é™ç­‰å¾…
        const MAX_WAIT_TIME = 5000; // 5ç§’
        const startTime = Date.now();
        
        if (UserManager.users.length === 0) {
            console.log('â³ ç­‰å¾…ç”¨æˆ·æ•°æ®åŠ è½½ï¼Œæ–°ç”¨æˆ·æœ€å¤šç­‰å¾…5ç§’...');
            await new Promise(resolve => {
                const checkUsers = () => {
                    const elapsedTime = Date.now() - startTime;
                    
                    if (UserManager.users.length > 0) {
                        console.log('âœ… ç”¨æˆ·æ•°æ®å·²åŠ è½½');
                        resolve();
                    } else if (elapsedTime >= MAX_WAIT_TIME) {
                        console.log('â° ç­‰å¾…è¶…æ—¶ï¼Œå¯èƒ½æ˜¯æ–°ç”¨æˆ·æ²¡æœ‰è¢«ç®¡ç†ç”¨æˆ·ï¼Œç»§ç»­åˆå§‹åŒ–...');
                        resolve();
                    } else {
                        setTimeout(checkUsers, 100);
                    }
                };
                checkUsers();
            });
        }
    },

    // ä»APIåŠ è½½TODOæ•°æ®
    async loadTodosFromAPI() {
        try {
            console.log('ğŸ“¥ ä»æœåŠ¡å™¨åŠ è½½TODOæ•°æ®...');
            
            // å°è¯•ä½¿ç”¨WebSocketï¼Œå¤±è´¥åˆ™é™çº§åˆ°HTTP
            let useWebSocket = true;
            try {
                // ç¡®ä¿WebSocketå·²è¿æ¥
                if (!WebSocketClient.isConnected) {
                    await WebSocketClient.init();
                }
            } catch (error) {
                console.warn('âš ï¸ WebSocketè¿æ¥å¤±è´¥ï¼Œä½¿ç”¨HTTPæ¨¡å¼:', error.message);
                useWebSocket = false;
            }

            // ä¸ºæ¯ä¸ªç”¨æˆ·åŠ è½½TODOæ•°æ®
            for (const user of UserManager.users) {
                try {
                    let response;
                    if (useWebSocket) {
                        response = await WebSocketClient.todos.getTodayTodos(user.id);
                        this.todos[user.id] = response.data.todos.map(todo => this.convertApiTodoToLocal(todo));
                    } else {
                        response = await ApiClient.todos.getTodayTodos(user.id);
                        if (response.success) {
                            this.todos[user.id] = response.data.map(todo => this.convertApiTodoToLocal(todo));
                        } else {
                            throw new Error(response.message);
                        }
                    }
                } catch (error) {
                    console.warn(`åŠ è½½ç”¨æˆ·${user.id}çš„TODOå¤±è´¥:`, error.message);
                    this.todos[user.id] = [];
                }
            }
            
            console.log('âœ… ä»æœåŠ¡å™¨åŠ è½½TODOæ•°æ®æˆåŠŸ');
        } catch (error) {
            console.error('ä»æœåŠ¡å™¨åŠ è½½TODOæ•°æ®å¤±è´¥:', error);
            throw error;
        }
    },

    // è®¾ç½®é»˜è®¤ç”¨æˆ·
    setDefaultUser() {
        console.log('ğŸ”„ å¼€å§‹è®¾ç½®é»˜è®¤ç”¨æˆ·...');
        console.log('ğŸ” ç”¨æˆ·æ•°æ®è°ƒè¯•:');
        console.log('  - UserManager.users.length:', UserManager.users.length);
        console.log('  - UserManager.users:', UserManager.users);
        
        if (UserManager.users.length > 0) {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„ç”¨æˆ·é€‰æ‹©
            let savedUserId = null;
            if (window.GlobalUserState) {
                savedUserId = GlobalUserState.getCurrentUser();
                console.log('ğŸ’¾ ä»å…¨å±€çŠ¶æ€è·å–ä¿å­˜çš„ç”¨æˆ·ID:', savedUserId);
            }
            
            // æŒ‰IDæ’åºï¼Œé€‰æ‹©IDæœ€å°çš„ç”¨æˆ·ï¼ˆæœ€æ—©æ·»åŠ çš„ç”¨æˆ·ï¼‰
            const sortedUsers = [...UserManager.users].sort((a, b) => a.id - b.id);
            
            // éªŒè¯ä¿å­˜çš„ç”¨æˆ·IDæ˜¯å¦ä»ç„¶å­˜åœ¨
            let defaultUser;
            if (savedUserId && sortedUsers.find(u => u.id == savedUserId)) {
                defaultUser = parseInt(savedUserId);
                console.log('ğŸ¯ ä½¿ç”¨ä¿å­˜çš„ç”¨æˆ·ID:', defaultUser);
            } else {
                defaultUser = sortedUsers[0].id;
                console.log('ğŸ¯ ä½¿ç”¨é»˜è®¤ç¬¬ä¸€ä¸ªç”¨æˆ·:', defaultUser, '(ç”¨æˆ·å:', sortedUsers[0].username, ')');
            }
            
            console.log('ğŸ“‹ æ‰€æœ‰ç”¨æˆ·æŒ‰IDæ’åº:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));
            this.currentUser = defaultUser;
            
            // ç›´æ¥åŒæ­¥å…¨å±€çŠ¶æ€ï¼Œä¸è§¦å‘äº‹ä»¶ï¼ˆäº‹ä»¶å°†åœ¨app.jsä¸­è§¦å‘ï¼‰
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = defaultUser;
                localStorage.setItem('wenting_current_user_id', defaultUser.toString());
                console.log('ğŸ”„ ç›´æ¥åŒæ­¥å…¨å±€ç”¨æˆ·çŠ¶æ€ï¼ˆä¸è§¦å‘äº‹ä»¶ï¼‰');
                console.log('ğŸ” è®¾ç½®åçš„çŠ¶æ€:');
                console.log('  - TodoManager.currentUser:', this.currentUser);
                console.log('  - GlobalUserState.currentUserId:', GlobalUserState.currentUserId);
            }
        } else {
            console.log('ğŸ“ æ²¡æœ‰ç”¨æˆ·ï¼Œæ–°æ³¨å†Œç”¨æˆ·æƒ…å†µï¼Œè®¾ç½®ä¸ºç©ºçŠ¶æ€ä½†ç»§ç»­åˆå§‹åŒ–');
            this.currentUser = null;
            
            // å³ä½¿æ²¡æœ‰ç”¨æˆ·ï¼Œä¹Ÿè¦è®¾ç½®å…¨å±€çŠ¶æ€ï¼Œç¡®ä¿åº”ç”¨å¯ä»¥ç»§ç»­è¿è¡Œ
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = null;
                console.log('ğŸ”„ è®¾ç½®å…¨å±€çŠ¶æ€ä¸ºç©ºç”¨æˆ·çŠ¶æ€');
            }
        }
    },

    // å¤„ç†å…¨å±€çŠ¶æ€å˜åŒ–
    handleGlobalStateChange(type, data) {
        console.log('ğŸ“¢ TODOç®¡ç†å™¨æ”¶åˆ°å…¨å±€çŠ¶æ€å˜åŒ–:', type, data);
        
        if (type === 'userChanged') {
            const newUserId = data.userId;
            console.log('ğŸ”„ å¤„ç†ç”¨æˆ·åˆ‡æ¢äº‹ä»¶:');
            console.log('  - å½“å‰ç”¨æˆ·:', this.currentUser);
            console.log('  - æ–°ç”¨æˆ·:', newUserId);
            
            // å…ˆæ›´æ–°currentUserï¼Œç¡®ä¿åç»­æ“ä½œä½¿ç”¨æ­£ç¡®çš„ç”¨æˆ·ID
            const oldUser = this.currentUser;
            this.currentUser = newUserId;
            
            if (oldUser !== newUserId) {
                console.log(`ğŸ”„ ç”¨æˆ·ä» ${oldUser} åˆ‡æ¢åˆ° ${newUserId}`);
                // åªæœ‰å½“å‰æ¨¡å—æ˜¯todoæ—¶æ‰æ¸²æŸ“
                if (GlobalUserState.getCurrentModule() === 'todo') {
                    console.log('âœ… å½“å‰æ˜¯TODOæ¨¡å—ï¼Œæ¸²æŸ“TODOå†…å®¹');
                    
                    // æ£€æŸ¥ç¼“å­˜å†³å®šæ˜¯å¦æ˜¾ç¤ºè¿›åº¦æ¡
                    const dateStr = (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
                    const cacheKey = `${newUserId}_${dateStr}`;
                    let hasCache = this.todoCache.has(cacheKey);
                    
                    // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œæ˜¾ç¤ºåŠ è½½è¿›åº¦æ¡
                    if (!hasCache && window.DateManager) {
                        window.DateManager.showLoadingProgress();
                    }
                    
                    this.loadTodosForDate(DateManager.selectedDate || new Date(), newUserId).then(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }).catch(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    });
                } else {
                    console.log('â¸ï¸ å½“å‰ä¸æ˜¯TODOæ¨¡å—ï¼Œè·³è¿‡æ¸²æŸ“');
                }
            } else {
                console.log('ğŸ”„ ç”¨æˆ·IDç›¸åŒï¼Œä½†ä»éœ€é‡æ–°æ¸²æŸ“TODOé¢æ¿ï¼ˆå¯èƒ½æ˜¯åˆå§‹åŒ–è°ƒç”¨ï¼‰');
                // å³ä½¿ç”¨æˆ·IDç›¸åŒï¼Œä¹Ÿè¦é‡æ–°æ¸²æŸ“ï¼ˆæ¯”å¦‚åˆå§‹åŒ–æ—¶ï¼‰
                if (GlobalUserState.getCurrentModule() === 'todo') {
                    console.log('âœ… å½“å‰æ˜¯TODOæ¨¡å—ï¼Œæ¸²æŸ“TODOå†…å®¹');
                    
                    // æ£€æŸ¥ç¼“å­˜å†³å®šæ˜¯å¦æ˜¾ç¤ºè¿›åº¦æ¡  
                    const dateStr = (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
                    const cacheKey = `${newUserId}_${dateStr}`;
                    let hasCache = this.todoCache.has(cacheKey);
                    
                    // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œæ˜¾ç¤ºåŠ è½½è¿›åº¦æ¡
                    if (!hasCache && window.DateManager) {
                        window.DateManager.showLoadingProgress();
                    }
                    
                    this.loadTodosForDate(DateManager.selectedDate || new Date(), newUserId).then(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }).catch(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    });
                } else {
                    console.log('â¸ï¸ å½“å‰ä¸æ˜¯TODOæ¨¡å—ï¼Œè·³è¿‡æ¸²æŸ“');
                }
            }
        }
    },

    // æ˜¾ç¤ºç¦»çº¿é”™è¯¯
    showOfflineError() {
        const contentArea = document.getElementById('contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="offline-error">
                    <div class="error-icon">ğŸŒ</div>
                    <h2>éœ€è¦ç½‘ç»œè¿æ¥</h2>
                    <p>æ­¤åº”ç”¨éœ€è¦è¿æ¥åˆ°æœåŠ¡å™¨æ‰èƒ½æ­£å¸¸ä½¿ç”¨ã€‚</p>
                    <p>è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥å’ŒæœåŠ¡å™¨çŠ¶æ€ã€‚</p>
                    <button onclick="location.reload()" class="retry-btn">é‡è¯•</button>
                </div>
            `;
        }
    },

    // æ˜¾ç¤ºç©ºç”¨æˆ·çŠ¶æ€
    showEmptyUserState() {
        const contentArea = document.getElementById('contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="empty-user-state">
                    <div class="empty-icon">ğŸ‘¥</div>
                    <h2>æ¬¢è¿ä½¿ç”¨é›¯å©·</h2>
                    <p>è¿˜æ²¡æœ‰ç”¨æˆ·ï¼Œè¯·å…ˆæ·»åŠ ä¸€ä¸ªç”¨æˆ·å¼€å§‹ä½¿ç”¨ã€‚</p>
                    <button onclick="UserManager.addUser()" class="add-first-user-btn">æ·»åŠ ç¬¬ä¸€ä¸ªç”¨æˆ·</button>
                </div>
            `;
        }
    },

    // å°†API TODOæ ¼å¼è½¬æ¢ä¸ºæœ¬åœ°æ ¼å¼
    convertApiTodoToLocal(apiTodo) {
        console.log('ğŸ“¥ ä»æœåŠ¡å™¨æ¥æ”¶çš„TODOæ•°æ®:', apiTodo);
        console.log('ğŸ“‹ é‡å¤å‘¨æœŸæ•°æ®è°ƒè¯•:');
        console.log('  cycle_type:', apiTodo.cycle_type);
        console.log('  cycle_duration:', apiTodo.cycle_duration);
        console.log('  cycle_unit:', apiTodo.cycle_unit);
        
        const cycleText = this.getCycleText(apiTodo.cycle_type, apiTodo.cycle_duration, apiTodo.cycle_unit);
        console.log('  è®¡ç®—å‡ºçš„cycleæ–‡æœ¬:', cycleText);
        
        return {
            id: apiTodo.id,
            text: apiTodo.title,
            note: apiTodo.description || '',
            time: apiTodo.reminder_time === 'all_day' ? 'å½“å¤©' : apiTodo.reminder_time,
            period: this.getRepeatTypeText(apiTodo.repeat_type, apiTodo.repeat_interval),
            periodType: apiTodo.repeat_type,
            customInterval: apiTodo.repeat_interval > 1 ? apiTodo.repeat_interval : null,
            cycle: cycleText,
            cycleType: apiTodo.cycle_type || 'long_term',
            cycleDuration: apiTodo.cycle_duration || null,
            cycleUnit: apiTodo.cycle_unit || 'days',
            completed: apiTodo.is_completed_today || false,
            priority: apiTodo.priority || 'medium',
            createdDate: apiTodo.start_date || new Date().toISOString().split('T')[0]
        };
    },

    // å°†æœ¬åœ°TODOæ ¼å¼è½¬æ¢ä¸ºAPIæ ¼å¼
    convertLocalTodoToApi(localTodo, userId) {
        return {
            user_id: userId,
            title: localTodo.text,
            description: localTodo.note || '',
            reminder_time: localTodo.time === 'å½“å¤©' ? 'all_day' : localTodo.time,
            priority: localTodo.priority || 'medium',
            repeat_type: localTodo.periodType || 'none',
            repeat_interval: localTodo.customInterval || 1,
            cycle_type: localTodo.cycleType || 'long_term',
            cycle_duration: localTodo.cycleDuration || null,
            cycle_unit: localTodo.cycleUnit || 'days',
            start_date: new Date().toISOString().split('T')[0]
        };
    },

    // è·å–é‡å¤ç±»å‹çš„æ˜¾ç¤ºæ–‡æœ¬
    getRepeatTypeText(repeatType, repeatInterval = 1) {
        switch (repeatType) {
            case 'none':
                return 'ä¸€æ¬¡æ€§';
            case 'daily':
                return 'æ¯å¤©';
            case 'every_other_day':
                return 'éš”å¤©';
            case 'weekly':
                return 'æ¯å‘¨';
            case 'monthly':
                return 'æ¯æœˆ';
            case 'yearly':
                return 'æ¯å¹´';
            case 'custom':
                return `æ¯${repeatInterval}å¤©`;
            default:
                return 'ä¸€æ¬¡æ€§';
        }
    },

    // è·å–é‡å¤å‘¨æœŸçš„æ˜¾ç¤ºæ–‡æœ¬
    getCycleText(cycleType, cycleDuration, cycleUnit) {
        if (cycleType === 'long_term') {
            return 'é•¿æœŸ';
        } else if (cycleType === 'custom' && cycleDuration) {
            const unitText = {
                'days': 'å¤©',
                'weeks': 'å‘¨',
                'months': 'æœˆ'
            };
            return `${cycleDuration}${unitText[cycleUnit] || 'å¤©'}`;
        }
        return 'é•¿æœŸ';
    },


    // æ¸²æŸ“TODOé¢æ¿
    renderTodoPanel(userId) {
        console.log('ğŸ¨ å¼€å§‹æ¸²æŸ“TODOé¢æ¿ï¼Œç”¨æˆ·ID:', userId);
        console.log('ğŸ” æ¸²æŸ“è°ƒè¯•ä¿¡æ¯:');
        
        const contentArea = document.getElementById('contentArea');
        console.log('  - contentAreaå­˜åœ¨:', !!contentArea);
        if (!contentArea) {
            console.error('âŒ æ‰¾ä¸åˆ°contentAreaå…ƒç´ ');
            return;
        }

        // è·å–å½“å‰é€‰ä¸­çš„æ—¥æœŸ
        const currentDate = DateManager.selectedDate || new Date();
        console.log('  - å½“å‰æ—¥æœŸ:', currentDate);
        
        // è·å–ç”¨æˆ·TODOå¹¶æŒ‰æ—¶é—´æ’åº
        const userTodos = this.todos[userId] || [];
        const user = UserManager.getUser(userId);
        console.log('  - ç”¨æˆ·ä¿¡æ¯:', user);
        console.log('  - ç”¨æˆ·TODOæ•°é‡:', userTodos.length);
        console.log('  - ç”¨æˆ·TODOè¯¦æƒ…:', userTodos);
        
        // è·å–å½“å‰æ—¥æœŸçš„æ ¼å¼åŒ–æ˜¾ç¤º
        const currentDateFormatted = this.formatDate(currentDate);
        console.log('  - æ ¼å¼åŒ–æ—¥æœŸ:', currentDateFormatted);
        
        const panelHtml = `
            <div class="content-panel" id="${userId}-todo-panel">
                <div class="date-controls">
                    <div class="date-center">
                        <div class="today-btn">ä»Šå¤©</div>
                        <div class="date-nav-btn">â€¹</div>
                        <div class="current-date">${currentDateFormatted}</div>
                        <div class="date-nav-btn">â€º</div>
                    </div>
                    <div class="date-picker-btn">ğŸ“…</div>
                    <div class="date-picker" id="datePicker">
                        <div class="calendar-header">
                            <button class="calendar-nav">â€¹</button>
                            <span id="calendarMonth">2025å¹´8æœˆ</span>
                            <button class="calendar-nav">â€º</button>
                        </div>
                        <div class="calendar-grid">
                            <div class="calendar-weekday">æ—¥</div>
                            <div class="calendar-weekday">ä¸€</div>
                            <div class="calendar-weekday">äºŒ</div>
                            <div class="calendar-weekday">ä¸‰</div>
                            <div class="calendar-weekday">å››</div>
                            <div class="calendar-weekday">äº”</div>
                            <div class="calendar-weekday">å…­</div>
                        </div>
                        <div class="calendar-grid" id="calendarDays"></div>
                    </div>
                </div>
                <div class="todo-list-container">
                    ${userTodos.map(todo => this.renderTodoItem(todo, userId)).join('')}
                    <button class="new-todo-btn" onclick="TodoManager.showAddTodoForm(${userId})">+ æ·»åŠ æ–°TODO</button>
                </div>
            </div>
        `;

        console.log('ğŸ“ è®¾ç½®contentAreaçš„innerHTML...');
        console.log('ğŸ“ panelHtmlé•¿åº¦:', panelHtml.length);
        contentArea.innerHTML = panelHtml;
        console.log('âœ… TODOé¢æ¿HTMLå·²è®¾ç½®åˆ°contentArea');
    },

    // æ¸²æŸ“å•ä¸ªTODOé¡¹
    renderTodoItem(todo, userId) {
        const checkedClass = todo.completed ? 'checked' : '';
        const completedClass = todo.completed ? 'completed' : '';
        const timeSpecificClass = todo.time !== 'å½“å¤©' ? 'specific' : '';
        
        // æ ¹æ®ä¼˜å…ˆçº§è®¾ç½®è¾¹æ¡†é¢œè‰²
        let priorityClass = '';
        switch (todo.priority) {
            case 'high':
                priorityClass = 'priority-high';
                break;
            case 'medium':
                priorityClass = 'priority-medium';
                break;
            case 'low':
            default:
                priorityClass = 'priority-low';
                break;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å…³è”ç”¨æˆ·ï¼ˆåŒæ­¥çŠ¶æ€ï¼‰
        const syncStatus = this.getSyncStatus(userId);
        const syncIndicator = syncStatus.isLinked ? `
            <div class="sync-indicator ${syncStatus.status}" title="${syncStatus.tooltip}">
                <span class="sync-icon">${syncStatus.icon}</span>
            </div>
        ` : '';
        
        return `
            <div class="todo-item todo-card ${priorityClass} ${completedClass}">
                <div class="todo-checkbox ${checkedClass}" onclick="TodoManager.toggleTodo(this)" 
                     data-member="${userId}" data-id="${todo.id}"></div>
                <div class="todo-content" onclick="TodoManager.showEditTodoForm(${todo.id}, ${userId})">
                    <div class="todo-text ${completedClass}">
                        ${todo.text}
                        ${todo.note ? `<div class="todo-note">${todo.note}</div>` : ''}
                    </div>
                    <div class="todo-right">
                        <div class="todo-time ${timeSpecificClass}">${todo.time}</div>
                        <div class="todo-period">${todo.period}</div>
                        <div class="todo-cycle">${todo.cycle}</div>
                        ${syncIndicator}
                    </div>
                </div>
            </div>
        `;
    },

    // è·å–åŒæ­¥çŠ¶æ€
    getSyncStatus(userId) {
        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰å…³è”å…³ç³»
        const user = UserManager.users.find(u => u.id === userId);
        if (!user) {
            return { isLinked: false };
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²å…³è”
        if (user.is_linked && user.supervised_app_user) {
            return {
                isLinked: true,
                status: 'synced',
                icon: 'ğŸ”—',
                tooltip: `å·²ä¸ ${user.supervised_app_user} åŒæ­¥`
            };
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„å…³è”è¯·æ±‚
        if (this.hasPendingLinkRequest && this.hasPendingLinkRequest(userId)) {
            return {
                isLinked: true,
                status: 'pending',
                icon: 'â³',
                tooltip: 'å…³è”è¯·æ±‚å¤„ç†ä¸­'
            };
        }
        
        return { isLinked: false };
    },

    // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„å…³è”è¯·æ±‚
    hasPendingLinkRequest() {
        // è¿™ä¸ªæ–¹æ³•å¯ä»¥é€šè¿‡å…¨å±€çŠ¶æ€æˆ–APIè°ƒç”¨æ¥å®ç°
        // æš‚æ—¶è¿”å›falseï¼Œåç»­å¯ä»¥é›†æˆ
        return false;
    },

    // æ˜¾ç¤ºåŒæ­¥çŠ¶æ€æç¤º
    showSyncStatusToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `sync-toast ${type}`;
        toast.innerHTML = `
            <span class="sync-toast-icon">${type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}</span>
            <span class="sync-toast-message">${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // æ˜¾ç¤ºåŠ¨ç”»
        setTimeout(() => toast.classList.add('show'), 100);
        
        // 3ç§’åç§»é™¤
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    },

    // åˆ‡æ¢TODOçŠ¶æ€
    async toggleTodo(checkbox) {
        const toggleContext = this._prepareToggleContext(checkbox);
        if (!toggleContext) return;

        try {
            await this._syncToggleToServer(toggleContext);
            this._updateLocalTodoState(toggleContext);
            this._updateTodoUI(toggleContext);
            this._showSyncStatus(toggleContext);
        } catch (error) {
            this._handleToggleError(error, toggleContext);
        }
    },

    // å‡†å¤‡åˆ‡æ¢ä¸Šä¸‹æ–‡
    _prepareToggleContext(checkbox) {
        const todoId = parseInt(checkbox.dataset.id);
        const userId = parseInt(checkbox.dataset.member);
        
        if (!todoId || !userId) return null;

        const todo = this.todos[userId]?.find(t => t.id === todoId);
        if (!todo) return null;

        const currentDate = DateManager.selectedDate || new Date();
        const dateStr = currentDate.toISOString().split('T')[0];

        return {
            todoId,
            userId,
            todo,
            wasCompleted: todo.completed,
            dateStr,
            checkbox
        };
    },

    // åŒæ­¥åˆ‡æ¢åˆ°æœåŠ¡å™¨
    async _syncToggleToServer(context) {
        const { todoId, userId, wasCompleted, dateStr } = context;
        
        if (WebSocketClient.isConnected) {
            await this._syncViaWebSocket(todoId, userId, dateStr, wasCompleted);
        } else {
            await this._syncViaHTTP(todoId, userId, dateStr, wasCompleted);
        }
    },

    // é€šè¿‡WebSocketåŒæ­¥
    async _syncViaWebSocket(todoId, userId, dateStr, wasCompleted) {
        if (wasCompleted) {
            await WebSocketClient.todos.uncomplete(todoId, dateStr, userId);
        } else {
            await WebSocketClient.todos.complete(todoId, userId, dateStr);
        }
    },

    // é€šè¿‡HTTPåŒæ­¥
    async _syncViaHTTP(todoId, userId, dateStr, wasCompleted) {
        if (wasCompleted) {
            await ApiClient.todos.uncomplete(todoId, dateStr, userId);
        } else {
            await ApiClient.todos.complete(todoId, userId, dateStr);
        }
    },

    // æ›´æ–°æœ¬åœ°TODOçŠ¶æ€
    _updateLocalTodoState(context) {
        const { todo, userId, dateStr } = context;
        
        todo.completed = !todo.completed;
        
        const cacheKey = `${userId}_${dateStr}`;
        this.todoCache.delete(cacheKey);
        console.log('ğŸ§¹ TODOçŠ¶æ€åˆ‡æ¢ï¼šæ¸…é™¤ç¼“å­˜', cacheKey);
    },

    // æ›´æ–°TODOç•Œé¢
    _updateTodoUI(context) {
        const { checkbox, todo } = context;
        const todoItem = checkbox.closest('.todo-item');
        const todoContent = checkbox.nextElementSibling;
        const todoText = todoContent?.querySelector('.todo-text');
        
        if (todo.completed) {
            this._markTodoCompleted(checkbox, todoText, todoItem);
        } else {
            this._markTodoIncomplete(checkbox, todoText, todoItem);
        }
    },

    // æ ‡è®°TODOä¸ºå·²å®Œæˆ
    _markTodoCompleted(checkbox, todoText, todoItem) {
        checkbox.classList.add('checked');
        if (todoText) todoText.classList.add('completed');
        if (todoItem) todoItem.classList.add('completed');
    },

    // æ ‡è®°TODOä¸ºæœªå®Œæˆ
    _markTodoIncomplete(checkbox, todoText, todoItem) {
        checkbox.classList.remove('checked');
        if (todoText) todoText.classList.remove('completed');
        if (todoItem) todoItem.classList.remove('completed');
    },

    // æ˜¾ç¤ºåŒæ­¥çŠ¶æ€
    _showSyncStatus(context) {
        const { userId, todo } = context;
        const syncStatus = this.getSyncStatus(userId);
        
        if (syncStatus.isLinked) {
            const action = todo.completed ? 'å®Œæˆ' : 'å–æ¶ˆå®Œæˆ';
            this.showSyncStatusToast(`${action}çŠ¶æ€å·²åŒæ­¥`, 'success');
        }
    },

    // å¤„ç†åˆ‡æ¢é”™è¯¯
    _handleToggleError(error, context) {
        console.error('åˆ‡æ¢TODOçŠ¶æ€å¤±è´¥:', error);
        context.todo.completed = context.wasCompleted;
        this.showMessage('æ“ä½œå¤±è´¥: ' + error.message, 'error');
    },

    // æ˜¾ç¤ºæ·»åŠ TODOè¡¨å•
    showAddTodoForm(userId) {
        const user = UserManager.getUser(userId);
        if (!user) return;
        
        const formHtml = `
            <div class="modal-overlay" id="addTodoModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>ä¸º ${user.display_name || user.username} æ·»åŠ æ–°TODO</h3>
                        <button class="modal-close" onclick="TodoManager.closeAddTodoForm()">Ã—</button>
                    </div>
                    <form class="todo-form" onsubmit="TodoManager.handleAddTodo(event, ${userId})">
                        <div class="form-group">
                            <label for="todo_title">æ ‡é¢˜ *</label>
                            <input type="text" id="todo_title" name="title" required maxlength="200" placeholder="ä¾‹å¦‚ï¼šåƒé±¼è‚æ²¹">
                        </div>
                        <div class="form-group">
                            <label for="todo_start_date">å¼€å§‹æ—¥æœŸ</label>
                            <input type="date" id="todo_start_date" name="start_date" value="${(DateManager.selectedDate || new Date()).toISOString().split('T')[0]}">
                        </div>
                        <div class="form-group">
                            <label for="todo_description">å¤‡æ³¨</label>
                            <textarea id="todo_description" name="description" maxlength="1000" placeholder="è¯¦ç»†è¯´æ˜ï¼ˆå¯é€‰ï¼‰"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="todo_time">æé†’æ—¶é—´</label>
                            <select id="todo_time" name="reminder_time">
                                <option value="all_day">å½“å¤©</option>
                                <option value="06:00">06:00</option>
                                <option value="07:00">07:00</option>
                                <option value="08:00">08:00</option>
                                <option value="09:00">09:00</option>
                                <option value="10:00">10:00</option>
                                <option value="11:00">11:00</option>
                                <option value="12:00">12:00</option>
                                <option value="13:00">13:00</option>
                                <option value="14:00">14:00</option>
                                <option value="15:00">15:00</option>
                                <option value="16:00">16:00</option>
                                <option value="17:00">17:00</option>
                                <option value="18:00">18:00</option>
                                <option value="19:00">19:00</option>
                                <option value="20:00">20:00</option>
                                <option value="21:00">21:00</option>
                                <option value="22:00">22:00</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo_priority">ä¼˜å…ˆçº§</label>
                            <select id="todo_priority" name="priority">
                                <option value="low">ä½</option>
                                <option value="medium" selected>ä¸­</option>
                                <option value="high">é«˜</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo_repeat">é‡å¤é¢‘ç‡</label>
                            <select id="todo_repeat" name="repeat_type" onchange="TodoManager.handleRepeatChange(this)">
                                <option value="none">ä¸é‡å¤</option>
                                <option value="daily" selected>æ¯å¤©</option>
                                <option value="every_other_day">éš”å¤©</option>
                                <option value="weekly">æ¯å‘¨</option>
                                <option value="monthly">æ¯æœˆ</option>
                                <option value="yearly">æ¯å¹´</option>
                                <option value="custom">è‡ªå®šä¹‰</option>
                            </select>
                        </div>
                        <div class="form-group" id="custom_interval_group" style="display: none;">
                            <label for="custom_interval">è‡ªå®šä¹‰é—´éš”</label>
                            <div class="form-row">
                                <input type="number" id="custom_interval" name="custom_interval" min="1" max="365" value="2" style="width: 80px;">
                                <span style="margin-left: 8px;">å¤©ä¸€æ¬¡</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="todo_cycle">é‡å¤å‘¨æœŸ</label>
                            <select id="todo_cycle" name="cycle_type" onchange="TodoManager.handleCycleChange(this)">
                                <option value="long_term" selected>é•¿æœŸ</option>
                                <option value="custom">è‡ªå®šä¹‰å‘¨æœŸ</option>
                            </select>
                        </div>
                        <div class="form-group" id="custom_cycle_group" style="display: none;">
                            <label for="cycle_duration">å‘¨æœŸæ—¶é•¿</label>
                            <div class="form-row" style="display: table !important; width: 100% !important; table-layout: fixed !important; border-collapse: separate !important; border-spacing: 8px 0 !important;">
                                <input type="number" id="cycle_duration" name="cycle_duration" min="1" max="365" value="1" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; text-align: center !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important;">
                                <select id="cycle_unit" name="cycle_unit" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important; cursor: pointer !important;">
                                    <option value="days">å¤©</option>
                                    <option value="weeks">å‘¨</option>
                                    <option value="months">æœˆ</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-actions">
                            <button type="button" onclick="TodoManager.closeAddTodoForm()">å–æ¶ˆ</button>
                            <button type="submit">æ·»åŠ TODO</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // å…³é—­æ·»åŠ TODOè¡¨å•
    closeAddTodoForm() {
        const modal = document.getElementById('addTodoModal');
        if (modal) {
            modal.remove();
        }
    },

    // å¤„ç†æ·»åŠ TODOè¡¨å•æäº¤ï¼ˆä¸»å…¥å£ï¼‰
    async handleAddTodo(event, userId) {
        event.preventDefault();
        
        try {
            // è§£æè¡¨å•æ•°æ®
            const todoData = this._parseAddTodoForm(event.target, userId);
            
            // åˆ›å»ºTODO
            await this._createTodoOnServer(todoData);
            
            // å¤„ç†åˆ›å»ºæˆåŠŸåçš„æ“ä½œ
            await this._handleAddTodoSuccess(userId);
            
        } catch (error) {
            this._handleAddTodoError(error);
        }
    },

    // è§£ææ·»åŠ TODOè¡¨å•æ•°æ®
    _parseAddTodoForm(form, userId) {
        const formData = new FormData(form);
        const repeatType = formData.get('repeat_type') || 'none';
        const customInterval = parseInt(formData.get('custom_interval')) || 1;
        const cycleType = formData.get('cycle_type') || 'long_term';
        const cycleDuration = parseInt(formData.get('cycle_duration')) || null;
        const cycleUnit = formData.get('cycle_unit') || 'days';
        
        console.log('ğŸ“‹ è¡¨å•æ•°æ®è°ƒè¯•:');
        console.log('  cycleType:', cycleType);
        console.log('  cycleDuration:', cycleDuration);
        console.log('  cycleUnit:', cycleUnit);
        
        // ä½¿ç”¨å½“å‰é€‰ä¸­çš„æ—¥æœŸä½œä¸ºå¼€å§‹æ—¥æœŸ
        const selectedStartDate = formData.get('start_date') || 
            (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
        
        const todoData = {
            user_id: userId,
            title: formData.get('title'),
            description: formData.get('description') || '',
            reminder_time: formData.get('reminder_time') || 'all_day',
            priority: formData.get('priority') || 'medium',
            repeat_type: repeatType,
            repeat_interval: repeatType === 'custom' ? customInterval : 1,
            cycle_type: cycleType,
            cycle_duration: cycleType === 'custom' ? cycleDuration : null,
            cycle_unit: cycleType === 'custom' ? cycleUnit : 'days',
            start_date: selectedStartDate
        };
        
        console.log('ğŸ“¤ å‘é€åˆ°æœåŠ¡å™¨çš„TODOæ•°æ®:', todoData);
        return todoData;
    },

    // åœ¨æœåŠ¡å™¨ä¸Šåˆ›å»ºTODO
    async _createTodoOnServer(todoData) {
        if (WebSocketClient.isConnected) {
            return await this._createTodoViaWebSocket(todoData);
        } else {
            return await this._createTodoViaHTTP(todoData);
        }
    },

    // é€šè¿‡WebSocketåˆ›å»ºTODO
    async _createTodoViaWebSocket(todoData) {
        const response = await WebSocketClient.todos.create(todoData);
        if (response.data && response.data.todo) {
            this.convertApiTodoToLocal(response.data.todo);
            console.log('âœ… é€šè¿‡WebSocketåˆ›å»ºTODOæˆåŠŸ');
            return response;
        } else {
            throw new Error('WebSocketå“åº”æ ¼å¼é”™è¯¯');
        }
    },

    // é€šè¿‡HTTPåˆ›å»ºTODO
    async _createTodoViaHTTP(todoData) {
        const response = await ApiClient.todos.create(todoData);
        if (response.success) {
            this.convertApiTodoToLocal(response.data);
            console.log('âœ… é€šè¿‡HTTPåˆ›å»ºTODOæˆåŠŸ');
            return response;
        } else {
            throw new Error(response.message || 'åˆ›å»ºTODOå¤±è´¥');
        }
    },

    // å¤„ç†TODOåˆ›å»ºæˆåŠŸåçš„æ“ä½œ
    async _handleAddTodoSuccess(userId) {
        // å…³é—­è¡¨å•
        this.closeAddTodoForm();
        
        // æ¸…é™¤ç¼“å­˜å¹¶é‡æ–°åŠ è½½æ•°æ®
        this.clearAllRelatedCache(userId);
        const currentDate = DateManager.selectedDate || new Date();
        await this.loadTodosForDate(currentDate, userId);
        
        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        this.showMessage('TODOæ·»åŠ æˆåŠŸï¼', 'success');
    },

    // å¤„ç†TODOåˆ›å»ºé”™è¯¯
    _handleAddTodoError(error) {
        console.error('æ·»åŠ TODOå¤±è´¥:', error);
        this.showMessage('æ·»åŠ TODOå¤±è´¥: ' + error.message, 'error');
    },

    // å¤„ç†é‡å¤é¢‘ç‡å˜åŒ–
    handleRepeatChange(select) {
        const customGroup = document.getElementById('custom_interval_group');
        if (customGroup) {
            customGroup.style.display = select.value === 'custom' ? 'block' : 'none';
        }
    },

    // å¤„ç†é‡å¤å‘¨æœŸå˜åŒ–
    handleCycleChange(select) {
        const customCycleGroup = document.getElementById('custom_cycle_group');
        if (customCycleGroup) {
            customCycleGroup.style.display = select.value === 'custom' ? 'block' : 'none';
        }
    },

    // æ˜¾ç¤ºç¼–è¾‘TODOè¡¨å•
    showEditTodoForm(todoId, userId) {
        const todo = this.todos[userId]?.find(t => t.id === todoId);
        if (!todo) return;
        
        const user = UserManager.getUser(userId);
        if (!user) return;
        
        const formHtml = this._generateEditFormHTML(todo, user, todoId, userId);
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // ç”Ÿæˆç¼–è¾‘è¡¨å•HTML
    _generateEditFormHTML(todo, user, todoId, userId) {
        return `
            <div class="modal-overlay" id="editTodoModal">
                <div class="modal-content">
                    ${this._generateEditFormHeader(user)}
                    <form class="todo-form" onsubmit="TodoManager.handleEditTodo(event, '${todoId}', ${userId})">
                        ${this._generateBasicFields(todo)}
                        ${this._generateTimeAndPriorityFields(todo)}
                        ${this._generateRepeatFields(todo)}
                        ${this._generateCycleFields(todo)}
                        ${this._generateFormActions(todoId, userId)}
                    </form>
                </div>
            </div>
        `;
    },

    // ç”Ÿæˆè¡¨å•å¤´éƒ¨
    _generateEditFormHeader(user) {
        return `
            <div class="modal-header">
                <h3>ç¼–è¾‘ ${user.display_name || user.username} çš„TODO</h3>
                <button class="modal-close" onclick="TodoManager.closeEditTodoForm()">Ã—</button>
            </div>
        `;
    },

    // ç”ŸæˆåŸºç¡€å­—æ®µ
    _generateBasicFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_title">æ ‡é¢˜ *</label>
                <input type="text" id="edit_todo_title" name="title" required maxlength="200" value="${todo.text}" placeholder="ä¾‹å¦‚ï¼šåƒé±¼è‚æ²¹">
            </div>
            <div class="form-group">
                <label for="edit_todo_start_date">å¼€å§‹æ—¥æœŸ</label>
                <input type="date" id="edit_todo_start_date" name="start_date" value="${todo.createdDate}">
            </div>
            <div class="form-group">
                <label for="edit_todo_description">å¤‡æ³¨</label>
                <textarea id="edit_todo_description" name="description" maxlength="1000" placeholder="è¯¦ç»†è¯´æ˜ï¼ˆå¯é€‰ï¼‰">${todo.note || ''}</textarea>
            </div>
        `;
    },

    // ç”Ÿæˆæ—¶é—´å’Œä¼˜å…ˆçº§å­—æ®µ
    _generateTimeAndPriorityFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_time">æé†’æ—¶é—´</label>
                <select id="edit_todo_time" name="reminder_time">
                    ${this._generateTimeOptions(todo.time)}
                </select>
            </div>
            <div class="form-group">
                <label for="edit_todo_priority">ä¼˜å…ˆçº§</label>
                <select id="edit_todo_priority" name="priority">
                    ${this._generatePriorityOptions(todo.priority)}
                </select>
            </div>
        `;
    },

    // ç”Ÿæˆæ—¶é—´é€‰é¡¹
    _generateTimeOptions(selectedTime) {
        const timeOptions = [
            { value: 'all_day', label: 'å½“å¤©', compareValue: 'å½“å¤©' },
            ...Array.from({ length: 17 }, (_, i) => {
                const hour = String(i + 6).padStart(2, '0');
                return { value: `${hour}:00`, label: `${hour}:00`, compareValue: `${hour}:00` };
            })
        ];

        return timeOptions.map(option => 
            `<option value="${option.value}" ${selectedTime === option.compareValue ? 'selected' : ''}>${option.label}</option>`
        ).join('');
    },

    // ç”Ÿæˆä¼˜å…ˆçº§é€‰é¡¹
    _generatePriorityOptions(selectedPriority) {
        const priorities = [
            { value: 'low', label: 'ä½' },
            { value: 'medium', label: 'ä¸­' },
            { value: 'high', label: 'é«˜' }
        ];

        return priorities.map(priority => {
            const isSelected = priority.value === selectedPriority || 
                             (priority.value === 'medium' && (!selectedPriority || selectedPriority === 'medium'));
            return `<option value="${priority.value}" ${isSelected ? 'selected' : ''}>${priority.label}</option>`;
        }).join('');
    },

    // ç”Ÿæˆé‡å¤å­—æ®µ
    _generateRepeatFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_repeat">é‡å¤é¢‘ç‡</label>
                <select id="edit_todo_repeat" name="repeat_type" onchange="TodoManager.handleEditRepeatChange(this, '${todo.customInterval || 1}')">
                    ${this._generateRepeatOptions(todo.periodType)}
                </select>
            </div>
            <div class="form-group" id="edit_custom_interval_group" style="display: ${todo.periodType === 'custom' ? 'block' : 'none'};">
                <label for="edit_custom_interval">è‡ªå®šä¹‰é—´éš”</label>
                <div class="form-row">
                    <input type="number" id="edit_custom_interval" name="custom_interval" min="1" max="365" value="${todo.customInterval || 1}" style="width: 80px;">
                    <span style="margin-left: 8px;">å¤©ä¸€æ¬¡</span>
                </div>
            </div>
        `;
    },

    // ç”Ÿæˆé‡å¤é€‰é¡¹
    _generateRepeatOptions(selectedType) {
        const repeatTypes = [
            { value: 'none', label: 'ä¸é‡å¤' },
            { value: 'daily', label: 'æ¯å¤©' },
            { value: 'every_other_day', label: 'éš”å¤©' },
            { value: 'weekly', label: 'æ¯å‘¨' },
            { value: 'monthly', label: 'æ¯æœˆ' },
            { value: 'yearly', label: 'æ¯å¹´' },
            { value: 'custom', label: 'è‡ªå®šä¹‰' }
        ];

        return repeatTypes.map(type => {
            const isSelected = type.value === selectedType || 
                             (type.value === 'none' && (!selectedType || selectedType === 'none'));
            return `<option value="${type.value}" ${isSelected ? 'selected' : ''}>${type.label}</option>`;
        }).join('');
    },

    // ç”Ÿæˆå‘¨æœŸå­—æ®µ
    _generateCycleFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_cycle">é‡å¤å‘¨æœŸ</label>
                <select id="edit_todo_cycle" name="cycle_type" onchange="TodoManager.handleEditCycleChange(this, '${todo.cycleDuration || 1}', '${todo.cycleUnit || 'days'}')">
                    ${this._generateCycleOptions(todo.cycleType)}
                </select>
            </div>
            <div class="form-group" id="edit_custom_cycle_group" style="display: ${todo.cycleType === 'custom' ? 'block' : 'none'};">
                <label for="edit_cycle_duration">å‘¨æœŸæ—¶é•¿</label>
                <div class="form-row" style="display: table !important; width: 100% !important; table-layout: fixed !important; border-collapse: separate !important; border-spacing: 8px 0 !important;">
                    <input type="number" id="edit_cycle_duration" name="cycle_duration" min="1" max="365" value="${todo.cycleDuration || 1}" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; text-align: center !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important;">
                    <select id="edit_cycle_unit" name="cycle_unit" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important; cursor: pointer !important;">
                        ${this._generateCycleUnitOptions(todo.cycleUnit)}
                    </select>
                </div>
            </div>
        `;
    },

    // ç”Ÿæˆå‘¨æœŸé€‰é¡¹
    _generateCycleOptions(selectedType) {
        const cycleTypes = [
            { value: 'long_term', label: 'é•¿æœŸ' },
            { value: 'custom', label: 'è‡ªå®šä¹‰å‘¨æœŸ' }
        ];

        return cycleTypes.map(type => {
            const isSelected = type.value === selectedType || 
                             (type.value === 'long_term' && (!selectedType || selectedType === 'long_term'));
            return `<option value="${type.value}" ${isSelected ? 'selected' : ''}>${type.label}</option>`;
        }).join('');
    },

    // ç”Ÿæˆå‘¨æœŸå•ä½é€‰é¡¹
    _generateCycleUnitOptions(selectedUnit) {
        const units = [
            { value: 'days', label: 'å¤©' },
            { value: 'weeks', label: 'å‘¨' },
            { value: 'months', label: 'æœˆ' }
        ];

        return units.map(unit => 
            `<option value="${unit.value}" ${selectedUnit === unit.value ? 'selected' : ''}>${unit.label}</option>`
        ).join('');
    },

    // ç”Ÿæˆè¡¨å•æ“ä½œæŒ‰é’®
    _generateFormActions(todoId, userId) {
        return `
            <div class="form-actions">
                <button type="button" class="delete-btn" onclick="TodoManager.deleteTodo('${todoId}', ${userId})">åˆ é™¤</button>
                <button type="button" onclick="TodoManager.closeEditTodoForm()">å–æ¶ˆ</button>
                <button type="submit">ä¿å­˜</button>
            </div>
        `;
    },

    // å…³é—­ç¼–è¾‘TODOè¡¨å•
    closeEditTodoForm() {
        const modal = document.getElementById('editTodoModal');
        if (modal) {
            modal.remove();
        }
    },

    // å¤„ç†ç¼–è¾‘TODOè¡¨å•æäº¤
    // eslint-disable-next-line no-unused-vars
    async handleEditTodo(event, todoId, _userId) {
        event.preventDefault();
        
        const updateData = this._extractEditFormData(event.target);
        
        try {
            await this._performTodoUpdate(todoId, updateData);
            await this._handleUpdateSuccess();
        } catch (error) {
            this._handleUpdateError(error);
        }
    },

    // æå–ç¼–è¾‘è¡¨å•æ•°æ®
    _extractEditFormData(form) {
        const formData = new FormData(form);
        const repeatType = formData.get('repeat_type') || 'none';
        const cycleType = formData.get('cycle_type') || 'long_term';
        
        return {
            title: formData.get('title'),
            description: formData.get('description') || '',
            reminder_time: formData.get('reminder_time') || 'all_day',
            priority: formData.get('priority') || 'medium',
            repeat_type: repeatType,
            repeat_interval: this._getRepeatInterval(formData, repeatType),
            cycle_type: cycleType,
            cycle_duration: this._getCycleDuration(formData, cycleType),
            cycle_unit: this._getCycleUnit(formData, cycleType),
            start_date: formData.get('start_date')
        };
    },

    // è·å–é‡å¤é—´éš”
    _getRepeatInterval(formData, repeatType) {
        if (repeatType === 'custom') {
            return parseInt(formData.get('custom_interval')) || 1;
        }
        return 1;
    },

    // è·å–å‘¨æœŸæŒç»­æ—¶é—´
    _getCycleDuration(formData, cycleType) {
        if (cycleType === 'custom') {
            return parseInt(formData.get('cycle_duration')) || null;
        }
        return null;
    },

    // è·å–å‘¨æœŸå•ä½
    _getCycleUnit(formData, cycleType) {
        if (cycleType === 'custom') {
            return formData.get('cycle_unit') || 'days';
        }
        return 'days';
    },

    // æ‰§è¡ŒTODOæ›´æ–°
    async _performTodoUpdate(todoId, updateData) {
        const response = await ApiClient.todos.update(todoId, updateData);
        if (!response.success) {
            throw new Error(response.message || 'æ›´æ–°TODOå¤±è´¥');
        }
        console.log('âœ… åœ¨æœåŠ¡å™¨æ›´æ–°TODOæˆåŠŸ');
    },

    // å¤„ç†æ›´æ–°æˆåŠŸ
    async _handleUpdateSuccess() {
        this.closeEditTodoForm();
        this._refreshTodoData();
        this.showMessage('TODOæ›´æ–°æˆåŠŸï¼', 'success');
    },

    // åˆ·æ–°TODOæ•°æ®
    async _refreshTodoData() {
        this.clearAllRelatedCache(this.currentUser);
        const currentDate = DateManager.selectedDate || new Date();
        await this.loadTodosForDate(currentDate, this.currentUser);
    },

    // å¤„ç†æ›´æ–°é”™è¯¯
    _handleUpdateError(error) {
        console.error('æ›´æ–°TODOå¤±è´¥:', error);
        this.showMessage('æ›´æ–°TODOå¤±è´¥: ' + error.message, 'error');
    },

    // å¤„ç†ç¼–è¾‘é‡å¤é¢‘ç‡å˜åŒ–
    handleEditRepeatChange(select, defaultInterval) {
        const customGroup = document.getElementById('edit_custom_interval_group');
        if (customGroup) {
            customGroup.style.display = select.value === 'custom' ? 'block' : 'none';
            if (select.value === 'custom') {
                const intervalInput = document.getElementById('edit_custom_interval');
                if (intervalInput && !intervalInput.value) {
                    intervalInput.value = defaultInterval;
                }
            }
        }
    },

    // å¤„ç†ç¼–è¾‘é‡å¤å‘¨æœŸå˜åŒ–
    handleEditCycleChange(select, defaultDuration, defaultUnit) {
        const customCycleGroup = document.getElementById('edit_custom_cycle_group');
        if (customCycleGroup) {
            customCycleGroup.style.display = select.value === 'custom' ? 'block' : 'none';
            if (select.value === 'custom') {
                const durationInput = document.getElementById('edit_cycle_duration');
                const unitSelect = document.getElementById('edit_cycle_unit');
                if (durationInput && !durationInput.value) {
                    durationInput.value = defaultDuration;
                }
                if (unitSelect && !unitSelect.value) {
                    unitSelect.value = defaultUnit;
                }
            }
        }
    },

    // åˆ é™¤TODO - æ™ºèƒ½åˆ é™¤å¯¹è¯æ¡†
    async deleteTodo(todoId, userId) {
        const todo = this.todos[userId]?.find(t => t.id == todoId);
        if (!todo) return;

        // å¦‚æœæ˜¯é‡å¤ä»»åŠ¡ï¼Œæ˜¾ç¤ºåˆ é™¤é€‰é¡¹å¯¹è¯æ¡†
        if (todo.periodType && todo.periodType !== 'none') {
            this.showDeleteOptionsDialog(todoId, userId, todo);
        } else {
            // ä¸€æ¬¡æ€§ä»»åŠ¡ï¼Œç›´æ¥ç¡®è®¤åˆ é™¤
            
            const confirmed = await DialogUtils.showDeleteConfirm('è¿™ä¸ªTODO');
            if (confirmed) {
                await this.performDelete(todoId, userId, 'all');
            }
        }
    },

    // æ˜¾ç¤ºåˆ é™¤é€‰é¡¹å¯¹è¯æ¡†
    showDeleteOptionsDialog(todoId, userId, todo) {
        const currentDate = DateManager.selectedDate || new Date();
        const currentDateStr = this.formatDate(currentDate);
        
        const dialogHtml = `
            <div class="modal-overlay" id="deleteOptionsModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>åˆ é™¤é‡å¤ä»»åŠ¡</h3>
                        <button class="modal-close" onclick="TodoManager.closeDeleteOptionsDialog()">Ã—</button>
                    </div>
                    <div class="delete-options-content">
                        <p>è¿™æ˜¯ä¸€ä¸ªé‡å¤ä»»åŠ¡ï¼š"${todo.text}"</p>
                        <p>ä½ æƒ³è¦åˆ é™¤ï¼š</p>
                        <div class="delete-options">
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="single" checked>
                                <span>åªåˆ é™¤ ${currentDateStr} çš„è¿™ä¸ªä»»åŠ¡</span>
                            </label>
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="from_date">
                                <span>åˆ é™¤ ${currentDateStr} åŠä»¥åçš„æ‰€æœ‰ä»»åŠ¡</span>
                            </label>
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="all">
                                <span>åˆ é™¤æ‰€æœ‰æ—¥æœŸçš„è¿™ä¸ªä»»åŠ¡</span>
                            </label>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" onclick="TodoManager.closeDeleteOptionsDialog()">å–æ¶ˆ</button>
                        <button type="button" class="delete-btn" onclick="TodoManager.confirmDelete(${todoId}, ${userId})">åˆ é™¤</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', dialogHtml);
    },

    // å…³é—­åˆ é™¤é€‰é¡¹å¯¹è¯æ¡†
    closeDeleteOptionsDialog() {
        const modal = document.getElementById('deleteOptionsModal');
        if (modal) {
            modal.remove();
        }
    },

    // ç¡®è®¤åˆ é™¤
    async confirmDelete(todoId, userId) {
        const selectedOption = document.querySelector('input[name="deleteOption"]:checked');
        if (!selectedOption) return;

        const deletionType = selectedOption.value;
        const currentDate = DateManager.selectedDate || new Date();
        const deletionDate = currentDate.toISOString().split('T')[0];

        this.closeDeleteOptionsDialog();
        await this.performDelete(todoId, userId, deletionType, deletionDate);
    },

    // æ‰§è¡Œåˆ é™¤æ“ä½œ
    async performDelete(todoId, userId, deletionType, deletionDate = null) {
        try {
            // åœ¨æœåŠ¡å™¨åˆ é™¤TODO
            const response = await ApiClient.todos.delete(todoId, deletionType, deletionDate);
            if (response.success) {
                console.log('âœ… åœ¨æœåŠ¡å™¨åˆ é™¤TODOæˆåŠŸ');
                
                // æ¸…é™¤è¯¥ç”¨æˆ·çš„æ‰€æœ‰ç¼“å­˜ï¼Œå› ä¸ºåˆ é™¤å¯èƒ½å½±å“å¤šä¸ªæ—¥æœŸï¼ˆç‰¹åˆ«æ˜¯é•¿æœŸé‡å¤ä»»åŠ¡ï¼‰
                this.clearAllRelatedCache(this.currentUser);
                
                // é‡æ–°åŠ è½½å½“å‰æ—¥æœŸçš„TODOæ•°æ®
                const currentDate = DateManager.selectedDate || new Date();
                await this.loadTodosForDate(currentDate, this.currentUser);
                
                // å…³é—­ç¼–è¾‘è¡¨å•ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
                this.closeEditTodoForm();
                
                // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                this.showMessage(response.message || 'TODOåˆ é™¤æˆåŠŸï¼', 'success');
            } else {
                throw new Error(response.message || 'åˆ é™¤TODOå¤±è´¥');
            }
            
        } catch (error) {
            console.error('åˆ é™¤TODOå¤±è´¥:', error);
            this.showMessage('åˆ é™¤TODOå¤±è´¥: ' + error.message, 'error');
        }
    },

    // æ³¨æ„ï¼šæ—¥æœŸå¯¼èˆªç°åœ¨ç”±DateManagerç»Ÿä¸€å¤„ç†

    // åŠ è½½æŒ‡å®šæ—¥æœŸçš„TODOï¼ˆä¼˜åŒ–ç‰ˆï¼Œæ”¯æŒç¼“å­˜ï¼‰
    async loadTodosForDate(date, userId = null, silent = false, retryCount = 0) {
        const dateStr = date.toISOString().split('T')[0];
        const targetUserId = userId || this.currentUser;
        
        this._logLoadingStart(dateStr, targetUserId, retryCount, silent);
        
        try {
            // æ£€æŸ¥ç¼“å­˜
            if (await this._tryLoadFromCache(targetUserId, dateStr, silent)) {
                return;
            }
            
            // ä»æœåŠ¡å™¨åŠ è½½æ•°æ®
            await this._loadFromServer(targetUserId, userId, dateStr, silent, retryCount);
            
            // æ¸…ç†ç¼“å­˜å’Œæ¸²æŸ“
            this._cleanupCacheAndRender(targetUserId, dateStr, silent);
            
        } catch (error) {
            await this._handleLoadingError(error, date, userId, silent, retryCount, targetUserId, dateStr);
        }
    },

    // è®°å½•åŠ è½½å¼€å§‹æ—¥å¿—
    _logLoadingStart(dateStr, targetUserId, retryCount, silent) {
        if (!silent) {
            console.log('ğŸ”„ å¼€å§‹åŠ è½½æŒ‡å®šæ—¥æœŸçš„TODOæ•°æ®...');
            console.log('ğŸ“… ç›®æ ‡æ—¥æœŸ:', dateStr, 'ç”¨æˆ·ID:', targetUserId, 'é‡è¯•æ¬¡æ•°:', retryCount);
        }
    },

    // å°è¯•ä»ç¼“å­˜åŠ è½½
    async _tryLoadFromCache(targetUserId, dateStr, silent) {
        const cacheKey = `${targetUserId}_${dateStr}`;
        if (!this.todoCache.has(cacheKey)) {
            if (!silent) console.log('ğŸ” ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æœåŠ¡å™¨åŠ è½½æ•°æ®ï¼Œç”¨æˆ·:', targetUserId);
            return false;
        }

        if (!silent) console.log('ğŸ“¦ ä½¿ç”¨ç¼“å­˜æ•°æ®ï¼Œç”¨æˆ·:', targetUserId);
        const cachedData = this.todoCache.get(cacheKey);
        this.todos[targetUserId] = [...cachedData];
        
        this._renderIfNeeded(targetUserId, silent);
        this.lastLoadedDate = dateStr;
        return true;
    },

    // ä»æœåŠ¡å™¨åŠ è½½æ•°æ®
    async _loadFromServer(targetUserId, userId, dateStr, silent, retryCount) {
        const usersToLoad = this._getUsersToLoad(userId, targetUserId);
        
        for (const user of usersToLoad) {
            await this._loadUserTodos(user, dateStr, silent, retryCount);
        }
    },

    // è·å–éœ€è¦åŠ è½½çš„ç”¨æˆ·åˆ—è¡¨
    _getUsersToLoad(userId, targetUserId) {
        return userId ? 
            [UserManager.getUser(userId)].filter(Boolean) : 
            [UserManager.getUser(targetUserId)].filter(Boolean);
    },

    // åŠ è½½å•ä¸ªç”¨æˆ·çš„TODOæ•°æ®
    async _loadUserTodos(user, dateStr, silent, retryCount) {
        try {
            const todos = await this._fetchUserTodos(user, dateStr, silent);
            this.todos[user.id] = todos;
            
            // å­˜å…¥ç¼“å­˜
            const userCacheKey = `${user.id}_${dateStr}`;
            this.todoCache.set(userCacheKey, [...todos]);
            
            if (!silent) {
                console.log(`âœ… å·²åŠ è½½ç”¨æˆ·${user.id}åœ¨${dateStr}çš„TODOæ•°æ®ï¼Œæ•°é‡:`, todos.length);
            }
        } catch (error) {
            await this._handleUserLoadError(user, dateStr, error, retryCount, silent);
        }
    },

    // è·å–ç”¨æˆ·TODOæ•°æ®
    async _fetchUserTodos(user, dateStr, silent) {
        if (WebSocketClient.isConnected) {
            if (!silent) console.log(`ğŸ”Œ ä½¿ç”¨WebSocketåŠ è½½ç”¨æˆ·${user.id}çš„TODOæ•°æ®...`);
            const response = await WebSocketClient.todos.getTodosForDate(user.id, dateStr);
            return response.data.todos.map(todo => this.convertApiTodoToLocal(todo));
        } else {
            if (!silent) console.log(`ğŸŒ ä½¿ç”¨HTTPåŠ è½½ç”¨æˆ·${user.id}çš„TODOæ•°æ®...`);
            const response = await ApiClient.todos.getTodosForDate(user.id, dateStr);
            return response.success ? response.data.map(todo => this.convertApiTodoToLocal(todo)) : [];
        }
    },

    // å¤„ç†ç”¨æˆ·åŠ è½½é”™è¯¯
    // eslint-disable-next-line no-unused-vars
    async _handleUserLoadError(user, dateStr, error, retryCount, _silent) {
        console.warn(`åŠ è½½ç”¨æˆ·${user.id}åœ¨${dateStr}çš„TODOå¤±è´¥:`, error.message);
        
        if (this._shouldRetryUserLoad(error, retryCount)) {
            console.log(`ğŸ”„ è¶…æ—¶é‡è¯• ${retryCount + 1}/${this.MAX_RETRIES} ç”¨æˆ·${user.id}...`);
            await this._delayRetry(retryCount);
            throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯ä»¥è§¦å‘æ•´ä½“é‡è¯•
        }
        
        this.todos[user.id] = [];
    },

    // åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•ç”¨æˆ·åŠ è½½
    _shouldRetryUserLoad(error, retryCount) {
        return error.message.includes('è¯·æ±‚è¶…æ—¶') && retryCount < (this.MAX_RETRIES || 3);
    },

    // å»¶è¿Ÿé‡è¯•
    async _delayRetry(retryCount) {
        const delay = (retryCount + 1) * (this.RETRY_DELAY_BASE || 1000);
        await new Promise(resolve => setTimeout(resolve, delay));
    },

    // æ¸…ç†ç¼“å­˜å¹¶æ¸²æŸ“
    _cleanupCacheAndRender(targetUserId, dateStr, silent) {
        this._cleanupCache();
        this._renderIfNeeded(targetUserId, silent);
        this.lastLoadedDate = dateStr;
    },

    // æ¸…ç†ç¼“å­˜
    _cleanupCache() {
        if (this.todoCache.size > 50) {
            const sortedKeys = Array.from(this.todoCache.keys()).sort();
            const keysToDelete = sortedKeys.slice(0, sortedKeys.length - 50);
            keysToDelete.forEach(key => this.todoCache.delete(key));
        }
    },

    // å¦‚æœéœ€è¦åˆ™æ¸²æŸ“
    _renderIfNeeded(targetUserId, silent) {
        if (!targetUserId) {
            console.warn('âš ï¸ æ— æ³•ç¡®å®šè¦æ¸²æŸ“å“ªä¸ªç”¨æˆ·çš„TODOé¢æ¿');
            return;
        }

        const shouldRender = window.GlobalUserState ? 
            GlobalUserState.getCurrentModule() === 'todo' : true;
            
        if (shouldRender) {
            this.renderTodoPanel(targetUserId);
            if (!silent) console.log('âœ… TODOé¢æ¿æ¸²æŸ“å®Œæˆ');
        } else if (!silent) {
            console.log('â¸ï¸ å½“å‰ä¸åœ¨TODOæ¨¡å—ï¼Œä»…åå°åŒæ­¥æ•°æ®');
        }
    },

    // å¤„ç†åŠ è½½é”™è¯¯
    async _handleLoadingError(error, date, userId, silent, retryCount, targetUserId, dateStr) {
        console.error(`åŠ è½½ç”¨æˆ·${targetUserId}åœ¨${dateStr}çš„TODOå¤±è´¥:`, error);
        
        const MAX_RETRIES = this.MAX_RETRIES || 3;
        
        if (this._shouldRetryLoad(error, retryCount, MAX_RETRIES)) {
            await this._retryLoad(date, userId, silent, retryCount, MAX_RETRIES);
            return;
        }
        
        // æœ€ç»ˆå¤±è´¥å¤„ç†
        this._handleFinalLoadError(error, retryCount, MAX_RETRIES, silent);
    },

    // åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•åŠ è½½
    _shouldRetryLoad(error, retryCount, maxRetries) {
        return error.message.includes('è¯·æ±‚è¶…æ—¶') && retryCount < maxRetries;
    },

    // é‡è¯•åŠ è½½
    async _retryLoad(date, userId, silent, retryCount, maxRetries) {
        console.log(`ğŸ”„ æ•´ä½“è¶…æ—¶é‡è¯• ${retryCount + 1}/${maxRetries}...`);
        if (!silent) {
            this.showMessage(`è¯·æ±‚è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯• (${retryCount + 1}/${maxRetries})...`, 'warning');
        }
        
        const delay = (retryCount + 1) * (this.RETRY_DELAY_MULTIPLIER || 2000);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.loadTodosForDate(date, userId, silent, retryCount + 1);
    },

    // å¤„ç†æœ€ç»ˆåŠ è½½é”™è¯¯
    _handleFinalLoadError(error, retryCount, maxRetries, silent) {
        const errorMsg = retryCount >= maxRetries ? 
            `åŠ è½½TODOå¤±è´¥: ${error.message} (å·²é‡è¯•${maxRetries}æ¬¡)` : 
            `åŠ è½½TODOå¤±è´¥: ${error.message}`;
        
        if (!silent) this.showMessage(errorMsg, 'error');
    },

    // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
    formatDate(date) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        
        const month = months[date.getMonth()];
        const day = date.getDate();
        const weekday = weekdays[date.getDay()];
        
        return `${month} ${day} ${weekday}`;
    },

    // æ˜¾ç¤ºæ¶ˆæ¯
    showMessage(message, type = 'info', duration = 3000) {
        // å¦‚æœæ˜¯é‡è¯•æ¶ˆæ¯ï¼Œä½¿ç”¨ç‰¹æ®Šæ ·å¼
        const isRetry = type === 'warning' && message.includes('é‡è¯•');
        
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            z-index: 10000;
            color: white;
            font-weight: 500;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        `;
        
        switch (type) {
            case 'success':
                messageEl.style.backgroundColor = '#4CAF50';
                break;
            case 'error':
                messageEl.style.backgroundColor = '#f44336';
                break;
            case 'warning':
                messageEl.style.backgroundColor = '#ff9800';
                break;
            default:
                messageEl.style.backgroundColor = '#2196F3';
        }
        
        // å¦‚æœæ˜¯é‡è¯•æ¶ˆæ¯ï¼Œæ·»åŠ åŠ è½½åŠ¨ç”»
        if (isRetry) {
            messageEl.innerHTML = `
                <span class="retry-spinner">â³</span>
                ${message}
            `;
            duration = 10000; // é‡è¯•æ¶ˆæ¯æ˜¾ç¤ºæ›´ä¹…
        }
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, duration);
    },

    // å¤„ç†WebSocketå¹¿æ’­æ¶ˆæ¯ï¼ˆæ¥è‡ªå…¶ä»–è®¾å¤‡çš„æ“ä½œï¼‰
    handleWebSocketBroadcast(type, data) {
        console.log('ğŸ”„ å¤„ç†TODOå¹¿æ’­æ¶ˆæ¯:', type, data);
        
        switch (type) {
            case 'TODO_CREATE_BROADCAST':
            case 'TODO_UPDATE_BROADCAST':
            case 'TODO_DELETE_BROADCAST':
                // æ¸…é™¤æ‰€æœ‰ç”¨æˆ·çš„ç¼“å­˜ï¼Œå› ä¸ºå¹¿æ’­å¯èƒ½æ¥è‡ªå…¶ä»–è®¾å¤‡ï¼Œå½±å“æ‰€æœ‰ç”¨æˆ·
                console.log('ğŸ§¹ å¹¿æ’­æ¶ˆæ¯ï¼šæ¸…é™¤æ‰€æœ‰ç¼“å­˜');
                this.clearAllRelatedCache();
                // é‡æ–°åŠ è½½å½“å‰æ—¥æœŸçš„TODOæ•°æ®
                this.loadTodosForDate(DateManager.selectedDate || new Date(), this.currentUser);
                break;
                
            case 'TODO_COMPLETE_BROADCAST':
            case 'TODO_UNCOMPLETE_BROADCAST':
                // å®ŒæˆçŠ¶æ€å˜åŒ–ä¹Ÿè¦æ¸…é™¤ç¼“å­˜ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
                console.log('ğŸ§¹ å®ŒæˆçŠ¶æ€å¹¿æ’­ï¼šæ¸…é™¤ç›¸å…³ç”¨æˆ·ç¼“å­˜');
                if (data.userId) {
                    this.clearAllRelatedCache(data.userId);
                } else {
                    this.clearAllRelatedCache();
                }
                // é‡æ–°åŠ è½½å½“å‰æ—¥æœŸçš„æ•°æ®
                this.loadTodosForDate(DateManager.selectedDate || new Date(), this.currentUser);
                break;
                
            case 'TODO_SYNC_UPDATE': {
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¤„ç†å…³è”ç”¨æˆ·çš„å®æ—¶åŒæ­¥æ›´æ–°
                console.log('ğŸ”— [TODO] æ”¶åˆ°LinkåŒæ­¥æ›´æ–°:', data);
                
                // ç«‹å³æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                console.log('ğŸ§¹ [TODO] æ¸…é™¤æ‰€æœ‰ç¼“å­˜ä»¥ç¡®ä¿æ•°æ®åŒæ­¥');
                this.clearAllRelatedCache();
                
                // è·å–å½“å‰æ—¥æœŸå’Œç”¨æˆ·
                const currentDate = window.DateManager ? window.DateManager.selectedDate : new Date();
                const currentUser = this.currentUser;
                const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : null;
                
                console.log('ğŸ“… [TODO] åŒæ­¥æ›´æ–°ä¿¡æ¯:', {
                    currentDate: currentDate.toISOString().split('T')[0],
                    currentUser,
                    currentModule,
                    operation: data.operation,
                    fromUser: data.sync?.fromUser
                });
                
                if (currentUser) {
                    // å¼ºåˆ¶é‡æ–°åŠ è½½æ•°æ®
                    this.loadTodosForDate(currentDate, currentUser, false).then(() => {
                        console.log('âœ… [TODO] åŒæ­¥æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
                        
                        // å¦‚æœå½“å‰åœ¨TODOæ¨¡å—ï¼Œç¡®ä¿ç•Œé¢æ›´æ–°
                        if (currentModule === 'todo') {
                            console.log('ğŸ¨ [TODO] é‡æ–°æ¸²æŸ“ç•Œé¢ä»¥æ˜¾ç¤ºåŒæ­¥æ•°æ®');
                            this.renderTodoPanel(currentUser);
                        }
                        
                        // æ˜¾ç¤ºåŒæ­¥é€šçŸ¥
                        if (data.sync && data.sync.fromUser) {
                            const operationText = {
                                'COMPLETE': 'å®Œæˆ',
                                'UNCOMPLETE': 'å–æ¶ˆå®Œæˆ',
                                'CREATE': 'åˆ›å»º',
                                'UPDATE': 'æ›´æ–°',
                                'DELETE': 'åˆ é™¤'
                            }[data.operation] || data.operation;
                            
                            this.showSyncStatusToast(`${data.sync.fromUser} ${operationText}äº†å¾…åŠäº‹é¡¹`, 'success');
                        }
                    }).catch(error => {
                        console.error('âŒ [TODO] åŒæ­¥æ•°æ®é‡æ–°åŠ è½½å¤±è´¥:', error);
                    });
                }
                break;
            }
        }
    },

    // é™çº§åˆ°HTTPæ¨¡å¼
    fallbackToHTTP() {
        console.log('ğŸ“¡ TODOæ¨¡å—é™çº§åˆ°HTTPæ¨¡å¼');
        // ç›®å‰çš„å®ç°å·²ç»è‡ªåŠ¨å¤„ç†é™çº§ï¼Œæ— éœ€é¢å¤–æ“ä½œ
    },

    // æ¸…é™¤æ‰€æœ‰ç›¸å…³ç¼“å­˜ - å½»åº•æ¸…ç†æ–¹æ³•
    clearAllRelatedCache(userId = null) {
        console.log('ğŸ§¹ å¼€å§‹æ¸…é™¤æ‰€æœ‰ç›¸å…³ç¼“å­˜...', userId ? `ç”¨æˆ·${userId}` : 'æ‰€æœ‰ç”¨æˆ·');
        
        if (userId) {
            // æ¸…é™¤æŒ‡å®šç”¨æˆ·çš„æ‰€æœ‰ç¼“å­˜
            const keysToDelete = [];
            for (const key of this.todoCache.keys()) {
                if (key.startsWith(`${userId}_`)) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => {
                this.todoCache.delete(key);
                console.log('ğŸ—‘ï¸ åˆ é™¤ç¼“å­˜:', key);
            });
            console.log(`âœ… å·²æ¸…é™¤ç”¨æˆ·${userId}çš„${keysToDelete.length}ä¸ªç¼“å­˜é¡¹`);
        } else {
            // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
            const cacheCount = this.todoCache.size;
            this.todoCache.clear();
            console.log(`âœ… å·²æ¸…é™¤æ‰€æœ‰${cacheCount}ä¸ªç¼“å­˜é¡¹`);
        }
    },

    // æ¸…é™¤æŒ‡å®šç”¨æˆ·æŒ‡å®šæ—¥æœŸèŒƒå›´çš„ç¼“å­˜
    clearCacheForDateRange(userId, startDate = null, endDate = null) {
        console.log('ğŸ§¹ æ¸…é™¤æ—¥æœŸèŒƒå›´ç¼“å­˜...', {userId, startDate, endDate});
        
        const keysToDelete = [];
        for (const key of this.todoCache.keys()) {
            if (!key.startsWith(`${userId}_`)) continue;
            
            const dateStr = key.split('_')[1];
            if (!startDate && !endDate) {
                // å¦‚æœæ²¡æœ‰æŒ‡å®šæ—¥æœŸèŒƒå›´ï¼Œæ¸…é™¤è¯¥ç”¨æˆ·æ‰€æœ‰ç¼“å­˜
                keysToDelete.push(key);
            } else if (startDate && endDate) {
                // æ£€æŸ¥æ—¥æœŸæ˜¯å¦åœ¨èŒƒå›´å†…
                if (dateStr >= startDate && dateStr <= endDate) {
                    keysToDelete.push(key);
                }
            } else if (startDate) {
                // åªæœ‰å¼€å§‹æ—¥æœŸï¼Œæ¸…é™¤è¯¥æ—¥æœŸåŠä»¥åçš„ç¼“å­˜
                if (dateStr >= startDate) {
                    keysToDelete.push(key);
                }
            }
        }
        
        keysToDelete.forEach(key => {
            this.todoCache.delete(key);
            console.log('ğŸ—‘ï¸ åˆ é™¤èŒƒå›´ç¼“å­˜:', key);
        });
        
        console.log(`âœ… å·²æ¸…é™¤ç”¨æˆ·${userId}çš„${keysToDelete.length}ä¸ªæ—¥æœŸèŒƒå›´ç¼“å­˜é¡¹`);
    },

    // ç»‘å®šäº‹ä»¶
    bindEvents() {
        // ç”¨æˆ·æ ‡ç­¾ç‚¹å‡»äº‹ä»¶ç°åœ¨ç”±GlobalUserStateç»Ÿä¸€å¤„ç†
        // ä¸éœ€è¦åœ¨è¿™é‡Œé‡å¤ç»‘å®šäº‹ä»¶
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.TodoManager = TodoManager;


// Notesç®¡ç†å™¨ - å¥åº·ç¬”è®°åŠŸèƒ½
const NotesManager = {
    notes: {},
    currentUser: 1,
    isOnline: false,
    // ğŸ”¥ æ–°å¢ï¼šæ·»åŠ ç¼“å­˜æœºåˆ¶ï¼Œå‚è€ƒTodoManager
    notesCache: new Map(),
    lastLoadedUser: null,

    // åˆå§‹åŒ–
    async init() {
        console.log('ğŸ”„ åˆå§‹åŒ–Notesç®¡ç†å™¨...');
        
        // æ£€æŸ¥åç«¯è¿æ¥
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.warn('âš ï¸ åç«¯æœåŠ¡ä¸å¯ç”¨ï¼ŒNotesåŠŸèƒ½å°†æ— æ³•æ­£å¸¸å·¥ä½œ');
            this.showOfflineError();
            return;
        }

        // ç­‰å¾…ç”¨æˆ·ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
        await this.waitForUserManager();
        
        // åŠ è½½Notesæ•°æ®
        await this.loadNotesFromAPI();
        
        // è®¾ç½®é»˜è®¤ç”¨æˆ·
        this.setDefaultUser();
        
        // ç›‘å¬å…¨å±€ç”¨æˆ·çŠ¶æ€å˜åŒ–ï¼Œä½†ä¸è®¾ç½®æ¨¡å—
        await this.registerGlobalStateListener();
        
        // WebSocketæ¶ˆæ¯å¤„ç†ç”±websocketClient.jsç»Ÿä¸€ç®¡ç†ï¼Œæ— éœ€å•ç‹¬æ³¨å†Œ
        
        // æ¸²æŸ“ç•Œé¢
        this.renderNotesPanel(this.currentUser);
        this.bindEvents();
        
        console.log('âœ… Notesç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
    },

    // ç­‰å¾…ç”¨æˆ·ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
    async waitForUserManager() {
        // è®¾ç½®æœ€å¤§ç­‰å¾…æ—¶é—´ä¸º5ç§’ï¼Œé¿å…æ–°ç”¨æˆ·æ— é™ç­‰å¾…
        const MAX_WAIT_TIME = 5000; // 5ç§’
        const startTime = Date.now();
        
        if (UserManager.users.length === 0) {
            console.log('â³ Notes: ç­‰å¾…ç”¨æˆ·æ•°æ®åŠ è½½ï¼Œæ–°ç”¨æˆ·æœ€å¤šç­‰å¾…5ç§’...');
            await new Promise(resolve => {
                const checkUsers = () => {
                    const elapsedTime = Date.now() - startTime;
                    
                    if (UserManager.users.length > 0) {
                        console.log('âœ… Notes: ç”¨æˆ·æ•°æ®å·²åŠ è½½');
                        resolve();
                    } else if (elapsedTime >= MAX_WAIT_TIME) {
                        console.log('â° Notes: ç­‰å¾…è¶…æ—¶ï¼Œå¯èƒ½æ˜¯æ–°ç”¨æˆ·æ²¡æœ‰è¢«ç®¡ç†ç”¨æˆ·ï¼Œç»§ç»­åˆå§‹åŒ–...');
                        resolve();
                    } else {
                        setTimeout(checkUsers, 100);
                    }
                };
                checkUsers();
            });
        }
    },

    // ğŸ”¥ æ–°å¢ï¼šç­‰å¾…å¹¶æ³¨å†Œå…¨å±€çŠ¶æ€ç›‘å¬å™¨
    async registerGlobalStateListener() {
        console.log('ğŸ“ [Notes] å¼€å§‹æ³¨å†Œå…¨å±€çŠ¶æ€ç›‘å¬å™¨...');
        
        // ç­‰å¾…GlobalUserStateå‡†å¤‡å¥½
        let attempts = 0;
        const maxAttempts = 50; // æœ€å¤šç­‰å¾…5ç§’
        
        while (!window.GlobalUserState && attempts < maxAttempts) {
            console.log(`â³ [Notes] ç­‰å¾…GlobalUserStateå‡†å¤‡... (${attempts + 1}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (window.GlobalUserState) {
            console.log('ğŸ“ [Notes] æ³¨å†Œå…¨å±€çŠ¶æ€ç›‘å¬å™¨...');
            GlobalUserState.addListener(this.handleGlobalStateChange.bind(this));
            console.log('âœ… [Notes] å…¨å±€çŠ¶æ€ç›‘å¬å™¨æ³¨å†Œå®Œæˆ');
            console.log('ğŸ” [Notes] å½“å‰ç›‘å¬å™¨æ•°é‡:', GlobalUserState.listeners.length);
        } else {
            console.error('âŒ [Notes] GlobalUserStateæœªæ‰¾åˆ°ï¼Œæ— æ³•æ³¨å†Œç›‘å¬å™¨');
        }
    },

    // ğŸ”¥ ä¿®å¤ï¼šé‡å†™æ•°æ®åŠ è½½æœºåˆ¶ï¼Œå‚è€ƒTodoManageræ¨¡å¼
    async loadNotesFromAPI(autoRender = false, targetUserId = null) {
        try {
            console.log('ğŸ”„ [Notes] å¼€å§‹åŠ è½½Notesæ•°æ®...', autoRender ? '(è‡ªåŠ¨æ¸²æŸ“)' : '', 'targetUserId:', targetUserId);
            
            if (targetUserId) {
                await this._loadSingleUserNotes(targetUserId);
            } else {
                await this._loadAllUsersNotes();
            }
            
            this._handleAutoRender(autoRender, targetUserId);
            
        } catch (error) {
            this._handleNotesLoadError(error, autoRender, targetUserId);
        }
    },

    // åŠ è½½å•ä¸ªç”¨æˆ·çš„ç¬”è®°
    async _loadSingleUserNotes(userId) {
        const cacheKey = `notes_${userId}`;
        
        if (this._isNotesDataCached(cacheKey)) {
            this._loadNotesFromCache(userId, cacheKey);
        } else {
            await this._loadNotesFromAPI(userId, cacheKey);
        }
    },

    // æ£€æŸ¥ç¬”è®°æ•°æ®æ˜¯å¦å·²ç¼“å­˜
    _isNotesDataCached(cacheKey) {
        return this.notesCache.has(cacheKey) && 
               Date.now() - this.notesCache.get(cacheKey).timestamp < 30000;
    },

    // ä»ç¼“å­˜åŠ è½½ç¬”è®°æ•°æ®
    _loadNotesFromCache(userId, cacheKey) {
        console.log(`ğŸ“¦ [Notes] ä½¿ç”¨ç¼“å­˜æ•°æ®ï¼Œç”¨æˆ·: ${userId}`);
        this.notes[userId] = this.notesCache.get(cacheKey).data;
    },

    // ä»APIåŠ è½½ç¬”è®°æ•°æ®
    async _loadNotesFromAPI(userId, cacheKey) {
        console.log(`ğŸ“¥ [Notes] ä»APIåŠ è½½ç”¨æˆ· ${userId} çš„Notes...`);
        const response = await ApiClient.notes.getByUserId(userId);
        
        if (response.success) {
            this.notes[userId] = response.data || [];
            this._updateNotesCache(cacheKey, userId);
            console.log(`âœ… [Notes] ç”¨æˆ· ${userId} çš„NotesåŠ è½½å®Œæˆ: ${this.notes[userId].length} æ¡`);
        } else {
            console.warn(`âš ï¸ [Notes] åŠ è½½ç”¨æˆ· ${userId} çš„Noteså¤±è´¥:`, response.message);
            this.notes[userId] = [];
        }
    },

    // æ›´æ–°ç¬”è®°ç¼“å­˜
    _updateNotesCache(cacheKey, userId) {
        this.notesCache.set(cacheKey, {
            data: this.notes[userId],
            timestamp: Date.now()
        });
    },

    // åŠ è½½æ‰€æœ‰ç”¨æˆ·çš„ç¬”è®°
    async _loadAllUsersNotes() {
        for (const user of UserManager.users) {
            console.log(`ğŸ“¥ [Notes] åˆå§‹åŒ–åŠ è½½ç”¨æˆ· ${user.username} çš„Notes...`);
            await this._loadUserNotesData(user);
        }
    },

    // åŠ è½½ç”¨æˆ·ç¬”è®°æ•°æ®
    async _loadUserNotesData(user) {
        const response = await ApiClient.notes.getByUserId(user.id);
        
        if (response.success) {
            this.notes[user.id] = response.data || [];
            this._updateUserNotesCache(user);
            console.log(`âœ… [Notes] ç”¨æˆ· ${user.username} çš„NotesåŠ è½½å®Œæˆ: ${this.notes[user.id].length} æ¡`);
        } else {
            console.warn(`âš ï¸ [Notes] åŠ è½½ç”¨æˆ· ${user.username} çš„Noteså¤±è´¥:`, response.message);
            this.notes[user.id] = [];
        }
    },

    // æ›´æ–°ç”¨æˆ·ç¬”è®°ç¼“å­˜
    _updateUserNotesCache(user) {
        const cacheKey = `notes_${user.id}`;
        this.notesCache.set(cacheKey, {
            data: this.notes[user.id],
            timestamp: Date.now()
        });
    },

    // å¤„ç†è‡ªåŠ¨æ¸²æŸ“
    _handleAutoRender(autoRender, targetUserId) {
        if (autoRender) {
            const renderUserId = targetUserId || this.currentUser;
            if (renderUserId) {
                console.log('ğŸ¨ [Notes] æ•°æ®åŠ è½½å®Œæˆï¼Œæ¸²æŸ“æŒ‡å®šç”¨æˆ·ç•Œé¢:', renderUserId);
                console.log('ğŸ” [Notes] ç”¨æˆ·æ•°æ®:', this.notes[renderUserId] ? this.notes[renderUserId].length : 'undefined');
                this.renderNotesPanel(renderUserId);
            }
        }
    },

    // å¤„ç†ç¬”è®°åŠ è½½é”™è¯¯
    _handleNotesLoadError(error, autoRender, targetUserId) {
        console.error('âŒ [Notes] åŠ è½½Notesæ•°æ®å¤±è´¥:', error);
        this.showMessage('åŠ è½½ç¬”è®°æ•°æ®å¤±è´¥: ' + error.message, 'error');
        
        this._initializeEmptyNotesData(targetUserId);
        this._renderOnError(autoRender, targetUserId);
    },

    // åˆå§‹åŒ–ç©ºçš„ç¬”è®°æ•°æ®
    _initializeEmptyNotesData(targetUserId) {
        if (targetUserId) {
            this.notes[targetUserId] = [];
        } else {
            UserManager.users.forEach(user => {
                this.notes[user.id] = [];
            });
        }
    },

    // é”™è¯¯æ—¶æ¸²æŸ“ç•Œé¢
    _renderOnError(autoRender, targetUserId) {
        if (autoRender) {
            const renderUserId = targetUserId || this.currentUser;
            if (renderUserId) {
                console.log('ğŸ¨ [Notes] æ•°æ®åŠ è½½å¤±è´¥ï¼Œä»ç„¶æ¸²æŸ“ç•Œé¢é¿å…ç©ºç™½ï¼Œç”¨æˆ·:', renderUserId);
                this.renderNotesPanel(renderUserId);
            }
        }
    },

    // ğŸ”¥ ä¿®å¤ï¼šè®¾ç½®é»˜è®¤ç”¨æˆ·ï¼ˆå‚è€ƒTodoManageræ¨¡å¼ï¼‰
    setDefaultUser() {
        console.log('ğŸ”„ [Notes] å¼€å§‹è®¾ç½®é»˜è®¤ç”¨æˆ·...');
        console.log('ğŸ” [Notes] ç”¨æˆ·æ•°æ®è°ƒè¯•:');
        console.log('  - UserManager.users.length:', UserManager.users.length);
        console.log('  - UserManager.users:', UserManager.users);
        
        if (UserManager.users.length > 0) {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„ç”¨æˆ·é€‰æ‹©
            let savedUserId = null;
            if (window.GlobalUserState) {
                savedUserId = GlobalUserState.getCurrentUser();
                console.log('ğŸ’¾ [Notes] ä»å…¨å±€çŠ¶æ€è·å–ä¿å­˜çš„ç”¨æˆ·ID:', savedUserId);
            }
            
            // ğŸ”¥ ä¿®å¤ï¼šæŒ‰IDæ’åºï¼Œé€‰æ‹©IDæœ€å°çš„ç”¨æˆ·ï¼ˆæœ€æ—©æ·»åŠ çš„ç”¨æˆ·ï¼‰
            const sortedUsers = [...UserManager.users].sort((a, b) => a.id - b.id);
            
            // éªŒè¯ä¿å­˜çš„ç”¨æˆ·IDæ˜¯å¦ä»ç„¶å­˜åœ¨
            let defaultUser;
            if (savedUserId && sortedUsers.find(u => u.id == savedUserId)) {
                defaultUser = parseInt(savedUserId);
                console.log('ğŸ¯ [Notes] ä½¿ç”¨ä¿å­˜çš„ç”¨æˆ·ID:', defaultUser);
            } else {
                defaultUser = sortedUsers[0].id;
                console.log('ğŸ¯ [Notes] ä½¿ç”¨é»˜è®¤ç¬¬ä¸€ä¸ªç”¨æˆ·:', defaultUser, '(ç”¨æˆ·å:', sortedUsers[0].username, ')');
            }
            
            console.log('ğŸ“‹ [Notes] æ‰€æœ‰ç”¨æˆ·æŒ‰IDæ’åº:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));
            this.currentUser = defaultUser;
            
            // ç›´æ¥åŒæ­¥å…¨å±€çŠ¶æ€ï¼Œä¸è§¦å‘äº‹ä»¶
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = defaultUser;
                localStorage.setItem('wenting_current_user_id', defaultUser.toString());
                console.log('ğŸ”„ [Notes] ç›´æ¥åŒæ­¥å…¨å±€ç”¨æˆ·çŠ¶æ€ï¼ˆä¸è§¦å‘äº‹ä»¶ï¼‰');
                console.log('ğŸ” [Notes] è®¾ç½®åçš„çŠ¶æ€:');
                console.log('  - NotesManager.currentUser:', this.currentUser);
                console.log('  - GlobalUserState.currentUserId:', GlobalUserState.currentUserId);
            }
        } else {
            console.log('ğŸ“ [Notes] æ²¡æœ‰ç”¨æˆ·ï¼Œè®¾ç½®ä¸ºç©ºçŠ¶æ€');
            this.currentUser = null;
            
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = null;
                console.log('ğŸ”„ [Notes] è®¾ç½®å…¨å±€çŠ¶æ€ä¸ºç©ºç”¨æˆ·çŠ¶æ€');
            }
        }
    },

    // ğŸ”¥ ä¿®å¤ï¼šå¤„ç†å…¨å±€çŠ¶æ€å˜åŒ–ï¼ˆå‚è€ƒTodoManageræ¨¡å¼ï¼‰
    handleGlobalStateChange(type, data) {
        console.log('ğŸ“¢ [Notes] æ”¶åˆ°å…¨å±€çŠ¶æ€å˜åŒ–:', type, data);
        
        if (type === 'userChanged') {
            const newUserId = data.userId;
            console.log('ğŸ”„ [Notes] å¤„ç†ç”¨æˆ·åˆ‡æ¢äº‹ä»¶:');
            console.log('  - å½“å‰ç”¨æˆ·:', this.currentUser);
            console.log('  - æ–°ç”¨æˆ·:', newUserId);
            
            // å…ˆæ›´æ–°currentUserï¼Œç¡®ä¿åç»­æ“ä½œä½¿ç”¨æ­£ç¡®çš„ç”¨æˆ·ID
            const oldUser = this.currentUser;
            this.currentUser = newUserId;
            
            if (oldUser !== newUserId) {
                console.log(`ğŸ”„ [Notes] ç”¨æˆ·ä» ${oldUser} åˆ‡æ¢åˆ° ${newUserId}`);
                // åªæœ‰å½“å‰æ¨¡å—æ˜¯notesæ—¶æ‰æ¸²æŸ“
                if (GlobalUserState.getCurrentModule() === 'notes') {
                    console.log('âœ… [Notes] å½“å‰æ˜¯Notesæ¨¡å—ï¼Œç›´æ¥æ¸²æŸ“Noteså†…å®¹');
                    
                    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šç›´æ¥è°ƒç”¨æ¸²æŸ“æ–¹æ³•ï¼Œè®©æ¸²æŸ“æ–¹æ³•å†…éƒ¨å¤„ç†æ•°æ®åŠ è½½
                    this.renderNotesPanel(newUserId);
                } else {
                    console.log('â¸ï¸ [Notes] å½“å‰ä¸æ˜¯Notesæ¨¡å—ï¼Œè·³è¿‡æ¸²æŸ“');
                }
            } else {
                console.log('ğŸ”„ [Notes] ç”¨æˆ·IDç›¸åŒï¼Œä½†ä»éœ€é‡æ–°æ¸²æŸ“Notesé¢æ¿ï¼ˆå¯èƒ½æ˜¯åˆå§‹åŒ–è°ƒç”¨ï¼‰');
                if (GlobalUserState.getCurrentModule() === 'notes') {
                    console.log('âœ… [Notes] å½“å‰æ˜¯Notesæ¨¡å—ï¼Œç›´æ¥æ¸²æŸ“Noteså†…å®¹');
                    this.renderNotesPanel(newUserId);
                } else {
                    console.log('â¸ï¸ [Notes] å½“å‰ä¸æ˜¯Notesæ¨¡å—ï¼Œè·³è¿‡æ¸²æŸ“');
                }
            }
        }
    },
    
    // ğŸ”¥ æ–°å¢ï¼šåŠ è½½å•ä¸ªç”¨æˆ·çš„Notesæ•°æ®ï¼ˆå‚è€ƒTodoManageræ¨¡å¼ï¼‰
    async loadNotesForUser(userId, autoRender = false) {
        try {
            console.log(`ğŸ“¥ [Notes] å¼€å§‹åŠ è½½ç”¨æˆ·${userId}çš„Notes...`);
            
            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ¸…é™¤æ—§æ•°æ®å’Œç¼“å­˜ï¼Œé¿å…æ•°æ®ä¸²ç”¨
            console.log(`ğŸ§¹ [Notes] æ¸…é™¤ç”¨æˆ·${userId}çš„æ—§æ•°æ®å’Œç¼“å­˜...`);
            
            // å¼ºåˆ¶æ¸…é™¤æ•°æ®
            if (this.notes[userId]) {
                delete this.notes[userId];
                console.log(`âœ… [Notes] å·²æ¸…é™¤ç”¨æˆ·${userId}çš„æ—§æ•°æ®`);
            }
            
            // æ¸…é™¤ç¼“å­˜
            const cacheKey = `notes_${userId}`;
            if (this.notesCache.has(cacheKey)) {
                this.notesCache.delete(cacheKey);
                console.log(`âœ… [Notes] å·²æ¸…é™¤ç”¨æˆ·${userId}çš„ç¼“å­˜`);
            }
            
            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå…ˆåˆå§‹åŒ–ä¸ºç©ºæ•°ç»„ï¼Œç„¶ååŠ è½½
            this.notes[userId] = [];
            console.log(`ğŸ”„ [Notes] ç”¨æˆ·${userId}åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„`);
            
            // é‡æ–°åŠ è½½æ•°æ®
            await this.loadNotesFromAPI(autoRender, userId);
            
            console.log(`âœ… [Notes] ç”¨æˆ·${userId}çš„NotesåŠ è½½å®Œæˆï¼Œæœ€ç»ˆæ•°æ®:`, this.notes[userId]);
            
        } catch (error) {
            console.error(`âŒ [Notes] åŠ è½½ç”¨æˆ·${userId}çš„Noteså¤±è´¥:`, error);
            // ç¡®ä¿å¤±è´¥æ—¶ä¹Ÿæœ‰ç©ºæ•°ç»„
            this.notes[userId] = [];
            if (autoRender) {
                this.renderNotesPanel(userId);
            }
        }
    },



    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¤„ç†WebSocketå¹¿æ’­æ¶ˆæ¯ï¼ˆå®Œå…¨æŒ‰ç…§TodoManagerçš„æ¨¡å¼ï¼‰
    handleWebSocketBroadcast(type, data) {
        console.log('ğŸ”„ å¤„ç†Noteså¹¿æ’­æ¶ˆæ¯:', type, data);
        
        switch (type) {
            case 'NOTES_CREATE_BROADCAST':
            case 'NOTES_UPDATE_BROADCAST':
            case 'NOTES_DELETE_BROADCAST': {
                // ğŸ”¥ ä¿®å¤ï¼šä»…æ¸…é™¤å½“å‰ç”¨æˆ·çš„ç¼“å­˜ï¼Œè€Œä¸æ˜¯æ‰€æœ‰ç”¨æˆ·
                console.log('ğŸ§¹ [Notes] å¹¿æ’­æ¶ˆæ¯ï¼šæ¸…é™¤å½“å‰ç”¨æˆ·ç¼“å­˜');
                this.clearAllNotesCache(this.currentUser);
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä»…å½“å½“å‰æ¨¡å—ä¸ºnotesæ—¶è‡ªåŠ¨æ¸²æŸ“
                const shouldAutoRender = window.GlobalUserState && GlobalUserState.getCurrentModule() === 'notes';
                if (shouldAutoRender) {
                    console.log('ğŸ”„ [Notes] å½“å‰æ˜¯Notesæ¨¡å—ï¼Œé‡æ–°åŠ è½½æ•°æ®');
                    this.loadNotesForUser(this.currentUser, true);
                } else {
                    console.log('â¸ï¸ [Notes] å½“å‰ä¸æ˜¯Notesæ¨¡å—ï¼Œè·³è¿‡æ¸²æŸ“');
                }
                break;
            }
                
            case 'NOTES_SYNC_UPDATE': {
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¤„ç†å…³è”ç”¨æˆ·çš„å®æ—¶åŒæ­¥æ›´æ–°
                console.log('ğŸ”— [Notes] æ”¶åˆ°LinkåŒæ­¥æ›´æ–°:', data);
                console.log('ğŸ”— [Notes] å½“å‰NotesManagerçŠ¶æ€:', {
                    currentUser: this.currentUser,
                    currentModule: window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : null,
                    notesCount: Object.keys(this.notes).length
                });
                
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„æ“ä½œï¼Œé¿å…é‡å¤å¤„ç†
                const currentAppUser = localStorage.getItem('wenting_current_app_user');
                const isOwnOperation = data.sync && data.sync.fromUser === currentAppUser;
                
                console.log('ğŸ” [Notes] åŒæ­¥æ¶ˆæ¯æ¥æºæ£€æŸ¥:', {
                    fromUser: data.sync?.fromUser,
                    currentAppUser: currentAppUser,
                    isOwnOperation: isOwnOperation
                });
                
                if (isOwnOperation) {
                    console.log('â¸ï¸ [Notes] è¿™æ˜¯è‡ªå·±çš„æ“ä½œï¼Œè·³è¿‡åŒæ­¥é‡è½½ï¼ˆé¿å…ç•Œé¢é—ªçƒï¼‰');
                    
                    // åªæ˜¾ç¤ºæˆåŠŸæç¤ºï¼Œä¸é‡æ–°åŠ è½½æ•°æ®
                    if (data.sync && data.sync.fromUser) {
                        const operationText = {
                            'CREATE': 'åˆ›å»º',
                            'UPDATE': 'æ›´æ–°',
                            'DELETE': 'åˆ é™¤'
                        }[data.operation] || data.operation;
                        
                        this.showSyncStatusToast(`${operationText}æ“ä½œå·²åŒæ­¥åˆ°å…³è”ç”¨æˆ·`, 'info');
                    }
                    return;
                }
                
                // ğŸ”¥ æ–°å¢ï¼šç«‹å³æ˜¾ç¤ºåŒæ­¥æç¤º
                this.showSyncStatusToast('æ­£åœ¨åŒæ­¥Notesæ•°æ®...', 'info');
                
                // ğŸ”¥ ä¿®å¤ï¼šä»…æ¸…é™¤å½“å‰ç”¨æˆ·çš„ç¼“å­˜
                console.log('ğŸ§¹ [Notes] æ¸…é™¤å½“å‰ç”¨æˆ·ç¼“å­˜ä»¥ç¡®ä¿æ•°æ®åŒæ­¥');
                this.clearAllNotesCache(this.currentUser);
                
                // è·å–å½“å‰ç”¨æˆ·å’Œæ¨¡å—
                const currentUser = this.currentUser;
                const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : null;
                
                console.log('ğŸ“ [Notes] å¤„ç†å…¶ä»–ç”¨æˆ·çš„åŒæ­¥æ›´æ–°:', {
                    currentUser,
                    currentModule,
                    operation: data.operation,
                    fromUser: data.sync?.fromUser
                });
                
                if (currentUser) {
                    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå§‹ç»ˆè¿›è¡Œæ•°æ®åŒæ­¥ï¼Œä½†æ ¹æ®æ¨¡å—å†³å®šæ˜¯å¦æ¸²æŸ“UI
                    const shouldAutoRender = currentModule === 'notes';
                    console.log('ğŸ”„ [Notes] å¼€å§‹é‡æ–°åŠ è½½æ•°æ®ï¼Œè‡ªåŠ¨æ¸²æŸ“:', shouldAutoRender);
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå§‹ç»ˆé‡æ–°åŠ è½½æ•°æ®ç¡®ä¿ç¼“å­˜æ›´æ–°
                    this.loadNotesForUser(currentUser, shouldAutoRender).then(() => {
                        console.log('âœ… [Notes] åŒæ­¥æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
                        
                        // æ˜¾ç¤ºæˆåŠŸæç¤º
                        if (data.sync && data.sync.fromUser) {
                            const operationText = {
                                'CREATE': 'åˆ›å»º',
                                'UPDATE': 'æ›´æ–°',
                                'DELETE': 'åˆ é™¤'
                            }[data.operation] || data.operation;
                            
                            const syncType = shouldAutoRender ? 'å·²åŒæ­¥' : 'åå°åŒæ­¥';
                            this.showSyncStatusToast(`${data.sync.fromUser} ${operationText}äº†å¥åº·ç¬”è®° (${syncType})`, 'success');
                        }
                    }).catch(error => {
                        console.error('âŒ [Notes] åŒæ­¥æ•°æ®é‡æ–°åŠ è½½å¤±è´¥:', error);
                        this.showSyncStatusToast('åŒæ­¥å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', 'error');
                    });
                }
                break;
            }
        }
    },



    // é™çº§åˆ°HTTPæ¨¡å¼
    fallbackToHTTP() {
        console.log('ğŸ“¡ Notesæ¨¡å—é™çº§åˆ°HTTPæ¨¡å¼');
        // ç›®å‰çš„å®ç°å·²ç»è‡ªåŠ¨å¤„ç†é™çº§ï¼Œæ— éœ€é¢å¤–æ“ä½œ
    },

    // ğŸ”¥ ä¿®å¤ï¼šæ¸…é™¤Notesç¼“å­˜ï¼ˆå¢åŠ Mapç¼“å­˜æ¸…ç†ï¼‰
    clearAllNotesCache(userId = null) {
        console.log('ğŸ§¹ [Notes] å¼€å§‹æ¸…é™¤Notesç¼“å­˜...', userId ? `ç”¨æˆ·${userId}` : 'æ‰€æœ‰ç”¨æˆ·');
        
        if (userId) {
            // æ¸…é™¤æŒ‡å®šç”¨æˆ·çš„Notesæ•°æ®
            if (this.notes[userId]) {
                delete this.notes[userId];
                console.log(`âœ… [Notes] å·²æ¸…é™¤ç”¨æˆ·${userId}çš„Notesæ•°æ®`);
            }
            // æ¸…é™¤Mapç¼“å­˜
            const cacheKey = `notes_${userId}`;
            if (this.notesCache.has(cacheKey)) {
                this.notesCache.delete(cacheKey);
                console.log(`âœ… [Notes] å·²æ¸…é™¤ç”¨æˆ·${userId}çš„Mapç¼“å­˜`);
            }
        } else {
            // æ¸…é™¤æ‰€æœ‰Notesæ•°æ®
            const userCount = Object.keys(this.notes).length;
            this.notes = {};
            this.notesCache.clear(); // æ¸…é™¤Mapç¼“å­˜
            console.log(`âœ… [Notes] å·²æ¸…é™¤æ‰€æœ‰${userCount}ä¸ªç”¨æˆ·çš„Notesç¼“å­˜`);
        }
    },

    // ğŸ”¥ ä¿®å¤ï¼šæ¸²æŸ“Notesé¢æ¿ - ç¡®ä¿æ•°æ®æ­£ç¡®åŠ è½½å’Œæ˜¾ç¤º
    async renderNotesPanel(userId) {
        const contentArea = Utils.$('#contentArea');
        if (!contentArea) return;

        console.log(`ğŸ¨ [Notes] å¼€å§‹æ¸²æŸ“ç”¨æˆ· ${userId} çš„Notesé¢æ¿`);
        console.log(`ğŸ” [Notes] å½“å‰ç”¨æˆ·æ•°æ®æ£€æŸ¥:`, {
            userId: userId,
            hasData: !!this.notes[userId],
            dataLength: this.notes[userId] ? this.notes[userId].length : 'undefined',
            allUsersData: Object.keys(this.notes).map(id => `${id}:${this.notes[id]?.length || 0}`).join(', ')
        });

        // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¦‚æœç”¨æˆ·æ•°æ®ä¸å­˜åœ¨æˆ–ä¸ºç©ºï¼Œå…ˆå°è¯•åŠ è½½
        if (!this.notes[userId] || this.notes[userId].length === 0) {
            console.log(`ğŸ“¥ [Notes] ç”¨æˆ·${userId}æ•°æ®ä¸ºç©ºï¼Œå°è¯•ä»APIåŠ è½½...`);
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            contentArea.innerHTML = `
                <div class="content-panel" id="${userId}-notes-panel">
                    <div class="notes-content">
                        <div class="notes-loading">
                            <div class="loading-spinner"></div>
                            <p>æ­£åœ¨åŠ è½½ç¬”è®°...</p>
                        </div>
                    </div>
                </div>
            `;
            
            try {
                // å¼ºåˆ¶ä»APIé‡æ–°åŠ è½½æ•°æ®
                await this.loadNotesForUser(userId, false);
                console.log(`âœ… [Notes] ç”¨æˆ·${userId}æ•°æ®åŠ è½½å®Œæˆï¼Œé‡æ–°æ¸²æŸ“`);
            } catch (error) {
                console.error(`âŒ [Notes] åŠ è½½ç”¨æˆ·${userId}æ•°æ®å¤±è´¥:`, error);
                // ç»§ç»­æ¸²æŸ“ç©ºçŠ¶æ€
            }
        }

        // è·å–æœ€æ–°çš„ç”¨æˆ·æ•°æ®
        const userNotes = this.notes[userId] || [];
        console.log(`ğŸ¨ [Notes] æœ€ç»ˆæ¸²æŸ“ç”¨æˆ· ${userId} çš„Notesé¢æ¿ï¼Œå…± ${userNotes.length} æ¡ç¬”è®°`);
        console.log(`ğŸ” [Notes] ç”¨æˆ·${userId}çš„æœ€ç»ˆæ•°æ®:`, userNotes);

        const panelHtml = `
            <div class="content-panel" id="${userId}-notes-panel">
                <div class="notes-content">
                    <div class="notes-container">
                        ${userNotes.length > 0 
                            ? userNotes.map(note => this.renderNoteCard(note, userId)).join('')
                            : this.renderEmptyState()
                        }
                    </div>
                </div>
                <button class="new-note-btn" onclick="NotesManager.showAddNoteForm(${userId})">+ æ·»åŠ æ–°ç¬”è®°</button>
            </div>
        `;

        contentArea.innerHTML = panelHtml;
        console.log(`âœ… [Notes] ç”¨æˆ·${userId}çš„Notesé¢æ¿æ¸²æŸ“å®Œæˆ`);
    },

    // æ¸²æŸ“ç¬”è®°å¡ç‰‡
    // eslint-disable-next-line no-unused-vars
    renderNoteCard(note, _userId) {
        const shortDescription = note.description.length > 50 
            ? note.description.substring(0, 50) + '...' 
            : note.description;

        // è·å–åŒæ­¥çŠ¶æ€
        const syncStatus = this.getSyncStatus(note.user_id);
        const syncIndicator = syncStatus.isLinked ? `
            <div class="sync-indicator ${syncStatus.status}" title="${syncStatus.tooltip}">
                <span class="sync-icon">${syncStatus.icon}</span>
            </div>
        ` : '';

        return `
            <div class="note-card clickable" data-note-id="${note.id}" onclick="NotesManager.showNoteDetails(${note.id})">
                <div class="note-header">
                    <div class="note-title-container">
                        <h3 class="note-title">${Utils.escapeHtml(note.title)}</h3>
                        ${syncIndicator}
                    </div>
                    <div class="note-actions" onclick="event.stopPropagation()">
                        <button class="note-action-btn delete" onclick="NotesManager.deleteNote(${note.id})" title="åˆ é™¤">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                ${shortDescription ? `<p class="note-description">${Utils.escapeHtml(shortDescription)}</p>` : ''}
                ${note.precautions ? `<div class="note-precautions">
                    <strong>æ³¨æ„äº‹é¡¹:</strong> ${Utils.escapeHtml(note.precautions.length > 80 ? note.precautions.substring(0, 80) + '...' : note.precautions)}
                </div>` : ''}
            </div>
        `;
    },

    // è·å–åŒæ­¥çŠ¶æ€
    getSyncStatus(userId) {
        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰å…³è”å…³ç³»
        const user = UserManager.users.find(u => u.id === userId);
        if (!user) {
            return { isLinked: false };
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²å…³è”
        if (user.is_linked && user.supervised_app_user) {
            return {
                isLinked: true,
                status: 'synced',
                icon: 'ğŸ”—',
                tooltip: `å·²ä¸ ${user.supervised_app_user} åŒæ­¥`
            };
        }
        
        return { isLinked: false };
    },

    // æ˜¾ç¤ºåŒæ­¥çŠ¶æ€æç¤º
    showSyncStatusToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `sync-toast ${type}`;
        toast.innerHTML = `
            <span class="sync-toast-icon">${type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}</span>
            <span class="sync-toast-message">${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // æ˜¾ç¤ºåŠ¨ç”»
        setTimeout(() => toast.classList.add('show'), 100);
        
        // 3ç§’åç§»é™¤
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    },

    // æ¸²æŸ“ç©ºçŠ¶æ€
    renderEmptyState() {
        return `
            <div class="notes-empty-state">
                <div class="empty-icon">ğŸ“</div>
                <h3>è¿˜æ²¡æœ‰å¥åº·ç¬”è®°</h3>
                <p>å¼€å§‹è®°å½•æ‚¨çš„å¥åº·çŠ¶å†µå’Œæ³¨æ„äº‹é¡¹</p>
            </div>
        `;
    },

    // æ˜¾ç¤ºæ·»åŠ ç¬”è®°è¡¨å•
    showAddNoteForm(userId) {
        const formHtml = `
            <div class="modal-overlay" id="addNoteModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>æ·»åŠ å¥åº·ç¬”è®°</h3>
                        <button class="modal-close" onclick="NotesManager.closeNoteForm()">Ã—</button>
                    </div>
                    <form class="note-form" onsubmit="NotesManager.handleAddNote(event, ${userId})">
                        <div class="form-group">
                            <label for="note-title">å¥åº·çŠ¶å†µæ ‡é¢˜ *</label>
                            <input type="text" id="note-title" name="title" required maxlength="100" 
                                   placeholder="å¦‚ï¼šå…³èŠ‚ç‚ã€è¡€å‹é«˜ã€è½»åº¦æŠ‘éƒç­‰">
                        </div>
                        <div class="form-group">
                            <label for="note-description">è¯¦ç»†æè¿°</label>
                            <textarea id="note-description" name="description" rows="4" 
                                      placeholder="è¯¦ç»†æè¿°æ‚¨çš„å¥åº·çŠ¶å†µ..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="note-precautions">æ³¨æ„äº‹é¡¹/åŒ»å˜±</label>
                            <textarea id="note-precautions" name="precautions" rows="3" 
                                      placeholder="åŒ»ç”Ÿå»ºè®®ã€æ³¨æ„äº‹é¡¹ç­‰..."></textarea>
                        </div>
                        <div class="form-actions">
                            <button type="button" onclick="NotesManager.closeNoteForm()">å–æ¶ˆ</button>
                            <button type="submit">ä¿å­˜ç¬”è®°</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // å¤„ç†æ·»åŠ ç¬”è®°
    async handleAddNote(event, userId) {
        event.preventDefault();
        
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        
        try {
            // é˜²æ­¢é‡å¤æäº¤
            submitButton.disabled = true;
            submitButton.textContent = 'ä¿å­˜ä¸­...';
            
            const formData = new FormData(form);
            const noteData = {
                user_id: parseInt(userId),
                title: formData.get('title').trim(),
                description: formData.get('description').trim(),
                precautions: formData.get('precautions').trim()
            };
            
            console.log('ğŸ”„ åˆ›å»ºæ–°ç¬”è®°:', noteData);
            const response = await ApiClient.notes.create(noteData);
            
            if (response.success) {
                console.log('âœ… [Notes] åç«¯åˆ›å»ºæˆåŠŸ:', response.data);
                
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šç›´æ¥å°†æ–°ç¬”è®°æ·»åŠ åˆ°æœ¬åœ°æ•°æ®ï¼Œç„¶åæ¸²æŸ“
                if (!this.notes[userId]) {
                    this.notes[userId] = [];
                }
                this.notes[userId].unshift(response.data); // æ·»åŠ åˆ°æ•°ç»„å¼€å¤´
                
                // æ›´æ–°ç¼“å­˜
                const cacheKey = `notes_${userId}`;
                this.notesCache.set(cacheKey, {
                    data: this.notes[userId],
                    timestamp: Date.now()
                });
                
                // ç«‹å³æ¸²æŸ“æ–°ç•Œé¢
                this.renderNotesPanel(userId);
                
                // å…³é—­è¡¨å•
                this.closeNoteForm();
                
                this.showMessage('ç¬”è®°æ·»åŠ æˆåŠŸï¼', 'success');
                console.log('âœ… [Notes] åˆ›å»ºæ“ä½œå®Œæˆï¼Œç•Œé¢å·²æ›´æ–°');
            } else {
                throw new Error(response.message || 'åˆ›å»ºç¬”è®°å¤±è´¥');
            }
            
        } catch (error) {
            console.error('âŒ æ·»åŠ ç¬”è®°å¤±è´¥:', error);
            this.showMessage('æ·»åŠ ç¬”è®°å¤±è´¥: ' + error.message, 'error');
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = 'ä¿å­˜ç¬”è®°';
        }
    },


    // æ˜¾ç¤ºç¼–è¾‘ç¬”è®°å†…å®¹è¡¨å•ï¼ˆåªç¼–è¾‘æè¿°å’Œæ³¨æ„äº‹é¡¹ï¼‰
    async showEditNoteContentForm(noteId) {
        try {
            // è·å–ç¬”è®°è¯¦æƒ…
            const response = await ApiClient.notes.getById(noteId);
            if (!response.success) {
                throw new Error(response.message);
            }
            
            const note = response.data;
            const formHtml = `
                <div class="modal-overlay" id="editNoteContentModal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>ç¼–è¾‘ç¬”è®°å†…å®¹</h3>
                            <button class="modal-close" onclick="NotesManager.closeNoteContentForm()">Ã—</button>
                        </div>
                        <form class="note-form" onsubmit="NotesManager.handleEditNoteContent(event, ${noteId})">
                            <div class="form-group">
                                <label for="edit-content-description">è¯¦ç»†æè¿°</label>
                                <textarea id="edit-content-description" name="description" rows="4" 
                                          placeholder="è¯¦ç»†æè¿°æ‚¨çš„å¥åº·çŠ¶å†µ...">${Utils.escapeHtml(note.description || '')}</textarea>
                            </div>
                            <div class="form-group">
                                <label for="edit-content-precautions">æ³¨æ„äº‹é¡¹/åŒ»å˜±</label>
                                <textarea id="edit-content-precautions" name="precautions" rows="3" 
                                          placeholder="åŒ»ç”Ÿå»ºè®®ã€æ³¨æ„äº‹é¡¹ç­‰...">${Utils.escapeHtml(note.precautions || '')}</textarea>
                            </div>
                            <div class="form-actions">
                                <button type="button" onclick="NotesManager.closeNoteContentForm()">å–æ¶ˆ</button>
                                <button type="submit">ä¿å­˜ä¿®æ”¹</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', formHtml);
        } catch (error) {
            console.error('æ˜¾ç¤ºç¼–è¾‘å†…å®¹è¡¨å•å¤±è´¥:', error);
            this.showMessage('åŠ è½½ç¬”è®°æ•°æ®å¤±è´¥: ' + error.message, 'error');
        }
    },

    // å¤„ç†ç¼–è¾‘ç¬”è®°å†…å®¹
    async handleEditNoteContent(event, noteId) {
        event.preventDefault();
        
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        
        try {
            // é˜²æ­¢é‡å¤æäº¤
            submitButton.disabled = true;
            submitButton.textContent = 'ä¿å­˜ä¸­...';
            
            const formData = new FormData(form);
            const noteData = {
                description: formData.get('description').trim(),
                precautions: formData.get('precautions').trim()
                // æ³¨æ„ï¼šè¿™é‡Œä¸åŒ…æ‹¬ ai_suggestionsï¼Œä¿æŒä¸å˜
            };
            
            console.log('ğŸ”„ æ›´æ–°ç¬”è®°å†…å®¹:', noteId, noteData);
            const response = await ApiClient.notes.update(noteId, noteData);
            
            if (response.success) {
                console.log('âœ… [Notes] å†…å®¹æ›´æ–°æˆåŠŸ:', response.data);
                
                // ğŸ”¥ ä¿®å¤ï¼šæ›´æ–°æœ¬åœ°æ•°æ®å¹¶ç«‹å³æ¸²æŸ“
                const updatedNote = response.data;
                if (this.notes[this.currentUser]) {
                    const noteIndex = this.notes[this.currentUser].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[this.currentUser][noteIndex] = updatedNote;
                    }
                }
                
                // æ›´æ–°ç¼“å­˜
                const cacheKey = `notes_${this.currentUser}`;
                this.notesCache.set(cacheKey, {
                    data: this.notes[this.currentUser],
                    timestamp: Date.now()
                });
                
                // ç«‹å³æ¸²æŸ“æ–°ç•Œé¢
                this.renderNotesPanel(this.currentUser);
                
                // å…³é—­ç¼–è¾‘è¡¨å•
                this.closeNoteContentForm();
                
                // æ›´æ–°è¯¦æƒ…é¡µé¢å†…å®¹
                this.updateNoteDetailsContent(noteId, response.data);
                
                this.showMessage('ç¬”è®°å†…å®¹æ›´æ–°æˆåŠŸï¼', 'success');
                console.log('âœ… [Notes] å†…å®¹æ›´æ–°æ“ä½œå®Œæˆï¼Œç•Œé¢å·²æ›´æ–°');
            } else {
                throw new Error(response.message || 'æ›´æ–°ç¬”è®°å†…å®¹å¤±è´¥');
            }
            
        } catch (error) {
            console.error('âŒ æ›´æ–°ç¬”è®°å†…å®¹å¤±è´¥:', error);
            this.showMessage('æ›´æ–°ç¬”è®°å†…å®¹å¤±è´¥: ' + error.message, 'error');
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = 'ä¿å­˜ä¿®æ”¹';
        }
    },

    // å…³é—­ç¬”è®°å†…å®¹ç¼–è¾‘è¡¨å•
    closeNoteContentForm() {
        const modal = document.getElementById('editNoteContentModal');
        if (modal) {
            modal.remove();
        }
    },

    // æ›´æ–°è¯¦æƒ…é¡µé¢å†…å®¹ï¼ˆä¸åˆ·æ–°æ•´ä¸ªè¯¦æƒ…é¡µï¼Œåªæ›´æ–°å†…å®¹éƒ¨åˆ†ï¼‰
    updateNoteDetailsContent(noteId, updatedNote) {
        // æ›´æ–°è¯¦ç»†æè¿°
        const descriptionElement = document.querySelector('.detail-section:nth-child(1) p');
        if (descriptionElement) {
            descriptionElement.textContent = updatedNote.description || 'N/A';
        }
        
        // æ›´æ–°æ³¨æ„äº‹é¡¹
        const precautionsElement = document.querySelector('.detail-section:nth-child(2) p');
        if (precautionsElement) {
            precautionsElement.textContent = updatedNote.precautions || 'N/A';
        }
        
        console.log('âœ… è¯¦æƒ…é¡µé¢å†…å®¹å·²æ›´æ–°');
    },

    // å…³é—­ç¬”è®°è¡¨å•
    closeNoteForm() {
        const modal = document.getElementById('addNoteModal') || document.getElementById('editNoteModal');
        if (modal) {
            modal.remove();
        }
    },

    // æ˜¾ç¤ºç¬”è®°è¯¦æƒ…
    async showNoteDetails(noteId) {
        try {
            const response = await ApiClient.notes.getById(noteId);
            if (!response.success) {
                throw new Error(response.message);
            }
            
            const note = response.data;
            const detailsHtml = `
                <div class="modal-overlay" id="noteDetailsModal">
                    <div class="modal-content large">
                        <div class="modal-header">
                            <h3>${Utils.escapeHtml(note.title)}</h3>
                            <button class="modal-close" onclick="NotesManager.closeNoteDetails()">Ã—</button>
                        </div>
                        <div class="note-details">
                            <div class="detail-section">
                                <h4>è¯¦ç»†æè¿°</h4>
                                <p>${note.description ? Utils.escapeHtml(note.description) : 'N/A'}</p>
                            </div>
                            <div class="detail-section">
                                <h4>æ³¨æ„äº‹é¡¹/åŒ»å˜±</h4>
                                <p>${note.precautions ? Utils.escapeHtml(note.precautions) : 'N/A'}</p>
                            </div>
                            <div class="detail-section">
                                <h4>AIå»ºè®®</h4>
                                ${note.ai_suggestions ? `
                                    <div class="ai-suggestions-content">${this.formatAISuggestions(note.ai_suggestions)}</div>
                                ` : `
                                    <p class="no-suggestions">æš‚æ— AIå»ºè®®</p>
                                    <button class="generate-ai-btn" onclick="NotesManager.generateAISuggestions(${noteId})">
                                        è·å–AIå»ºè®®
                                    </button>
                                `}
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="NotesManager.showEditNoteContentForm(${noteId})" class="edit-content-btn">ç¼–è¾‘</button>
                            ${note.ai_suggestions ? `<button onclick="NotesManager.regenerateAISuggestions(${noteId})" class="regenerate-ai-btn">å†æ¬¡ç”ŸæˆAIå»ºè®®</button>` : ''}
                            <button onclick="NotesManager.shareNoteAsImage(${noteId})" class="share-note-btn">åˆ†äº«</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', detailsHtml);
        } catch (error) {
            console.error('æ˜¾ç¤ºç¬”è®°è¯¦æƒ…å¤±è´¥:', error);
            this.showMessage('åŠ è½½ç¬”è®°è¯¦æƒ…å¤±è´¥: ' + error.message, 'error');
        }
    },

    // å…³é—­ç¬”è®°è¯¦æƒ…
    closeNoteDetails() {
        const modal = document.getElementById('noteDetailsModal');
        if (modal) {
            modal.remove();
        }
    },

    // è®¾ç½®AIç”ŸæˆåŠ è½½çŠ¶æ€
    setAIGenerationLoadingState(isLoading) {
        const modal = document.querySelector('.modal-overlay');
        if (!modal) return;

        // è·å–æ‰€æœ‰éœ€è¦ç¦ç”¨çš„æŒ‰é’®
        const editButton = modal.querySelector('.edit-content-btn');
        const regenerateButton = modal.querySelector('.regenerate-ai-btn');
        const generateButton = modal.querySelector('.generate-ai-btn');
        const shareButton = modal.querySelector('.share-note-btn');

        const buttons = [editButton, regenerateButton, generateButton, shareButton].filter(btn => btn);

        if (isLoading) {
            // å¯ç”¨åŠ è½½çŠ¶æ€
            buttons.forEach(button => {
                if (button) {
                    button.disabled = true;
                    button.style.opacity = '0.6';
                    button.style.cursor = 'not-allowed';
                }
            });

            // æ·»åŠ åŠ è½½é®ç½©
            if (!modal.querySelector('.ai-loading-overlay')) {
                const loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'ai-loading-overlay';
                loadingOverlay.innerHTML = `
                    <div class="ai-loading-spinner">
                        <div class="spinner"></div>
                        <p>AIæ­£åœ¨ç”Ÿæˆå¥åº·å»ºè®®...</p>
                        <small>è¯·å‹¿å…³é—­çª—å£</small>
                    </div>
                `;
                modal.appendChild(loadingOverlay);
            }
        } else {
            // ç¦ç”¨åŠ è½½çŠ¶æ€
            buttons.forEach(button => {
                if (button) {
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                }
            });

            // ç§»é™¤åŠ è½½é®ç½©
            const loadingOverlay = modal.querySelector('.ai-loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.remove();
            }
        }
    },

    // å†æ¬¡ç”ŸæˆAIå»ºè®®
    async regenerateAISuggestions(noteId) {
        try {
            // è®¾ç½®åŠ è½½çŠ¶æ€
            this.setAIGenerationLoadingState(true);
            
            const regenerateButton = document.querySelector('.regenerate-ai-btn');
            if (regenerateButton) {
                regenerateButton.textContent = 'ç”ŸæˆAIå»ºè®®ä¸­...';
            }
            
            console.log('ğŸ”„ å†æ¬¡ç”ŸæˆAIå»ºè®®ï¼Œç¬”è®°ID:', noteId);
            
            // è°ƒç”¨åç«¯APIç”ŸæˆAIå»ºè®®ï¼Œä¼ é€’çœŸå®å¤©æ°”æ•°æ®ç»™Gemini
            console.log('ğŸš€ å†æ¬¡è°ƒç”¨APIï¼Œä¼ é€’çœŸå®å¤©æ°”æ•°æ®ç»™Gemini');
            const response = await ApiClient.notes.generateAISuggestions(noteId);
            
            if (response.success) {
                console.log('âœ… AIå»ºè®®å†æ¬¡ç”ŸæˆæˆåŠŸ:', response.data);
                
                // æ›´æ–°ç•Œé¢æ˜¾ç¤ºAIå»ºè®®
                const aiSuggestionsSection = document.querySelector('.detail-section:last-child .ai-suggestions-content');
                if (aiSuggestionsSection) {
                    // ç›´æ¥æ›´æ–°AIå»ºè®®å†…å®¹
                    aiSuggestionsSection.innerHTML = this.formatAISuggestions(response.data.ai_suggestions);
                }
                
                // æ›´æ–°æœ¬åœ°æ•°æ®
                Object.keys(this.notes).forEach(userId => {
                    const noteIndex = this.notes[userId].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[userId][noteIndex].ai_suggestions = response.data.ai_suggestions;
                    }
                });
                
                this.showMessage('AIå»ºè®®å†æ¬¡ç”ŸæˆæˆåŠŸï¼', 'success');
            } else {
                throw new Error(response.message || 'å†æ¬¡ç”ŸæˆAIå»ºè®®å¤±è´¥');
            }
            
        } catch (error) {
            console.error('âŒ å†æ¬¡ç”ŸæˆAIå»ºè®®å¤±è´¥:', error);
            this.showMessage('å†æ¬¡ç”ŸæˆAIå»ºè®®å¤±è´¥: ' + error.message, 'error');
        } finally {
            // æ¢å¤æ‰€æœ‰æŒ‰é’®çŠ¶æ€
            this.setAIGenerationLoadingState(false);
            
            const regenerateButton = document.querySelector('.regenerate-ai-btn');
            if (regenerateButton) {
                regenerateButton.textContent = 'å†æ¬¡ç”ŸæˆAIå»ºè®®';
            }
        }
    },

    // ç”ŸæˆAIå»ºè®®
    async generateAISuggestions(noteId) {
        try {
            // è®¾ç½®åŠ è½½çŠ¶æ€
            this.setAIGenerationLoadingState(true);
            
            const button = document.querySelector('.generate-ai-btn');
            if (button) {
                button.textContent = 'ç”Ÿæˆä¸­...';
            }
            
            console.log('ğŸ¤– å¼€å§‹ç”ŸæˆAIå»ºè®®ï¼Œç¬”è®°ID:', noteId);
            
            // è°ƒç”¨åç«¯APIç”ŸæˆAIå»ºè®®ï¼Œä¼ é€’çœŸå®å¤©æ°”æ•°æ®ç»™Gemini
            console.log('ğŸš€ è°ƒç”¨APIï¼Œä¼ é€’çœŸå®å¤©æ°”æ•°æ®ç»™Gemini');
            const response = await ApiClient.notes.generateAISuggestions(noteId);
            
            if (response.success) {
                console.log('âœ… AIå»ºè®®ç”ŸæˆæˆåŠŸ:', response.data);
                
                // æ›´æ–°ç•Œé¢æ˜¾ç¤ºAIå»ºè®®
                const aiSuggestionsSection = document.querySelector('.detail-section:last-child');
                if (aiSuggestionsSection) {
                    // æŸ¥æ‰¾AIå»ºè®®å®¹å™¨
                    const noSuggestionsElement = aiSuggestionsSection.querySelector('.no-suggestions');
                    const generateButton = aiSuggestionsSection.querySelector('.generate-ai-btn');
                    
                    if (noSuggestionsElement && generateButton) {
                        // æ›¿æ¢"æš‚æ— AIå»ºè®®"å’ŒæŒ‰é’®ä¸ºå®é™…å»ºè®®å†…å®¹
                        const aiContentHtml = `<div class="ai-suggestions-content">${this.formatAISuggestions(response.data.ai_suggestions)}</div>`;
                        noSuggestionsElement.outerHTML = aiContentHtml;
                        generateButton.remove();
                        
                        // åœ¨æ¨¡æ€æ¡†åº•éƒ¨æ·»åŠ "å†æ¬¡ç”ŸæˆAIå»ºè®®"æŒ‰é’®
                        const modalActions = document.querySelector('.modal-actions');
                        if (modalActions && !modalActions.querySelector('.regenerate-ai-btn')) {
                            // åœ¨åˆ†äº«æŒ‰é’®ä¹‹å‰æ’å…¥"å†æ¬¡ç”ŸæˆAIå»ºè®®"æŒ‰é’®
                            const shareButton = modalActions.querySelector('.share-note-btn');
                            const regenerateButton = document.createElement('button');
                            regenerateButton.className = 'regenerate-ai-btn';
                            regenerateButton.setAttribute('onclick', `NotesManager.regenerateAISuggestions(${noteId})`);
                            regenerateButton.textContent = 'å†æ¬¡ç”ŸæˆAIå»ºè®®';
                            
                            if (shareButton) {
                                modalActions.insertBefore(regenerateButton, shareButton);
                            } else {
                                modalActions.appendChild(regenerateButton);
                            }
                        }
                    }
                }
                
                // æ›´æ–°æœ¬åœ°æ•°æ®
                Object.keys(this.notes).forEach(userId => {
                    const noteIndex = this.notes[userId].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[userId][noteIndex].ai_suggestions = response.data.ai_suggestions;
                    }
                });
                
                this.showMessage('AIå»ºè®®ç”ŸæˆæˆåŠŸï¼', 'success');
            } else {
                throw new Error(response.message || 'ç”ŸæˆAIå»ºè®®å¤±è´¥');
            }
            
        } catch (error) {
            console.error('âŒ ç”ŸæˆAIå»ºè®®å¤±è´¥:', error);
            this.showMessage('ç”ŸæˆAIå»ºè®®å¤±è´¥: ' + error.message, 'error');
        } finally {
            // æ¢å¤æ‰€æœ‰æŒ‰é’®çŠ¶æ€
            this.setAIGenerationLoadingState(false);
            
            const button = document.querySelector('.generate-ai-btn');
            if (button) {
                button.textContent = 'è·å–AIå»ºè®®';
            }
        }
    },

    // åˆ é™¤ç¬”è®°
    async deleteNote(noteId) {
        
        const confirmed = await DialogUtils.showDeleteConfirm('è¿™æ¡å¥åº·ç¬”è®°');
        if (!confirmed) {
            return;
        }
        
        try {
            console.log('ğŸ—‘ï¸ [Notes] å¼€å§‹åˆ é™¤ç¬”è®°:', noteId);
            console.log('ğŸ” [Notes] åˆ é™¤è°ƒè¯•ä¿¡æ¯:');
            console.log('  - å½“å‰ç”¨æˆ·ID:', this.currentUser);
            console.log('  - å½“å‰Appç”¨æˆ·:', localStorage.getItem('wenting_current_app_user'));
            console.log('  - è¦åˆ é™¤çš„ç¬”è®°ID:', noteId);
            
            // æŸ¥æ‰¾è¿™ä¸ªç¬”è®°åœ¨å½“å‰ç”¨æˆ·æ•°æ®ä¸­çš„è¯¦æƒ…
            if (this.notes[this.currentUser]) {
                const noteToDelete = this.notes[this.currentUser].find(note => note.id === noteId);
                if (noteToDelete) {
                    console.log('  - ç¬”è®°è¯¦æƒ…:', {
                        id: noteToDelete.id,
                        title: noteToDelete.title,
                        description: noteToDelete.description?.substring(0, 50) + '...'
                    });
                } else {
                    console.warn('âš ï¸ [Notes] è­¦å‘Šï¼šè¦åˆ é™¤çš„ç¬”è®°ä¸åœ¨å½“å‰ç”¨æˆ·æ•°æ®ä¸­!');
                }
            }
            
            const response = await ApiClient.notes.delete(noteId);
            
            if (response.success) {
                console.log('âœ… [Notes] åç«¯åˆ é™¤æˆåŠŸï¼Œå¼€å§‹æ›´æ–°æœ¬åœ°æ•°æ®');
                
                // ğŸ”¥ ä¿®å¤ï¼šç›´æ¥ä»æœ¬åœ°æ•°æ®ä¸­åˆ é™¤ï¼Œç„¶åæ¸²æŸ“
                if (this.notes[this.currentUser]) {
                    const noteIndex = this.notes[this.currentUser].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[this.currentUser].splice(noteIndex, 1);
                        console.log(`âœ… [Notes] å·²ä»æœ¬åœ°æ•°æ®ä¸­åˆ é™¤ç¬”è®° ID: ${noteId}`);
                    }
                }
                
                // æ›´æ–°ç¼“å­˜
                const cacheKey = `notes_${this.currentUser}`;
                this.notesCache.set(cacheKey, {
                    data: this.notes[this.currentUser] || [],
                    timestamp: Date.now()
                });
                
                // ğŸ”¥ ä¿®å¤ï¼šæ£€æŸ¥åˆ é™¤åæ˜¯å¦éœ€è¦åˆ‡æ¢ç”¨æˆ·æ˜¾ç¤º
                const currentUserNotes = this.notes[this.currentUser] || [];
                console.log(`ğŸ” [Notes] åˆ é™¤åå½“å‰ç”¨æˆ·${this.currentUser}å‰©ä½™ç¬”è®°æ•°: ${currentUserNotes.length}`);
                
                if (currentUserNotes.length === 0) {
                    // å½“å‰ç”¨æˆ·æ²¡æœ‰ç¬”è®°äº†ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–ç”¨æˆ·æœ‰æ•°æ®
                    const usersWithNotes = Object.keys(this.notes).filter(userId => 
                        this.notes[userId] && this.notes[userId].length > 0
                    );
                    console.log(`ğŸ” [Notes] æœ‰ç¬”è®°çš„ç”¨æˆ·åˆ—è¡¨:`, usersWithNotes);
                    
                    if (usersWithNotes.length > 0) {
                        // åˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªæœ‰æ•°æ®çš„ç”¨æˆ·
                        const targetUserId = parseInt(usersWithNotes[0]);
                        console.log(`ğŸ”„ [Notes] å½“å‰ç”¨æˆ·æ— ç¬”è®°ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ç”¨æˆ·${targetUserId}`);
                        this.loadNotesForUser(targetUserId, true);
                    } else {
                        // æ‰€æœ‰ç”¨æˆ·éƒ½æ²¡æœ‰ç¬”è®°
                        console.log(`ğŸ“ [Notes] æ‰€æœ‰ç”¨æˆ·éƒ½æ²¡æœ‰ç¬”è®°ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€`);
                        this.renderNotesPanel(this.currentUser);
                    }
                } else {
                    // å½“å‰ç”¨æˆ·è¿˜æœ‰ç¬”è®°ï¼Œæ­£å¸¸æ¸²æŸ“
                    this.renderNotesPanel(this.currentUser);
                }
                
                this.showMessage('ç¬”è®°åˆ é™¤æˆåŠŸ', 'success');
                console.log('âœ… [Notes] åˆ é™¤æ“ä½œå®Œæˆï¼Œç•Œé¢å·²æ›´æ–°');
            } else {
                throw new Error(response.message);
            }
        } catch (error) {
            console.error('âŒ [Notes] åˆ é™¤ç¬”è®°å¤±è´¥:', error);
            this.showMessage('åˆ é™¤ç¬”è®°å¤±è´¥: ' + error.message, 'error');
        }
    },



    // æ˜¾ç¤ºç¦»çº¿é”™è¯¯
    showOfflineError() {
        const contentArea = Utils.$('#contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="offline-error">
                    <div class="error-icon">ğŸ”Œ</div>
                    <h2>æœåŠ¡å™¨è¿æ¥å¤±è´¥</h2>
                    <p>æ— æ³•è¿æ¥åˆ°åç«¯æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ï¼š</p>
                    <p>1. åç«¯æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ</p>
                    <p>2. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸</p>
                    <button class="retry-btn" onclick="location.reload()">é‡è¯•</button>
                </div>
            `;
        }
    },

    // æ˜¾ç¤ºæ¶ˆæ¯
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        
        document.body.appendChild(messageEl);
        
        // 3ç§’åè‡ªåŠ¨ç§»é™¤
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 3000);
    },

    // æ ¼å¼åŒ–AIå»ºè®®å†…å®¹
    formatAISuggestions(suggestions) {
        if (!suggestions) return '';
        
        // å°†markdownæ ¼å¼è½¬æ¢ä¸ºHTML
        let formatted = suggestions
            // å¤„ç†åŠ ç²—æ–‡æœ¬ **text** -> <strong>text</strong>
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            // å¤„ç†æ¢è¡Œ
            .replace(/\n/g, '<br>')
            // å¤„ç†ç©ºè¡Œ
            .replace(/<br><br>/g, '<br><br>');
        
        // ç‰¹åˆ«å¤„ç†ä»Šæ—¥å»ºè®®éƒ¨åˆ†
        if (formatted.includes('ğŸŒ… ä»Šæ—¥å»ºè®®')) {
            // æ‰¾åˆ°ä»Šæ—¥å»ºè®®çš„å¼€å§‹å’Œç»“æŸä½ç½®
            const todayStart = formatted.indexOf('<strong>ğŸŒ… ä»Šæ—¥å»ºè®®</strong>');
            const nextSectionStart = formatted.indexOf('<strong>ğŸ‘©â€âš•ï¸', todayStart);
            
            if (todayStart !== -1) {
                const todayEnd = nextSectionStart !== -1 ? nextSectionStart : formatted.length;
                const todayContent = formatted.substring(todayStart, todayEnd);
                const restContent = formatted.substring(todayEnd);
                const beforeContent = formatted.substring(0, todayStart);
                
                // ä¸ºä»Šæ—¥å»ºè®®æ·»åŠ ç‰¹æ®Šæ ·å¼
                const highlightedToday = `<div class="today-suggestion-highlight">${todayContent}</div>`;
                formatted = beforeContent + highlightedToday + restContent;
            }
        }
        
        return `<div style="white-space: normal; line-height: 1.6;">${formatted}</div>`;
    },

    // åˆ†äº«ç¬”è®°ä¸ºå›¾ç‰‡
    async shareNoteAsImage(noteId) {
        try {
            console.log('ğŸ“¸ å¼€å§‹åˆ†äº«ç¬”è®°ä¸ºå›¾ç‰‡ï¼ŒID:', noteId);
            this.setShareLoadingState(true);
            const modal = document.getElementById('noteDetailsModal');
            if (!modal) throw new Error('æ‰¾ä¸åˆ°ç¬”è®°è¯¦æƒ…é¡µé¢');
            this.setAIGenerationLoadingState(true);
            this.showShareLoadingOverlay(modal);
            await this.ensureHtml2Canvas();
            await new Promise(res => setTimeout(res, 250));
            const response = await ApiClient.notes.getById(noteId);
            const note = response.success ? response.data : null;

            // æ„å»ºä¸“ç”¨åˆ†äº«DOM
            const shareDiv = document.createElement('div');
            shareDiv.id = 'note-share-capture';
            shareDiv.style.cssText = `
                width: 600px; margin: 0 auto; background: #fafaf7; color: #222; font-family: 'Noto Sans SC', 'Segoe UI', Arial, sans-serif; border-radius: 12px; border: 1px solid #e1e1e1; box-shadow: 0 2px 8px #eee; padding: 36px 36px 70px 36px; position: relative; line-height: 1.7; letter-spacing: 0.01em;`
            ;
            // ç”µå­å¢¨æ°´é£æ ¼å†…å®¹
            shareDiv.innerHTML = `
                <div style="font-size: 2.1rem; font-weight: 700; text-align: center; margin-bottom: 18px; letter-spacing: 0.04em;">${Utils.escapeHtml(note.title)}</div>
                <div style="border-bottom:1.5px solid #e1e1e1; margin-bottom:18px;"></div>
                <div style="margin-bottom: 18px;"><span style="font-weight:600;">è¯¦ç»†æè¿°</span><div style="margin-top:6px; color:#222;">${note.description ? Utils.escapeHtml(note.description) : 'N/A'}</div></div>
                <div style="margin-bottom: 18px;"><span style="font-weight:600;">æ³¨æ„äº‹é¡¹/åŒ»å˜±</span><div style="margin-top:6px; color:#222;">${note.precautions ? Utils.escapeHtml(note.precautions) : 'N/A'}</div></div>
                <div style="margin-bottom: 18px;"><span style="font-weight:600;">AIå»ºè®®</span><div style="margin-top:6px; color:#222;">${note.ai_suggestions ? this.formatAISuggestions(note.ai_suggestions).replace(/<br>/g, '<br/>') : 'æš‚æ— AIå»ºè®®'}</div></div>
                <div style="position:absolute;left:0;right:0;bottom:18px;text-align:center;color:#888;font-size:15px;letter-spacing:0.04em;">
                    <span style="font-weight:700;">WENTING</span><br/>
                    Household Health Supervisor
                </div>
            `;
            document.body.appendChild(shareDiv);
            // æˆªå›¾
            const canvas = await html2canvas(shareDiv, {
                backgroundColor: '#fafaf7',
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                width: 600
            });
            // æ¸…ç†
            document.body.removeChild(shareDiv);
            this.hideShareLoadingOverlay();
            this.setAIGenerationLoadingState(false);
            this.setShareLoadingState(false);
            // ä¿å­˜
            const filename = `é›¯å©·å¥åº·æ¡£æ¡ˆ-${note ? note.title : 'note'}-${new Date().toISOString().split('T')[0]}.png`;
            await this.saveImageByDevice(canvas, filename);
        } catch (error) {
            console.error('âŒ åˆ†äº«ç¬”è®°å›¾ç‰‡å¤±è´¥:', error);
            this.showMessage('ç”Ÿæˆå›¾ç‰‡å¤±è´¥: ' + error.message, 'error');
        } finally {
            this.setShareLoadingState(false);
            this.setAIGenerationLoadingState(false);
            this.hideShareLoadingOverlay();
        }
    },

    // è®¾ç½®åˆ†äº«åŠ è½½çŠ¶æ€
    setShareLoadingState(isLoading) {
        const shareButton = document.querySelector('.share-note-btn');
        if (!shareButton) return;

        if (isLoading) {
            shareButton.disabled = true;
            shareButton.textContent = 'ç”Ÿæˆä¸­...';
            shareButton.style.opacity = '0.6';
        } else {
            shareButton.disabled = false;
            shareButton.textContent = 'åˆ†äº«';
            shareButton.style.opacity = '1';
        }
    },

    // ç¡®ä¿html2canvasåº“å·²åŠ è½½
    async ensureHtml2Canvas() {
        if (typeof html2canvas !== 'undefined') {
            return Promise.resolve();
        }

        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
            script.onload = () => {
                console.log('âœ… html2canvasåº“åŠ è½½æˆåŠŸ');
                resolve();
            };
            script.onerror = () => {
                console.error('âŒ html2canvasåº“åŠ è½½å¤±è´¥');
                reject(new Error('æ— æ³•åŠ è½½å›¾ç‰‡ç”Ÿæˆåº“ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'));
            };
            document.head.appendChild(script);
        });
    },

    // æ£€æµ‹è®¾å¤‡ç±»å‹
    detectDeviceType() {
        const userAgent = navigator.userAgent.toLowerCase();
        const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile/.test(userAgent);
        const isIOS = /ipad|iphone|ipod/.test(userAgent);
        const isAndroid = /android/.test(userAgent);
        
        return {
            isMobile,
            isIOS,
            isAndroid,
            isDesktop: !isMobile
        };
    },

    // æ ¹æ®è®¾å¤‡ç±»å‹ä¿å­˜å›¾ç‰‡
    async saveImageByDevice(canvas, filename) {
        const device = this.detectDeviceType();
        const dataUrl = canvas.toDataURL('image/png', 1.0);
        
        try {
            if (device.isMobile) {
                // ç§»åŠ¨è®¾å¤‡ï¼šå°è¯•ä¿å­˜åˆ°ç›¸å†Œ
                await this.saveToGallery(dataUrl, filename, device);
            } else {
                // æ¡Œé¢è®¾å¤‡ï¼šä¸‹è½½åˆ°æ¡Œé¢/ä¸‹è½½æ–‡ä»¶å¤¹
                this.downloadToDesktop(dataUrl, filename);
            }
        } catch (error) {
            console.error('âŒ ä¿å­˜å›¾ç‰‡å¤±è´¥:', error);
            // é™çº§å¤„ç†ï¼šç›´æ¥ä¸‹è½½
            this.downloadToDesktop(dataUrl, filename);
        }
    },

    // ä¿å­˜åˆ°ç§»åŠ¨è®¾å¤‡ç›¸å†Œ
    async saveToGallery(dataUrl, filename, device) {
        try {
            // å°è¯•ä½¿ç”¨ Web Share API (ç°ä»£æµè§ˆå™¨æ”¯æŒ)
            if (navigator.share && navigator.canShare) {
                const blob = this.dataUrlToBlob(dataUrl);
                const file = new File([blob], filename, { type: 'image/png' });
                
                if (navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'é›¯å©·å¥åº·æ¡£æ¡ˆ',
                        text: 'åˆ†äº«æˆ‘çš„å¥åº·æ¡£æ¡ˆ'
                    });
                    this.showSuccessMessage('âœ… å¥åº·æ¡£æ¡ˆå·²æˆåŠŸåˆ†äº«ï¼', 'å›¾ç‰‡å·²é€šè¿‡ç³»ç»Ÿåˆ†äº«ä¿å­˜åˆ°è®¾å¤‡');
                    return;
                }
            }

            // é™çº§æ–¹æ¡ˆ1ï¼šåˆ›å»ºä¸‹è½½é“¾æ¥ï¼ˆä¼šä¿å­˜åˆ°ä¸‹è½½æ–‡ä»¶å¤¹ï¼‰
            if (device.isAndroid || device.isIOS) {
                this.downloadToDesktop(dataUrl, filename);
                
                if (device.isIOS) {
                    this.showSuccessMessage('ğŸ“± å›¾ç‰‡å·²ä¿å­˜æˆåŠŸï¼', 'iPhoneç”¨æˆ·ï¼šå›¾ç‰‡åœ¨ä¸‹è½½æ–‡ä»¶å¤¹ä¸­ï¼Œé•¿æŒ‰é€‰æ‹©"å­˜å‚¨åˆ°ç›¸å†Œ"å³å¯ä¿å­˜åˆ°ç›¸å†Œ');
                } else {
                    this.showSuccessMessage('ğŸ“± å›¾ç‰‡å·²ä¿å­˜åˆ°ç›¸å†Œï¼', 'Androidç”¨æˆ·ï¼šå›¾ç‰‡å·²ä¿å­˜åˆ°ä¸‹è½½æ–‡ä»¶å¤¹ï¼Œå¯åœ¨ç›¸å†Œä¸­æŸ¥çœ‹');
                }
                return;
            }

            // é™çº§æ–¹æ¡ˆ2ï¼šç›´æ¥ä¸‹è½½
            this.downloadToDesktop(dataUrl, filename);
            this.showSuccessMessage('ğŸ“± å›¾ç‰‡å·²ä¸‹è½½æˆåŠŸï¼', 'è¯·æ‰‹åŠ¨å°†å›¾ç‰‡ä¿å­˜åˆ°ç›¸å†Œ');
            
        } catch (error) {
            console.error('âŒ ä¿å­˜åˆ°ç›¸å†Œå¤±è´¥:', error);
            throw error;
        }
    },

    // ä¸‹è½½åˆ°æ¡Œé¢/ä¸‹è½½æ–‡ä»¶å¤¹
    downloadToDesktop(dataUrl, filename) {
        try {
            const link = document.createElement('a');
            link.download = filename;
            link.href = dataUrl;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('âœ… å›¾ç‰‡ä¸‹è½½æˆåŠŸ:', filename);
            
            const device = this.detectDeviceType();
            if (device.isDesktop) {
                this.showSuccessMessage('ğŸ’» å¥åº·æ¡£æ¡ˆå·²ä¿å­˜æˆåŠŸï¼', 'å›¾ç‰‡å·²ä¿å­˜åˆ°ç”µè„‘çš„ä¸‹è½½æ–‡ä»¶å¤¹ä¸­');
            } else {
                this.showSuccessMessage('ğŸ“± å›¾ç‰‡å·²ä¸‹è½½å®Œæˆï¼', 'è¯·åœ¨ä¸‹è½½æ–‡ä»¶å¤¹ä¸­æŸ¥çœ‹');
            }
            
        } catch (error) {
            console.error('âŒ å›¾ç‰‡ä¸‹è½½å¤±è´¥:', error);
            throw error;
        }
    },

    // å°† Data URL è½¬æ¢ä¸º Blob
    dataUrlToBlob(dataUrl) {
        const arr = dataUrl.split(',');
        const mime = arr[0].match(/:(.*?);/)[1];
        const bstr = atob(arr[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        
        return new Blob([u8arr], { type: mime });
    },

    // æ˜¾ç¤ºåˆ†äº«åŠ è½½é®ç½©
    showShareLoadingOverlay(modal) {
        // å¦‚æœå·²ç»å­˜åœ¨é®ç½©ï¼Œå…ˆç§»é™¤
        this.hideShareLoadingOverlay();
        
        // å¤ç”¨AIç”Ÿæˆçš„åŠ è½½é®ç½©æ ·å¼
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'ai-loading-overlay share-loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="ai-loading-spinner">
                <div class="spinner"></div>
                <p>æ­£åœ¨ç”Ÿæˆå¥åº·æ¡£æ¡ˆå›¾ç‰‡...</p>
                <small>è¯·ç¨å€™ï¼Œæ­£åœ¨å¤„ç†ä¸­</small>
            </div>
        `;
        modal.appendChild(loadingOverlay);
    },

    // éšè—åˆ†äº«åŠ è½½é®ç½©
    hideShareLoadingOverlay() {
        const loadingOverlay = document.querySelector('.share-loading-overlay');
        if (loadingOverlay) {
            loadingOverlay.remove();
        }
    },

    // ç»‘å®šäº‹ä»¶
    bindEvents() {
        // ç”¨æˆ·æ ‡ç­¾ç‚¹å‡»äº‹ä»¶åœ¨TodoManagerä¸­å·²å¤„ç†ï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤ç»‘å®š
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.NotesManager = NotesManager;


// ç”¨æˆ·ç®¡ç†æ¨¡å—
const UserManager = {
    users: [],
    isOnline: false,

    async init() {
        // ç¡®ä¿ ApiClient å·²åŠ è½½
        if (typeof ApiClient === 'undefined') {
            console.error('âŒ ApiClient æœªå®šä¹‰ï¼Œè¯·æ£€æŸ¥è„šæœ¬åŠ è½½é¡ºåº');
            return;
        }
        
        // æ£€æŸ¥åç«¯è¿æ¥ - å¿…é¡»è”ç½‘æ‰èƒ½ä½¿ç”¨
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.error('âŒ æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œåº”ç”¨æ— æ³•å¯åŠ¨');
            return;
        }
        
        await this.loadUsersFromAPI();
        this.bindEvents();
        this.renderUserTabs();
    },

    // ä»APIåŠ è½½ç”¨æˆ·æ•°æ®
    async loadUsersFromAPI() {
        try {
            const response = await ApiClient.users.getAll();
            if (response.success) {
                this.users = response.data;
                console.log('âœ… ä»æœåŠ¡å™¨åŠ è½½ç”¨æˆ·æ•°æ®æˆåŠŸï¼Œç”¨æˆ·æ•°é‡:', this.users.length);
                
                // æ•°æ®åº“ä¸ºç©ºï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æ·»åŠ ç”¨æˆ·
                if (this.users.length === 0) {
                    console.log('ğŸ“ æ•°æ®åº“ä¸­æ²¡æœ‰ç”¨æˆ·ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æ·»åŠ ');
                }
            }
        } catch (error) {
            console.error('ä»æœåŠ¡å™¨åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
            throw error; // ä¸é™çº§åˆ°æœ¬åœ°æ•°æ®ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯
        }
    },

    // åˆ›å»ºé»˜è®¤ç”¨æˆ·ï¼ˆå·²åºŸå¼ƒ - ç”¨æˆ·éœ€è¦æ‰‹åŠ¨æ·»åŠ ï¼‰
    async createDefaultUsers() {
        console.log('âš ï¸ createDefaultUsersæ–¹æ³•å·²åºŸå¼ƒï¼Œè¯·æ‰‹åŠ¨æ·»åŠ ç”¨æˆ·');
        // ä¸å†è‡ªåŠ¨åˆ›å»ºä»»ä½•é»˜è®¤ç”¨æˆ·
        return;
    },



    // åŒæ­¥ç”¨æˆ·æ•°æ®åˆ°æœåŠ¡å™¨
    async syncUserToServer(user) {
        if (!this.isOnline) return false;
        
        try {
            let response;
            if (user.id && user.id > 0) {
                // æ›´æ–°ç°æœ‰ç”¨æˆ·
                response = await ApiClient.users.update(user.id, user);
            } else {
                // åˆ›å»ºæ–°ç”¨æˆ·
                response = await ApiClient.users.create(user);
            }
            
            if (response.success) {
                console.log('âœ… ç”¨æˆ·æ•°æ®åŒæ­¥åˆ°æœåŠ¡å™¨æˆåŠŸ');
                return response.data;
            }
        } catch (error) {
            console.error('åŒæ­¥ç”¨æˆ·æ•°æ®åˆ°æœåŠ¡å™¨å¤±è´¥:', error);
        }
        return false;
    },

    // æ·»åŠ æ–°ç”¨æˆ·
    async addUser() {
        // æ·»åŠ ç‚¹å‡»åé¦ˆåŠ¨ç”»
        const btn = event.target;
        btn.style.transform = 'scale(0.9)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        // æ˜¾ç¤ºæ·»åŠ ç”¨æˆ·è¡¨å•
        this.showAddUserForm();
    },

    // æ˜¾ç¤ºæ·»åŠ ç”¨æˆ·è¡¨å•
    showAddUserForm() {
        const formHtml = `
            <div class="modal-overlay" id="addUserModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>æ·»åŠ æ–°ç”¨æˆ·</h3>
                        <button class="modal-close" data-action="close-add-user-form">Ã—</button>
                    </div>
                    <form class="user-form" id="addUserForm">
                        <div class="form-group">
                            <label for="username">ç”¨æˆ·å *</label>
                            <input type="text" id="username" name="username" required maxlength="50">
                        </div>
                        <div class="form-group">
                            <label for="display_name">æ˜¾ç¤ºåç§° *</label>
                            <input type="text" id="display_name" name="display_name" required maxlength="100">
                        </div>
                        <div class="form-group">
                            <label for="email">é‚®ç®±</label>
                            <input type="email" id="email" name="email" maxlength="100">
                        </div>
                        <div class="form-group">
                            <label for="phone">æ‰‹æœºå·</label>
                            <input type="tel" id="phone" name="phone" pattern="1[3-9]\\d{9}" maxlength="11">
                        </div>
                        <div class="form-group">
                            <label for="gender">æ€§åˆ«</label>
                            <select id="gender" name="gender">
                                <option value="">è¯·é€‰æ‹©</option>
                                <option value="male">ç”·</option>
                                <option value="female">å¥³</option>
                                <option value="other">å…¶ä»–</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="birthday">ç”Ÿæ—¥</label>
                            <input type="date" id="birthday" name="birthday">
                        </div>
                        <div class="form-group">
                            <label for="avatar_color">å¤´åƒé¢œè‰²</label>
                            <input type="color" id="avatar_color" name="avatar_color" value="#1d9bf0">
                        </div>
                        <div class="form-actions">
                            <button type="button" data-action="close-add-user-form">å–æ¶ˆ</button>
                            <button type="submit">æ·»åŠ ç”¨æˆ·</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
        
        // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
        const modal = document.getElementById('addUserModal');
        if (modal) {
            // å…³é—­æŒ‰é’®äº‹ä»¶
            modal.addEventListener('click', (e) => {
                if (e.target.dataset.action === 'close-add-user-form' || e.target.classList.contains('modal-overlay')) {
                    this.closeAddUserForm();
                }
            });
            
            // è¡¨å•æäº¤äº‹ä»¶
            const form = modal.querySelector('#addUserForm');
            if (form) {
                form.addEventListener('submit', (e) => this.handleAddUser(e));
            }
        }
    },

    // å…³é—­æ·»åŠ ç”¨æˆ·è¡¨å•
    closeAddUserForm() {
        const modal = document.getElementById('addUserModal');
        if (modal) {
            modal.remove();
        }
    },

    // å¤„ç†æ·»åŠ ç”¨æˆ·è¡¨å•æäº¤
    async handleAddUser(event) {
        event.preventDefault();
        
        const submitButton = this._handleFormSubmission(event);
        if (!submitButton) return;
        
        const userData = this._extractUserData(event.target);
        this._logUserData(userData);

        try {
            const newUser = await this._createUserOnServer(userData);
            await this._handleUserCreationSuccess(newUser);
        } catch (error) {
            this._handleUserCreationError(error);
        } finally {
            this._restoreSubmitButton(submitButton);
        }
    },

    // å¤„ç†è¡¨å•æäº¤çŠ¶æ€
    _handleFormSubmission(event) {
        const submitButton = event.target.querySelector('button[type="submit"]');
        if (submitButton.disabled) {
            console.log('âš ï¸ è¡¨å•æ­£åœ¨æäº¤ä¸­ï¼Œå¿½ç•¥é‡å¤æäº¤');
            return null;
        }
        
        submitButton.disabled = true;
        submitButton.textContent = 'æäº¤ä¸­...';
        return submitButton;
    },

    // æå–ç”¨æˆ·æ•°æ®
    _extractUserData(form) {
        const formData = new FormData(form);
        return {
            username: formData.get('username'),
            display_name: formData.get('display_name'),
            email: formData.get('email') || null,
            phone: formData.get('phone') || null,
            gender: formData.get('gender') || null,
            birthday: formData.get('birthday') || null,
            avatar_color: formData.get('avatar_color') || '#1d9bf0'
        };
    },

    // è®°å½•ç”¨æˆ·æ•°æ®
    _logUserData(userData) {
        console.log('ğŸ“¤ å‡†å¤‡åˆ›å»ºç”¨æˆ·:', userData);
        console.log('ğŸ“‹ ç”¨æˆ·æ•°æ®è¯¦æƒ…:');
        Object.keys(userData).forEach(key => {
            console.log(`  ${key}: "${userData[key]}" (ç±»å‹: ${typeof userData[key]}, é•¿åº¦: ${userData[key]?.length || 'N/A'})`);
        });
    },

    // åœ¨æœåŠ¡å™¨åˆ›å»ºç”¨æˆ·
    async _createUserOnServer(userData) {
        console.log('ğŸ”„ æ­£åœ¨è°ƒç”¨APIåˆ›å»ºç”¨æˆ·...');
        const response = await ApiClient.users.create(userData);
        console.log('ğŸ“¥ APIå“åº”:', response);
        
        if (response && response.success) {
            console.log('âœ… åœ¨æœåŠ¡å™¨åˆ›å»ºç”¨æˆ·æˆåŠŸ:', response.data);
            return response.data;
        } else {
            console.error('âŒ APIè¿”å›å¤±è´¥å“åº”:', response);
            throw new Error(response?.message || 'åˆ›å»ºç”¨æˆ·å¤±è´¥');
        }
    },

    // å¤„ç†ç”¨æˆ·åˆ›å»ºæˆåŠŸ
    async _handleUserCreationSuccess(newUser) {
        this._addUserToLocalList(newUser);
        this._switchToNewUser(newUser);
        this._updateUserInterface();
        await this._loadNewUserTodos(newUser);
    },

    // æ·»åŠ ç”¨æˆ·åˆ°æœ¬åœ°åˆ—è¡¨
    _addUserToLocalList(newUser) {
        this.users.push(newUser);
        console.log('ğŸ“ å·²æ·»åŠ åˆ°æœ¬åœ°ç”¨æˆ·åˆ—è¡¨ï¼Œå½“å‰ç”¨æˆ·æ•°:', this.users.length);
    },

    // åˆ‡æ¢åˆ°æ–°ç”¨æˆ·
    _switchToNewUser(newUser) {
        if (window.TodoManager) {
            window.TodoManager.currentUser = newUser.id;
            console.log('ğŸ¯ å·²åˆ‡æ¢TodoManageråˆ°æ–°ç”¨æˆ·:', newUser.id, newUser.username);
        }
        
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentUser(newUser.id);
            console.log('ğŸ¯ å·²åŒæ­¥GlobalUserStateåˆ°æ–°ç”¨æˆ·:', newUser.id, newUser.username);
        }
    },

    // æ›´æ–°ç”¨æˆ·ç•Œé¢
    _updateUserInterface() {
        this.renderUserTabs();
        console.log('ğŸ¨ å·²é‡æ–°æ¸²æŸ“ç”¨æˆ·æ ‡ç­¾');
        
        this.closeAddUserForm();
        this.showMessage('ç”¨æˆ·æ·»åŠ æˆåŠŸï¼', 'success');
    },

    // ä¸ºæ–°ç”¨æˆ·åŠ è½½TODOåˆ—è¡¨
    async _loadNewUserTodos(newUser) {
        if (window.TodoManager && typeof window.TodoManager.loadTodosFromAPI === 'function') {
            try {
                window.TodoManager.todos[newUser.id] = [];
                await window.TodoManager.loadTodosFromAPI();
                window.TodoManager.renderTodoPanel(newUser.id);
                console.log('âœ… å·²åŠ è½½å¹¶æ˜¾ç¤ºæ–°ç”¨æˆ·çš„TODOåˆ—è¡¨');
            } catch (todoError) {
                console.warn('é‡æ–°åŠ è½½TODOæ•°æ®å¤±è´¥:', todoError);
                window.TodoManager.renderTodoPanel(newUser.id);
            }
        }
    },

    // å¤„ç†ç”¨æˆ·åˆ›å»ºé”™è¯¯
    _handleUserCreationError(error) {
        console.error('âŒ æ·»åŠ ç”¨æˆ·å¤±è´¥:', error);
        console.error('é”™è¯¯è¯¦æƒ…:', {
            message: error.message,
            stack: error.stack,
            response: error.response
        });
        
        const errorMessage = this._getErrorMessage(error);
        this.showMessage(errorMessage, 'error');
    },

    // è·å–é”™è¯¯æ¶ˆæ¯
    _getErrorMessage(error) {
        if (error.message.includes('fetch') || error.message.includes('NetworkError')) {
            return 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€';
        } else {
            return 'æ·»åŠ ç”¨æˆ·å¤±è´¥: ' + error.message;
        }
    },

    // æ¢å¤æäº¤æŒ‰é’®çŠ¶æ€
    _restoreSubmitButton(submitButton) {
        if (submitButton) {
            submitButton.disabled = false;
            submitButton.textContent = 'æ·»åŠ ç”¨æˆ·';
        }
    },

    // åˆ é™¤ç”¨æˆ·
    async removeUser(userId) {
        
        const confirmed = await DialogUtils.showConfirm(
            'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç”¨æˆ·å—ï¼Ÿè¿™å°†åˆ é™¤è¯¥ç”¨æˆ·çš„æ‰€æœ‰TODOæ•°æ®ã€‚',
            'ç¡®è®¤åˆ é™¤ç”¨æˆ·',
            {
                confirmText: 'åˆ é™¤',
                cancelText: 'å–æ¶ˆ',
                type: 'danger'
            }
        );
        if (!confirmed) {
            return;
        }

        try {
            // ä»æœåŠ¡å™¨åˆ é™¤
            const response = await ApiClient.users.delete(userId);
            if (!response.success) {
                throw new Error(response.message || 'åˆ é™¤ç”¨æˆ·å¤±è´¥');
            }
            console.log('âœ… ä»æœåŠ¡å™¨åˆ é™¤ç”¨æˆ·æˆåŠŸ');

            // ä»æœ¬åœ°åˆ é™¤
            const index = this.users.findIndex(user => user.id === userId);
            if (index > -1) {
                this.users.splice(index, 1);
                
                // æ¸…ç†å¯¹åº”çš„TODOæ•°æ®
                if (TodoManager.todos && TodoManager.todos[userId]) {
                    delete TodoManager.todos[userId];
                }
                
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ç”¨æˆ·ï¼Œåˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªç”¨æˆ·
                if (TodoManager.currentUser === userId && this.users.length > 0) {
                    TodoManager.switchUser(this.users[0].id);
                }
                
                this.renderUserTabs();
                this.showMessage('ç”¨æˆ·åˆ é™¤æˆåŠŸï¼', 'success');
            }
        } catch (error) {
            console.error('åˆ é™¤ç”¨æˆ·å¤±è´¥:', error);
            this.showMessage('åˆ é™¤ç”¨æˆ·å¤±è´¥: ' + error.message, 'error');
        }
    },

    // æ¸²æŸ“ç”¨æˆ·æ ‡ç­¾
    renderUserTabs() {
        const sidebar = Utils.$('.left-sidebar');
        if (!sidebar) return;

        // æŒ‰IDæ’åºï¼Œç¡®ä¿ç”¨æˆ·æŒ‰åˆ›å»ºé¡ºåºæ˜¾ç¤ºï¼ˆIDè¶Šå°è¶Šé å‰ï¼‰
        const sortedUsers = [...this.users].sort((a, b) => a.id - b.id);
        console.log('ğŸ“‹ ç”¨æˆ·æ’åº:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));

        // è·å–å½“å‰é€‰ä¸­çš„ç”¨æˆ·ID
        const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : (TodoManager.currentUser || null);
        console.log('ğŸ¯ renderUserTabs - å½“å‰ç”¨æˆ·ID:', currentUserId);
        
        const tabsHtml = sortedUsers.map(user => {
            const isActive = parseInt(user.id) === parseInt(currentUserId);
            const userColor = user.avatar_color || '#1d9bf0';
            console.log(`ğŸ·ï¸ ç”¨æˆ·${user.id}(${user.username}) - æ˜¯å¦é€‰ä¸­:`, isActive);
            
            return `
                <div class="sidebar-tab ${isActive ? 'active' : ''}" 
                     data-tab="${user.id}"
                     style="--user-color: ${userColor};">
                    ${user.display_name || user.username}
                </div>
            `;
        }).join('');

        const addButtonHtml = `
            <div class="add-user-btn" data-action="add-user" title="æ·»åŠ æ–°ç”¨æˆ·">
                +
            </div>
        `;

        sidebar.innerHTML = tabsHtml + addButtonHtml;
        
        // é‡æ–°ç»‘å®šå…¨å±€ç”¨æˆ·é€‰æ‹©å™¨äº‹ä»¶
        if (window.GlobalUserState) {
            GlobalUserState.bindUserSelectorEvents();
        }
        
        // è§¦å‘ç”¨æˆ·æ ‡ç­¾æ¸²æŸ“å®Œæˆäº‹ä»¶ï¼Œé€šçŸ¥å…¶ä»–é¡µé¢
        const userTabsRenderedEvent = new CustomEvent('userTabsRendered', {
            detail: {
                users: sortedUsers,
                currentUserId: currentUserId
            }
        });
        document.dispatchEvent(userTabsRenderedEvent);
        console.log('ğŸ“¢ è§¦å‘userTabsRenderedäº‹ä»¶ï¼Œç”¨æˆ·æ•°:', sortedUsers.length, 'å½“å‰ç”¨æˆ·:', currentUserId);
        
        // å¦‚æœæœ‰å½“å‰ç”¨æˆ·ï¼Œä¹Ÿè§¦å‘userSelectedäº‹ä»¶
        if (currentUserId) {
            const currentUser = sortedUsers.find(user => user.id === currentUserId);
            if (currentUser) {
                console.log('ğŸ“¢ åŒæ—¶è§¦å‘userSelectedäº‹ä»¶ï¼Œç”¨æˆ·:', currentUser.username);
                const userSelectedEvent = new CustomEvent('userSelected', {
                    detail: currentUser
                });
                document.dispatchEvent(userSelectedEvent);
            }
        }
    },

    // è·å–ç”¨æˆ·ä¿¡æ¯
    getUser(userId) {
        return this.users.find(user => user.id === userId);
    },

    // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    async updateUser(userId, updates) {
        try {
            // åœ¨æœåŠ¡å™¨æ›´æ–°ç”¨æˆ·
            const response = await ApiClient.users.update(userId, updates);
            if (response.success) {
                const updatedUser = response.data;
                console.log('âœ… åœ¨æœåŠ¡å™¨æ›´æ–°ç”¨æˆ·æˆåŠŸ');
                
                // æ›´æ–°æœ¬åœ°ç”¨æˆ·æ•°æ®
                const user = this.getUser(userId);
                if (user) {
                    Object.assign(user, updatedUser);
                    this.renderUserTabs();
                    return true;
                }
            } else {
                throw new Error(response.message || 'æ›´æ–°ç”¨æˆ·å¤±è´¥');
            }
        } catch (error) {
            console.error('æ›´æ–°ç”¨æˆ·å¤±è´¥:', error);
            this.showMessage('æ›´æ–°ç”¨æˆ·å¤±è´¥: ' + error.message, 'error');
        }
        return false;
    },

    // æ˜¾ç¤ºæ¶ˆæ¯
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        `;
        
        switch (type) {
            case 'success':
                messageEl.style.backgroundColor = '#4CAF50';
                break;
            case 'error':
                messageEl.style.backgroundColor = '#f44336';
                break;
            case 'warning':
                messageEl.style.backgroundColor = '#ff9800';
                break;
            default:
                messageEl.style.backgroundColor = '#2196F3';
        }
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 3000);
    },

    // ç»‘å®šäº‹ä»¶
    bindEvents() {
        // äº‹ä»¶å§”æ‰˜ï¼šå¤„ç†åŠ¨æ€ç”Ÿæˆçš„æ·»åŠ ç”¨æˆ·æŒ‰é’®
        document.addEventListener('click', (e) => {
            if (e.target.dataset.action === 'add-user' || e.target.closest('[data-action="add-user"]')) {
                e.preventDefault();
                this.addUser();
            }
        });
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.UserManager = UserManager;




// Profileç®¡ç†å™¨
const ProfileManager = {
    currentAppUser: null,
    profileData: null,
    isOnline: false,

    async init() {
        console.log('ğŸ‘¤ åˆå§‹åŒ–Profileç®¡ç†å™¨...');
        
        // ç¡®ä¿ ApiClient å·²åŠ è½½
        if (typeof ApiClient === 'undefined') {
            console.error('âŒ ApiClient æœªå®šä¹‰ï¼Œè¯·æ£€æŸ¥è„šæœ¬åŠ è½½é¡ºåº');
            return;
        }
        
        // æ£€æŸ¥åç«¯è¿æ¥
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.error('âŒ æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨');
            return;
        }
        
        // è·å–å½“å‰ç™»å½•ç”¨æˆ·
        this.currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        
        if (!this.currentAppUser) {
            console.error('âŒ ç”¨æˆ·æœªç™»å½•');
            return;
        }
        
        console.log('âœ… Profileç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œå½“å‰ç”¨æˆ·:', this.currentAppUser);
    },

    // åŠ è½½ç”¨æˆ·èµ„æ–™æ•°æ®
    async loadProfileData() {
        try {
            console.log('ğŸ“¡ æ­£åœ¨åŠ è½½ç”¨æˆ·èµ„æ–™...');
            const response = await ApiClient.auth.getProfile(this.currentAppUser);
            
            if (response.success) {
                this.profileData = response.data;
                console.log('âœ… ç”¨æˆ·èµ„æ–™åŠ è½½æˆåŠŸ:', this.profileData);
                return this.profileData;
            } else {
                throw new Error(response.message || 'åŠ è½½ç”¨æˆ·èµ„æ–™å¤±è´¥');
            }
        } catch (error) {
            console.error('âŒ åŠ è½½ç”¨æˆ·èµ„æ–™å¤±è´¥:', error);
            throw error;
        }
    },

    // æ¸²æŸ“Profileé¡µé¢
    async renderProfilePanel() {
        console.log('ğŸ¨ å¼€å§‹æ¸²æŸ“Profileé¡µé¢');
        
        const contentArea = document.getElementById('contentArea');
        if (!contentArea) {
            console.error('âŒ æ‰¾ä¸åˆ°å†…å®¹åŒºåŸŸ');
            return;
        }

        // éšè—å·¦ä¾§è¾¹æ 
        this.hideLeftSidebar();

        try {
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            contentArea.innerHTML = `
                <div class="profile-content-panel">
                    <div class="profile-loading">
                        <div class="loading-spinner"></div>
                        <p>æ­£åœ¨åŠ è½½ç”¨æˆ·èµ„æ–™...</p>
                    </div>
                </div>
            `;

            // åŠ è½½ç”¨æˆ·æ•°æ®
            await this.loadProfileData();

            // æ¸²æŸ“Profileå†…å®¹
            const profileHtml = this.generateProfileHTML();
            contentArea.innerHTML = profileHtml;

            // ç»‘å®šäº‹ä»¶
            this.bindProfileEvents();

            console.log('âœ… Profileé¡µé¢æ¸²æŸ“å®Œæˆ');
        } catch (error) {
            console.error('âŒ æ¸²æŸ“Profileé¡µé¢å¤±è´¥:', error);
            
            // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
            contentArea.innerHTML = `
                <div class="profile-content-panel">
                    <div class="profile-error">
                        <div class="error-icon">âŒ</div>
                        <h3>åŠ è½½å¤±è´¥</h3>
                        <p>${error.message}</p>
                        <button class="btn btn-primary" onclick="ProfileManager.renderProfilePanel()">é‡è¯•</button>
                    </div>
                </div>
            `;
        }
    },

    // éšè—å·¦ä¾§è¾¹æ 
    hideLeftSidebar() {
        const leftSidebar = document.querySelector('.left-sidebar');
        const contentArea = document.querySelector('.content-area');
        
        if (leftSidebar) {
            leftSidebar.style.display = 'none';
        }
        
        if (contentArea) {
            contentArea.style.width = '100%';
            contentArea.style.marginLeft = '0';
        }
        
        console.log('ğŸ¨ å·²éšè—å·¦ä¾§è¾¹æ ');
    },

    // æ˜¾ç¤ºå·¦ä¾§è¾¹æ ï¼ˆå½“ç¦»å¼€Profileé¡µé¢æ—¶è°ƒç”¨ï¼‰
    showLeftSidebar() {
        const leftSidebar = document.querySelector('.left-sidebar');
        const contentArea = document.querySelector('.content-area');
        
        if (leftSidebar) {
            leftSidebar.style.display = '';
        }
        
        if (contentArea) {
            contentArea.style.width = '';
            contentArea.style.marginLeft = '';
        }
        
        console.log('ğŸ¨ å·²æ˜¾ç¤ºå·¦ä¾§è¾¹æ ');
    },

    // ç”ŸæˆProfileé¡µé¢HTML
    generateProfileHTML() {
        if (!this.profileData) {
            return '<div class="profile-error">ç”¨æˆ·æ•°æ®æœªåŠ è½½</div>';
        }

        const { username, created_at, stats } = this.profileData;
        const createdDate = new Date(created_at);
        const formattedDate = createdDate.toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        const formattedTime = createdDate.toLocaleTimeString('zh-CN', {
            hour: '2-digit',
            minute: '2-digit'
        });

        // è®¡ç®—æ³¨å†Œå¤©æ•°
        const daysSinceRegistration = Math.floor((new Date() - createdDate) / (1000 * 60 * 60 * 24));

        return `
            <div class="profile-content-panel">
                <div class="profile-content">
                    <div class="profile-section">
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">ğŸ“Š åŸºæœ¬ä¿¡æ¯</h4>
                            <div class="stats-list">
                                <div class="stats-item">
                                    <span class="stats-label">ç”¨æˆ·å</span>
                                    <span class="stats-value">${username}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">æ³¨å†Œæ—¥æœŸ</span>
                                    <span class="stats-value">${formattedDate} ${formattedTime}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">ä½¿ç”¨å¤©æ•°</span>
                                    <span class="stats-value">${daysSinceRegistration} å¤©</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3 class="section-title">ä½¿ç”¨ç»Ÿè®¡</h3>
                        
                        <!-- ç®¡ç†æˆå‘˜åˆ—è¡¨ -->
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">ğŸ‘¥ è¢«ç®¡ç†æˆå‘˜ (${this.profileData.managed_users.length}ä¸ª)</h4>
                            <div class="stats-list">
                                ${this.generateManagedUsersList()}
                            </div>
                        </div>

                        <!-- ä»»åŠ¡ç»Ÿè®¡ -->
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">ğŸ“ ä»»åŠ¡ç®¡ç†</h4>
                            <div class="stats-list">
                                <div class="stats-item highlight">
                                    <span class="stats-label">è¿›è¡Œä¸­ä»»åŠ¡</span>
                                    <span class="stats-value">${stats.active_todos || 0}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">é‡å¤ä»»åŠ¡</span>
                                    <span class="stats-value">${stats.repeat_todos || 0}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">ä¸€æ¬¡æ€§ä»»åŠ¡</span>
                                    <span class="stats-value">${stats.onetime_todos || 0}</span>
                                </div>
                                <div class="stats-item secondary">
                                    <span class="stats-label">å·²åˆ é™¤ä»»åŠ¡</span>
                                    <span class="stats-value">${stats.deleted_todos || 0}</span>
                                </div>
                                <div class="stats-item secondary">
                                    <span class="stats-label">å†å²ä»»åŠ¡æ€»æ•°</span>
                                    <span class="stats-value">${stats.total_todos || 0}</span>
                                </div>
                            </div>
                        </div>

                        <!-- ç¬”è®°ç»Ÿè®¡ -->
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">ğŸ“„ å¥åº·ç¬”è®° (æ€»è®¡${stats.total_notes || 0}ä¸ª)</h4>
                            <div class="stats-list">
                                ${this.generateNotesStatsList()}
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">âš™ï¸ è´¦æˆ·æ“ä½œ</h4>
                            <div class="action-buttons">
                                <button class="btn btn-success" id="refreshProfileBtn">
                                    <span class="btn-icon">ğŸ”„</span>
                                    åˆ·æ–°æ•°æ®
                                </button>
                                <button class="btn btn-danger" id="logoutBtn">
                                    <span class="btn-icon">ğŸšª</span>
                                    é€€å‡ºç™»å½•
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    },

    // ç”Ÿæˆç®¡ç†æˆå‘˜åˆ—è¡¨
    generateManagedUsersList() {
        if (!this.profileData.managed_users || this.profileData.managed_users.length === 0) {
            return '<div class="stats-item empty">æš‚æ— ç®¡ç†æˆå‘˜</div>';
        }

        return this.profileData.managed_users.map(user => {
            const linkStatus = user.is_linked ? 'ğŸ”—å·²å…³è”' : 'â­•æœªå…³è”';
            const linkUser = user.supervised_app_user ? ` (${user.supervised_app_user})` : '';
            
            return `
                <div class="stats-item user-item">
                    <div class="user-info">
                        <span class="user-name">${user.display_name} (${user.username})</span>
                        <span class="user-status">${linkStatus}${linkUser}</span>
                    </div>
                </div>
            `;
        }).join('');
    },

    // ç”Ÿæˆç¬”è®°ç»Ÿè®¡åˆ—è¡¨
    generateNotesStatsList() {
        if (!this.profileData.user_notes || this.profileData.user_notes.length === 0) {
            return '<div class="stats-item empty">æš‚æ— ç¬”è®°æ•°æ®</div>';
        }

        return this.profileData.user_notes.map(user => {
            return `
                <div class="stats-item">
                    <span class="stats-label">${user.display_name}</span>
                    <span class="stats-value">${user.notes_count}ä¸ª</span>
                </div>
            `;
        }).join('');
    },

    // ç»‘å®šProfileé¡µé¢äº‹ä»¶
    bindProfileEvents() {
        // åˆ·æ–°æŒ‰é’®
        const refreshBtn = document.getElementById('refreshProfileBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                this.renderProfilePanel();
            });
        }

        // ç™»å‡ºæŒ‰é’®
        const logoutBtn = document.getElementById('logoutBtn');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', () => {
                this.showLogoutConfirmation();
            });
        }
    },

    // æ˜¾ç¤ºç™»å‡ºç¡®è®¤å¯¹è¯æ¡†
    showLogoutConfirmation() {
        const confirmHtml = `
            <div class="modal-overlay" id="logoutModal">
                <div class="modal-content logout-modal">
                    <div class="modal-header">
                        <h3>ç¡®è®¤é€€å‡º</h3>
                    </div>
                    <div class="modal-body">
                        <div class="logout-icon">ğŸšª</div>
                        <p>æ‚¨ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿ</p>
                        <p class="logout-note">é€€å‡ºåéœ€è¦é‡æ–°ç™»å½•æ‰èƒ½ä½¿ç”¨åº”ç”¨ã€‚</p>
                    </div>
                    <div class="modal-actions">
                        <button class="btn btn-secondary" id="cancelLogoutBtn">å–æ¶ˆ</button>
                        <button class="btn btn-danger" id="confirmLogoutBtn">ç¡®è®¤é€€å‡º</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', confirmHtml);
        
        // ç»‘å®šäº‹ä»¶
        const modal = document.getElementById('logoutModal');
        const cancelBtn = document.getElementById('cancelLogoutBtn');
        const confirmBtn = document.getElementById('confirmLogoutBtn');
        
        // å–æ¶ˆæŒ‰é’®
        cancelBtn.addEventListener('click', () => {
            this.closeLogoutModal();
        });
        
        // ç¡®è®¤æŒ‰é’®
        confirmBtn.addEventListener('click', () => {
            this.performLogout();
        });
        
        // ç‚¹å‡»èƒŒæ™¯å…³é—­
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                this.closeLogoutModal();
            }
        });
    },

    // å…³é—­ç™»å‡ºç¡®è®¤å¯¹è¯æ¡†
    closeLogoutModal() {
        const modal = document.getElementById('logoutModal');
        if (modal) {
            modal.remove();
        }
    },

    // æ‰§è¡Œç™»å‡ºæ“ä½œ
    performLogout() {
        console.log('ğŸšª æ‰§è¡Œç™»å‡ºæ“ä½œ...');
        
        try {
            // æ¸…é™¤æ‰€æœ‰ç™»å½•ç›¸å…³çš„localStorageæ•°æ®
            localStorage.removeItem('wenting_current_app_user');
            localStorage.removeItem('wenting_login_time');
            localStorage.removeItem('wenting_current_user_id');
            localStorage.removeItem('wenting_current_module');
            
            console.log('âœ… ç™»å½•æ•°æ®å·²æ¸…é™¤');
            
            // å…³é—­ç¡®è®¤å¯¹è¯æ¡†
            this.closeLogoutModal();
            
            // æ˜¾ç¤ºç™»å‡ºæˆåŠŸæ¶ˆæ¯
            this.showLogoutMessage();
            
            // å»¶è¿Ÿè·³è½¬åˆ°ç™»å½•é¡µé¢
            setTimeout(() => {
                window.location.href = 'login.html';
            }, 1500);
            
        } catch (error) {
            console.error('âŒ ç™»å‡ºæ“ä½œå¤±è´¥:', error);
            
            DialogUtils.showError('ç™»å‡ºå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'ç™»å‡ºé”™è¯¯');
        }
    },

    // æ˜¾ç¤ºç™»å‡ºæˆåŠŸæ¶ˆæ¯
    showLogoutMessage() {
        const messageEl = document.createElement('div');
        messageEl.className = 'logout-success-message';
        messageEl.innerHTML = `
            <div class="logout-success-content">
                <div class="success-icon">âœ…</div>
                <h3>é€€å‡ºæˆåŠŸ</h3>
                <p>æ­£åœ¨è·³è½¬åˆ°ç™»å½•é¡µé¢...</p>
            </div>
        `;
        
        document.body.appendChild(messageEl);
        
        // 3ç§’åè‡ªåŠ¨ç§»é™¤æ¶ˆæ¯
        setTimeout(() => {
            if (messageEl.parentNode) {
                messageEl.parentNode.removeChild(messageEl);
            }
        }, 3000);
    },

    // è·å–å½“å‰ç”¨æˆ·å
    getCurrentAppUser() {
        return this.currentAppUser;
    },

    // è·å–ç”¨æˆ·èµ„æ–™æ•°æ®
    getProfileData() {
        return this.profileData;
    }
};

// å¯¼å‡ºåˆ°å…¨å±€
window.ProfileManager = ProfileManager;


// å¤©æ°”ç®¡ç†æ¨¡å—
const WeatherManager = {
    weatherData: null,
    userLocation: null,
    autoUpdateTimer: null,
    locationReady: false,

    // Open-Meteoå¤©æ°”ä»£ç æ˜ å°„
    weatherCodeMap: {
        0: { condition: 'æ™´æœ—', icon: 'â˜€ï¸' },
        1: { condition: 'åŸºæœ¬æ™´æœ—', icon: 'ğŸŒ¤ï¸' },
        2: { condition: 'éƒ¨åˆ†å¤šäº‘', icon: 'â›…' },
        3: { condition: 'é˜´å¤©', icon: 'â˜ï¸' },
        45: { condition: 'é›¾', icon: 'ğŸŒ«ï¸' },
        48: { condition: 'å†»é›¾', icon: 'ğŸŒ«ï¸' },
        51: { condition: 'ç»†é›¨', icon: 'ğŸŒ¦ï¸' },
        53: { condition: 'å°é›¨', icon: 'ğŸŒ¦ï¸' },
        55: { condition: 'ä¸­é›¨', icon: 'ğŸŒ§ï¸' },
        61: { condition: 'å°é›¨', icon: 'ğŸŒ¦ï¸' },
        63: { condition: 'ä¸­é›¨', icon: 'ğŸŒ§ï¸' },
        65: { condition: 'å¤§é›¨', icon: 'ğŸŒ§ï¸' },
        71: { condition: 'å°é›ª', icon: 'ğŸŒ¨ï¸' },
        73: { condition: 'ä¸­é›ª', icon: 'â„ï¸' },
        75: { condition: 'å¤§é›ª', icon: 'â„ï¸' },
        80: { condition: 'é˜µé›¨', icon: 'ğŸŒ¦ï¸' },
        81: { condition: 'é˜µé›¨', icon: 'ğŸŒ¦ï¸' },
        82: { condition: 'æš´é›¨', icon: 'â›ˆï¸' },
        95: { condition: 'é›·é›¨', icon: 'â›ˆï¸' },
        96: { condition: 'é›·é›¨å†°é›¹', icon: 'â›ˆï¸' },
        99: { condition: 'å¼ºé›·é›¨å†°é›¹', icon: 'â›ˆï¸' }
    },

    async init() {
        console.log('WeatherManager åˆå§‹åŒ–å¼€å§‹ - åªä½¿ç”¨ç”¨æˆ·å®é™…ä½ç½®');

        this.loadWeatherData();

        // å¿…é¡»è·å–ç”¨æˆ·å®é™…ä½ç½®ï¼Œä¸ä½¿ç”¨ä»»ä½•é»˜è®¤ä½ç½®
        await this.getCurrentLocation();

        if (this.userLocation && this.locationReady) {
            console.log('âœ… ç”¨æˆ·ä½ç½®è·å–æˆåŠŸï¼Œå¼€å§‹è·å–å¤©æ°”æ•°æ®');
            this.fetchRealWeatherData();
            this.updateWeatherDisplay();
        } else {
            console.log('âŒ æ— æ³•è·å–ç”¨æˆ·ä½ç½®ï¼Œå¤©æ°”åŠŸèƒ½ä¸å¯ç”¨');
            this.showLocationError();
        }

        console.log('WeatherManager åˆå§‹åŒ–å®Œæˆï¼Œç”¨æˆ·ä½ç½®:', this.userLocation);
    },

    // æ¸…é™¤ä½ç½®ç¼“å­˜ï¼Œå¼ºåˆ¶é‡æ–°è·å–
    clearLocationCache() {
        localStorage.removeItem('wenting_user_location');
        this.userLocation = null;
        this.locationReady = false;
        console.log('ğŸ—‘ï¸ ä½ç½®ç¼“å­˜å·²æ¸…é™¤');
    },

    // è·å–ç”¨æˆ·åœ°ç†ä½ç½®
    async getCurrentLocation() {
        try {
            if (!navigator.geolocation) {
                console.log('âŒ æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†ä½ç½®ï¼Œå¤©æ°”åŠŸèƒ½ä¸å¯ç”¨');
                this.locationReady = false;
                return;
            }

            // æ£€æŸ¥æ˜¯å¦ä¸ºHTTPSæˆ–localhost
            const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost';
            if (!isSecureContext) {
                console.log('âš ï¸ éå®‰å…¨ä¸Šä¸‹æ–‡ï¼Œåœ°ç†ä½ç½®APIä¸å¯ç”¨');
                this.locationReady = false;
                return;
            }

            console.log('ğŸŒ è¯·æ±‚ç”¨æˆ·åœ°ç†ä½ç½®æƒé™...');
            
            // æ˜¾ç¤ºä½ç½®æƒé™è¯·æ±‚æç¤º
            this.showLocationPermissionPrompt();

            const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        console.log('âœ… ç”¨æˆ·æˆæƒåœ°ç†ä½ç½®æˆåŠŸ');
                        this.hideLocationPermissionPrompt();
                        resolve(pos);
                    },
                    (error) => {
                        console.log('âŒ åœ°ç†ä½ç½®è·å–å¤±è´¥:', error.message);
                        this.hideLocationPermissionPrompt();
                        
                        if (error.code === error.PERMISSION_DENIED) {
                            console.log('ç”¨æˆ·æ‹’ç»äº†åœ°ç†ä½ç½®æƒé™');
                        } else if (error.code === error.POSITION_UNAVAILABLE) {
                            console.log('ä½ç½®ä¿¡æ¯ä¸å¯ç”¨');
                        } else if (error.code === error.TIMEOUT) {
                            console.log('è·å–ä½ç½®è¶…æ—¶');
                        }
                        
                        // ä¸ä½¿ç”¨é»˜è®¤ä½ç½®ï¼Œç›´æ¥å¤±è´¥
                        reject(error);
                    },
                    {
                        enableHighAccuracy: false, // é™ä½ç²¾åº¦è¦æ±‚ï¼Œæé«˜æˆåŠŸç‡
                        timeout: 15000, // å¢åŠ è¶…æ—¶æ—¶é—´
                        maximumAge: 600000 // 10åˆ†é’Ÿç¼“å­˜
                    }
                );
            });

            // ä½¿ç”¨ç”¨æˆ·çš„å®é™…ä½ç½®ï¼Œä¸åšä»»ä½•åœ°åŒºé™åˆ¶
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            this.userLocation = {
                latitude: lat,
                longitude: lon,
                city: 'è·å–ä¸­...'
            };
            this.locationReady = true;

            console.log('âœ… è·å–åˆ°ç”¨æˆ·å®é™…ä½ç½®:', this.userLocation);

            // å¼‚æ­¥è·å–åŸå¸‚åç§°å’Œå¤©æ°”æ•°æ®
            this.getCityFromCoords(lat, lon).then(cityName => {
                this.userLocation.city = cityName;
                console.log('ğŸ™ï¸ åŸå¸‚åç§°æ›´æ–°:', cityName);
                // è·å–å¤©æ°”æ•°æ®ï¼ˆæ­¤æ—¶åŸå¸‚åç§°å·²æ›´æ–°ï¼‰
                this.fetchRealWeatherData();
            }).catch(() => {
                // å¦‚æœåŸå¸‚åç§°è·å–å¤±è´¥ï¼Œä»ç„¶è·å–å¤©æ°”æ•°æ®
                console.log('åŸå¸‚åç§°è·å–å¤±è´¥ï¼Œä½¿ç”¨åæ ‡è·å–å¤©æ°”');
                this.fetchRealWeatherData();
            });

        } catch (error) {
            console.log('âŒ è·å–ç”¨æˆ·ä½ç½®å¤±è´¥:', error.message);
            this.userLocation = null;
            this.locationReady = false;
        }
    },

    // æ ¹æ®åæ ‡è·å–åŸå¸‚åç§°
    async getCityFromCoords(lat, lon) {
        try {
            // ä½¿ç”¨å…è´¹çš„åå‘åœ°ç†ç¼–ç æœåŠ¡è·å–åŸå¸‚å
            const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=zh`);
            if (response.ok) {
                const data = await response.json();
                const city = data.city || data.locality || data.principalSubdivision || 'æœªçŸ¥ä½ç½®';
                console.log('ğŸ™ï¸ è·å–åˆ°åŸå¸‚å:', city);
                return city;
            }
        } catch (error) {
            console.log('åå‘åœ°ç†ç¼–ç å¤±è´¥:', error);
        }

        // å¦‚æœåå‘åœ°ç†ç¼–ç å¤±è´¥ï¼Œè¿”å›åæ ‡
        return `${lat.toFixed(2)}Â°, ${lon.toFixed(2)}Â°`;
    },

    // è·å–çœŸå®å¤©æ°”æ•°æ® - æ¸è¿›å¼è·å–ï¼Œæœ‰å¤šå°‘æ˜¾ç¤ºå¤šå°‘
    async fetchRealWeatherData() {
        try {
            if (!this.userLocation || !this.locationReady) {
                console.log('âŒ æ²¡æœ‰ç”¨æˆ·ä½ç½®ä¿¡æ¯ï¼Œæ— æ³•è·å–å¤©æ°”æ•°æ®');
                this.showLocationError();
                return null;
            }

            const { latitude, longitude } = this.userLocation;

            // å°è¯•è·å–åŸºç¡€æ•°æ®ï¼ˆæ¸©åº¦ã€æ¹¿åº¦ã€å¤©æ°”çŠ¶å†µï¼‰
            let weatherData = await this.tryFetchWeatherData(latitude, longitude);
            
            if (weatherData) {
                this.updateWeather(weatherData);
                console.log('å¤©æ°”æ•°æ®æ›´æ–°æˆåŠŸ:', weatherData);
                return weatherData;
            } else {
                console.log('æ— æ³•è·å–ä»»ä½•å¤©æ°”æ•°æ®');
                return null;
            }

        } catch (error) {
            console.error('è·å–å¤©æ°”æ•°æ®å¤±è´¥:', error);
            if (!this.userLocation || !this.locationReady) {
                this.showLocationError();
            }
            return null;
        }
    },

    // è·å–å¤©æ°”æ•°æ® - APIç°åœ¨å·¥ä½œæ­£å¸¸ï¼Œç›´æ¥è·å–å®Œæ•´æ•°æ®
    async tryFetchWeatherData(latitude, longitude) {
        const cityName = this.userLocation?.city || 'å½“å‰ä½ç½®';
        
        try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m&timezone=auto`;
            console.log('æ­£åœ¨è·å–å¤©æ°”æ•°æ®...', url);
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('âœ… è·å–åˆ°å®Œæ•´å¤©æ°”æ•°æ®:', data);
            return this.convertApiData(data, cityName);
            
        } catch (error) {
            console.log('âŒ å¤©æ°”æ•°æ®è·å–å¤±è´¥:', error.message);
            return null;
        }
    },

    // è½¬æ¢APIæ•°æ®æ ¼å¼
    convertApiData(apiData, cityName) {
        const current = apiData.current;
        const weatherCode = current.weather_code;
        const weatherInfo = this.weatherCodeMap[weatherCode] || { condition: 'æœªçŸ¥', icon: 'â“' };

        return {
            location: cityName,
            icon: weatherInfo.icon,
            condition: weatherInfo.condition,
            temperature: Math.round(current.temperature_2m) + 'Â°C',
            wind: {
                level: this.convertWindSpeed(current.wind_speed_10m),
                label: 'é£åŠ›'
            },
            humidity: {
                value: Math.round(current.relative_humidity_2m) + '%',
                label: 'æ¹¿åº¦'
            },
            lastUpdated: new Date().toISOString(),
            isError: false
        };
    },

    // è½¬æ¢é£é€Ÿä¸ºç­‰çº§
    convertWindSpeed(windSpeedKmh) {
        if (windSpeedKmh < 6) return '1çº§';
        if (windSpeedKmh < 12) return '2çº§';
        if (windSpeedKmh < 20) return '3çº§';
        if (windSpeedKmh < 29) return '4çº§';
        if (windSpeedKmh < 39) return '5çº§';
        if (windSpeedKmh < 50) return '6çº§';
        if (windSpeedKmh < 62) return '7çº§';
        if (windSpeedKmh < 75) return '8çº§';
        if (windSpeedKmh < 89) return '9çº§';
        if (windSpeedKmh < 103) return '10çº§';
        if (windSpeedKmh < 118) return '11çº§';
        return '12çº§';
    },



    // æ˜¾ç¤ºä½ç½®æƒé™è¯·æ±‚æç¤º
    showLocationPermissionPrompt() {
        const locationElement = Utils.$('.weather-location');
        if (locationElement) {
            locationElement.textContent = 'è¯·æ±‚ä½ç½®æƒé™...';
            locationElement.className = 'weather-location requesting';
            locationElement.title = 'æ­£åœ¨è¯·æ±‚åœ°ç†ä½ç½®æƒé™ï¼Œè¯·å…è®¸è®¿é—®';
        }
    },

    // éšè—ä½ç½®æƒé™è¯·æ±‚æç¤º
    hideLocationPermissionPrompt() {
        // æç¤ºä¼šåœ¨åç»­çš„updateWeatherDisplayä¸­è¢«æ›´æ–°
    },

    // æ˜¾ç¤ºä½ç½®æƒé™è¢«æ‹’ç»çš„æ¶ˆæ¯
    showLocationDeniedMessage() {
        // æ˜¾ç¤ºä¸€ä¸ªä¸´æ—¶æç¤ºæ¶ˆæ¯
        this.showTemporaryMessage('ä½ç½®æƒé™è¢«æ‹’ç»ï¼Œç‚¹å‡»ä½ç½®åŒºåŸŸå¯é‡æ–°è¯·æ±‚', 'warning');
    },

    // è¯·æ±‚ä½ç½®æƒé™
    async requestLocationPermission() {
        console.log('ğŸŒ ç”¨æˆ·ä¸»åŠ¨è¯·æ±‚ä½ç½®æƒé™...');
        
        // æ˜¾ç¤ºä½ç½®æƒé™è¯´æ˜å¯¹è¯æ¡†
        this.showLocationPermissionDialog();
    },

    // æ˜¾ç¤ºä½ç½®æƒé™è¯´æ˜å¯¹è¯æ¡†
    showLocationPermissionDialog() {
        const modalHtml = `
            <div class="modal-overlay" id="locationPermissionModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>ğŸ“ ä½ç½®æƒé™è¯·æ±‚</h3>
                        <button class="modal-close" onclick="WeatherManager.closeLocationPermissionDialog()">Ã—</button>
                    </div>
                    <div class="location-permission-content">
                        <div class="permission-explanation">
                            <p>ğŸŒ¤ï¸ å¤©æ°”åŠŸèƒ½éœ€è¦è·å–æ‚¨çš„åœ°ç†ä½ç½®æ¥æä¾›å‡†ç¡®çš„å¤©æ°”ä¿¡æ¯ã€‚</p>
                            <p>ğŸ“± ç‚¹å‡»"è·å–ä½ç½®"åï¼Œæµè§ˆå™¨ä¼šè¯¢é—®æ‚¨æ˜¯å¦å…è®¸è®¿é—®ä½ç½®ä¿¡æ¯ã€‚</p>
                            <p>ğŸ”’ æ‚¨çš„ä½ç½®ä¿¡æ¯ä»…ç”¨äºè·å–å¤©æ°”æ•°æ®ï¼Œä¸ä¼šè¢«å­˜å‚¨æˆ–åˆ†äº«ã€‚</p>
                        </div>
                        <div class="permission-actions">
                            <button class="permission-btn allow" onclick="WeatherManager.startLocationRequest()">
                                ğŸ“ è·å–ä½ç½®
                            </button>
                            <button class="permission-btn cancel" onclick="WeatherManager.closeLocationPermissionDialog()">
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    },

    // å…³é—­ä½ç½®æƒé™å¯¹è¯æ¡†
    closeLocationPermissionDialog() {
        const modal = document.getElementById('locationPermissionModal');
        if (modal) {
            modal.remove();
        }
    },

    // å¼€å§‹ä½ç½®è¯·æ±‚
    async startLocationRequest() {
        // å…³é—­å¯¹è¯æ¡†
        this.closeLocationPermissionDialog();
        
        // æ˜¾ç¤ºè¯·æ±‚ä¸­çŠ¶æ€
        this.showLocationPermissionPrompt();
        
        try {
            // é‡æ–°è·å–ä½ç½®
            await this.getCurrentLocation();
            
            if (this.userLocation && this.locationReady) {
                console.log('âœ… ä½ç½®æƒé™è·å–æˆåŠŸ');
                this.fetchRealWeatherData();
                this.updateWeatherDisplay();
                this.showTemporaryMessage('ä½ç½®æƒé™è·å–æˆåŠŸï¼', 'success');
            }
        } catch (error) {
            console.log('âŒ ä½ç½®æƒé™è¯·æ±‚å¤±è´¥:', error);
            this.showLocationError();
            this.showTemporaryMessage('ä½ç½®æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸ä½ç½®è®¿é—®', 'error');
        }
    },

    // æ˜¾ç¤ºä¸´æ—¶æ¶ˆæ¯
    showTemporaryMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `weather-message weather-message-${type}`;
        messageEl.textContent = message;
        let backgroundColor = '#2196F3'; // é»˜è®¤è“è‰²
        if (type === 'warning') backgroundColor = '#ff9800';
        if (type === 'success') backgroundColor = '#4CAF50';
        if (type === 'error') backgroundColor = '#f44336';
        
        messageEl.style.cssText = `
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: ${backgroundColor};
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10001;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        
        document.body.appendChild(messageEl);
        
        // 3ç§’åè‡ªåŠ¨ç§»é™¤
        setTimeout(() => {
            if (messageEl.parentNode) {
                messageEl.style.opacity = '0';
                messageEl.style.transition = 'opacity 0.3s ease';
                setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 300);
            }
        }, 3000);
    },

    // æ˜¾ç¤ºä½ç½®é”™è¯¯ä¿¡æ¯
    showLocationError() {
        console.log('æ˜¾ç¤ºä½ç½®æƒé™é”™è¯¯ä¿¡æ¯');
        const errorData = {
            location: 'ä½ç½®æœªæˆæƒ',
            icon: 'âŒ',
            condition: 'éœ€è¦ä½ç½®æƒé™',
            temperature: '--Â°C',
            wind: {
                level: '--',
                label: 'é£åŠ›'
            },
            humidity: {
                value: '--%',
                label: 'æ¹¿åº¦'
            },
            lastUpdated: new Date().toISOString(),
            isError: true
        };

        this.updateWeather(errorData);

        // ç›´æ¥æ›´æ–°ä½ç½®æ˜¾ç¤ºï¼Œå¹¶æ·»åŠ ç‚¹å‡»äº‹ä»¶
        const locationElement = Utils.$('.weather-location');
        if (locationElement) {
            locationElement.textContent = 'ç‚¹å‡»æˆæƒä½ç½®';
            locationElement.className = 'weather-location error clickable';
            locationElement.title = 'ç‚¹å‡»è¯·æ±‚åœ°ç†ä½ç½®æƒé™';
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶æ¥è¯·æ±‚ä½ç½®æƒé™
            locationElement.style.cursor = 'pointer';
            locationElement.onclick = () => {
                this.requestLocationPermission();
            };
        }
    },

    // åŠ è½½å¤©æ°”æ•°æ®
    loadWeatherData() {
        const savedWeather = localStorage.getItem('wenting_weather');
        if (savedWeather) {
            this.weatherData = JSON.parse(savedWeather);
            // æ£€æŸ¥æ•°æ®æ˜¯å¦è¿‡æœŸï¼ˆè¶…è¿‡30åˆ†é’Ÿï¼‰
            if (this.weatherData.lastUpdated) {
                const lastUpdate = new Date(this.weatherData.lastUpdated);
                const now = new Date();
                const diffMinutes = (now - lastUpdate) / (1000 * 60);

                if (diffMinutes > 30) {
                    console.log('å¤©æ°”æ•°æ®å·²è¿‡æœŸï¼Œå°†é‡æ–°è·å–');
                    this.fetchRealWeatherData();
                }
            }
        } else {
            this.weatherData = Utils.deepClone(APP_CONFIG.weather);
        }
    },

    // ä¿å­˜å¤©æ°”æ•°æ®
    saveWeatherData() {
        localStorage.setItem('wenting_weather', JSON.stringify(this.weatherData));
    },

    // æ›´æ–°å¤©æ°”æ˜¾ç¤ºï¼ˆä¸»å…¥å£ï¼‰
    updateWeatherDisplay() {
        console.log('ğŸ”„ updateWeatherDisplay è¢«è°ƒç”¨');
        console.log('æ›´æ–°å¤©æ°”æ˜¾ç¤ºï¼Œæ•°æ®:', this.weatherData);
        
        // æ£€æŸ¥å¤©æ°”æ•°æ®
        if (!this._validateWeatherData()) {
            return;
        }

        // è·å–DOMå…ƒç´ 
        const elements = this._getWeatherElements();
        
        // æ›´æ–°å„ä¸ªéƒ¨åˆ†
        this._updateBasicWeatherInfo(elements);
        this._updateWindInfo(elements);
        this._updateHumidityInfo(elements);
        this._updateLocationInfo(elements);
    },

    // éªŒè¯å¤©æ°”æ•°æ®
    _validateWeatherData() {
        if (!this.weatherData) {
            console.log('æ²¡æœ‰å¤©æ°”æ•°æ®');
            if (!this.userLocation || !this.locationReady) {
                this.showLocationError();
            }
            return false;
        }
        return true;
    },

    // è·å–å¤©æ°”ç›¸å…³DOMå…ƒç´ 
    _getWeatherElements() {
        const elements = {
            icon: Utils.$('.weather-icon'),
            condition: Utils.$('.weather-condition'),
            temp: Utils.$('.weather-temp'),
            windValue: Utils.$('.weather-wind-value'),
            windLabel: Utils.$('.weather-wind-label'),
            humidityValue: Utils.$('.weather-humidity-value'),
            humidityLabel: Utils.$('.weather-humidity-label'),
            location: Utils.$('.weather-location')
        };
        
        console.log('ğŸ” è°ƒè¯•ï¼šlocationå…ƒç´ :', elements.location);
        console.log('ğŸ” è°ƒè¯•ï¼šweatherData.location:', this.weatherData.location);
        console.log('ğŸ” è°ƒè¯•ï¼šuserLocation:', this.userLocation);
        console.log('ğŸ” è°ƒè¯•ï¼šlocationReady:', this.locationReady);
        
        return elements;
    },

    // æ›´æ–°åŸºç¡€å¤©æ°”ä¿¡æ¯
    _updateBasicWeatherInfo(elements) {
        if (elements.icon) {
            elements.icon.textContent = this.weatherData.icon;
        }

        if (elements.condition) {
            elements.condition.textContent = this.weatherData.condition;
            // å¦‚æœæ˜¯å¤‡ç”¨æ•°æ®ï¼Œæ·»åŠ æç¤º
            if (this.weatherData.isFallback) {
                elements.condition.title = 'ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œæ˜¾ç¤ºå¤‡ç”¨æ•°æ®';
            }
        }

        if (elements.temp) {
            elements.temp.textContent = this.weatherData.temperature;
        }
    },

    // æ›´æ–°é£åŠ›ä¿¡æ¯
    _updateWindInfo(elements) {
        if (elements.windValue) {
            elements.windValue.textContent = this.weatherData.wind.level;
        }

        if (elements.windLabel) {
            elements.windLabel.textContent = this.weatherData.wind.label;
        }
    },

    // æ›´æ–°æ¹¿åº¦ä¿¡æ¯
    _updateHumidityInfo(elements) {
        if (elements.humidityValue) {
            elements.humidityValue.textContent = this.weatherData.humidity.value;
        }

        if (elements.humidityLabel) {
            elements.humidityLabel.textContent = this.weatherData.humidity.label;
        }
    },

    // æ›´æ–°ä½ç½®ä¿¡æ¯
    _updateLocationInfo(elements) {
        console.log('ğŸ” å¼€å§‹æ›´æ–°ä½ç½®æ˜¾ç¤º');
        if (!elements.location) {
            console.log('âŒ æœªæ‰¾åˆ°locationå…ƒç´ ');
            return;
        }

        console.log('âœ… æ‰¾åˆ°locationå…ƒç´ ');
        
        if (this.weatherData.isError) {
            this._setLocationError(elements.location);
        } else if (this.weatherData.location) {
            this._setLocationFromWeatherData(elements.location);
        } else if (this.userLocation && this.locationReady) {
            this._setLocationFromUserData(elements.location);
        } else {
            this._setLocationLoading(elements.location);
        }
    },

    // è®¾ç½®ä½ç½®é”™è¯¯çŠ¶æ€
    _setLocationError(locationElement) {
        console.log('âŒ æ˜¾ç¤ºé”™è¯¯çŠ¶æ€');
        locationElement.textContent = 'ä½ç½®æœªæˆæƒ';
        locationElement.className = 'weather-location error';
    },

    // ä½¿ç”¨å¤©æ°”æ•°æ®è®¾ç½®ä½ç½®
    _setLocationFromWeatherData(locationElement) {
        console.log('ğŸ™ï¸ ä½¿ç”¨å¤©æ°”æ•°æ®ä¸­çš„ä½ç½®:', this.weatherData.location);
        locationElement.textContent = this.weatherData.location;
        locationElement.className = 'weather-location';
        
        // è®¾ç½®æç¤ºä¿¡æ¯
        if (this.userLocation && this.userLocation.latitude && this.userLocation.longitude) {
            locationElement.title = `çº¬åº¦: ${this.userLocation.latitude.toFixed(4)}, ç»åº¦: ${this.userLocation.longitude.toFixed(4)}`;
        } else {
            locationElement.title = 'åŸºäºå¤©æ°”æ•°æ®çš„ä½ç½®';
        }
        console.log('âœ… ä½ç½®å·²æ›´æ–°ä¸º:', locationElement.textContent);
    },

    // ä½¿ç”¨ç”¨æˆ·æ•°æ®è®¾ç½®ä½ç½®
    _setLocationFromUserData(locationElement) {
        console.log('ğŸ“ ä½¿ç”¨ç”¨æˆ·ä½ç½®æ•°æ®:', this.userLocation.city);
        locationElement.textContent = this.userLocation.city || 'å½“å‰ä½ç½®';
        locationElement.className = 'weather-location';
        locationElement.title = `çº¬åº¦: ${this.userLocation.latitude.toFixed(4)}, ç»åº¦: ${this.userLocation.longitude.toFixed(4)}`;
    },

    // è®¾ç½®å®šä½ä¸­çŠ¶æ€
    _setLocationLoading(locationElement) {
        console.log('â³ æ˜¾ç¤ºå®šä½ä¸­çŠ¶æ€');
        locationElement.textContent = 'å®šä½ä¸­...';
        locationElement.className = 'weather-location loading';
    },

    // æ›´æ–°å¤©æ°”æ•°æ®
    updateWeather(newWeatherData) {
        this.weatherData = { ...this.weatherData, ...newWeatherData };
        this.saveWeatherData();
        this.updateWeatherDisplay();
    },

    // æ‰‹åŠ¨åˆ·æ–°å¤©æ°”
    async refreshWeather() {
        console.log('æ‰‹åŠ¨åˆ·æ–°å¤©æ°”æ•°æ®...');

        // æ·»åŠ åŠ è½½çŠ¶æ€
        const weatherBar = Utils.$('.weather-bar');
        const weatherIcon = Utils.$('.weather-icon');

        if (weatherBar) {
            weatherBar.classList.add('loading');
        }
        if (weatherIcon) {
            weatherIcon.classList.add('loading');
        }

        try {
            await this.fetchRealWeatherData();
        } catch (error) {
            console.error('åˆ·æ–°å¤©æ°”å¤±è´¥:', error);
        } finally {
            // ç§»é™¤åŠ è½½çŠ¶æ€
            setTimeout(() => {
                if (weatherBar) {
                    weatherBar.classList.remove('loading');
                }
                if (weatherIcon) {
                    weatherIcon.classList.remove('loading');
                }
            }, 300); // å»¶è¿Ÿä¸€ä¸‹è®©ç”¨æˆ·çœ‹åˆ°åé¦ˆ
        }
    },

    // å®šæ—¶æ›´æ–°å¤©æ°”
    startAutoUpdate(interval = 30 * 60 * 1000) {
        console.log('å¯åŠ¨å¤©æ°”è‡ªåŠ¨æ›´æ–°ï¼Œé—´éš”:', interval / 60000, 'åˆ†é’Ÿ');

        // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨ï¼Œé˜²æ­¢é‡å¤åˆ›å»º
        if (this.autoUpdateTimer) {
            clearInterval(this.autoUpdateTimer);
        }

        this.autoUpdateTimer = setInterval(() => {
            console.log('è‡ªåŠ¨æ›´æ–°å¤©æ°”æ•°æ®...');
            this.fetchRealWeatherData();
        }, interval);
    },

    // åœæ­¢è‡ªåŠ¨æ›´æ–°
    stopAutoUpdate() {
        if (this.autoUpdateTimer) {
            clearInterval(this.autoUpdateTimer);
            this.autoUpdateTimer = null;
            console.log('å¤©æ°”è‡ªåŠ¨æ›´æ–°å·²åœæ­¢');
        }
    },

    // æ ¹æ®å¤©æ°”ä»£ç è·å–å¤©æ°”ä¿¡æ¯ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
    getWeatherIcon(condition) {
        const iconMap = {
            'æ™´æœ—': 'â˜€ï¸',
            'å¤šäº‘': 'â›…',
            'é˜´å¤©': 'â˜ï¸',
            'å°é›¨': 'ğŸŒ¦ï¸',
            'å¤§é›¨': 'ğŸŒ§ï¸',
            'é›·é›¨': 'â›ˆï¸',
            'é›ª': 'â„ï¸',
            'é›¾': 'ğŸŒ«ï¸'
        };

        return iconMap[condition] || 'â˜€ï¸';
    },


};

// æš´éœ²WeatherManageråˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
window.WeatherManager = WeatherManager;



// ä¸»åº”ç”¨ç¨‹åº
const App = {
    // é˜²é‡å¤è°ƒç”¨æ ‡å¿—
    _refreshingAfterLink: false,
    
    init() {
        // ç­‰å¾…DOMåŠ è½½å®Œæˆ
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                this.initializeApp();
            });
        } else {
            this.initializeApp();
        }
    },

    // åˆå§‹åŒ–åº”ç”¨
    async initializeApp() {
        console.log('é›¯å©·åº”ç”¨å¯åŠ¨ä¸­...');
        
        try {
            // æŒ‰é¡ºåºåˆå§‹åŒ–å„ä¸ªæ¨¡å—
            await this.initializeModules();
            
            // ç»‘å®šå…¨å±€äº‹ä»¶
            this.bindGlobalEvents();
            
            console.log('é›¯å©·åº”ç”¨å¯åŠ¨å®Œæˆ');
        } catch (error) {
            console.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
        }
    },

    // åˆå§‹åŒ–æ¨¡å—
    async initializeModules() {
        // é¦–å…ˆåˆå§‹åŒ–è®¾å¤‡ç®¡ç†å™¨
        if (window.DeviceManager) {
            await DeviceManager.init();
        }
        
        // ç¡®ä¿ ApiClient å·²åŠ è½½
        if (typeof window.ApiClient === 'undefined') {
            console.error('âŒ ApiClient æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥è„šæœ¬åŠ è½½é¡ºåº');
            return;
        }
        
        // åˆå§‹åŒ–å…¨å±€ç”¨æˆ·çŠ¶æ€ç®¡ç†å™¨
        if (window.GlobalUserState) {
            GlobalUserState.init();
        }
        
        // åˆå§‹åŒ–æ—¥æœŸç®¡ç†å™¨
        DateManager.init();
        
        // åˆå§‹åŒ–å¤©æ°”ç®¡ç†å™¨ï¼ˆç­‰å¾…åœ°ç†ä½ç½®è·å–å®Œæˆï¼‰
        if (window.WeatherManager) {
            await WeatherManager.init();
            // å¯åŠ¨å¤©æ°”è‡ªåŠ¨æ›´æ–°ï¼ˆ30åˆ†é’Ÿé—´éš”ï¼‰
            WeatherManager.startAutoUpdate();
        } else {
            console.error('âŒ WeatherManageræœªåŠ è½½');
        }
        
        // åˆå§‹åŒ–ç”¨æˆ·ç®¡ç†å™¨ï¼ˆå¼‚æ­¥ï¼Œéœ€è¦ç­‰å¾…å®Œæˆï¼‰
        await UserManager.init();
        
        // åˆå§‹åŒ–TODOç®¡ç†å™¨ï¼ˆæœ€ååˆå§‹åŒ–ï¼Œå› ä¸ºå®ƒä¾èµ–ç”¨æˆ·ç®¡ç†å™¨ï¼‰
        await TodoManager.init();
        
        // åˆå§‹åŒ–Notesç®¡ç†å™¨
        if (window.NotesManager) {
            await NotesManager.init();
        }
        
        // åˆå§‹åŒ–Profileç®¡ç†å™¨
        if (window.ProfileManager) {
            await ProfileManager.init();
        }
        
        // è®¾ç½®é»˜è®¤æ¨¡å—ä¸ºtodo
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('todo');
            // ç»‘å®šå…¨å±€ç”¨æˆ·é€‰æ‹©å™¨äº‹ä»¶
            GlobalUserState.bindUserSelectorEvents();
        }
        
        // åˆå§‹åŒ–WebSocketè¿æ¥
        if (window.WebSocketClient) {
            try {
                await WebSocketClient.init();
                console.log('âœ… WebSocketè¿æ¥å·²å»ºç«‹');
                
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šç¡®ä¿æ³¨å†Œæ¶ˆæ¯åœ¨ç”¨æˆ·ä¿¡æ¯å‡†å¤‡å¥½åå‘é€
                this.ensureWebSocketRegistration();
            } catch (error) {
                console.error('âš ï¸ WebSocketè¿æ¥å¤±è´¥ï¼Œä½†åº”ç”¨å°†ç»§ç»­ä½¿ç”¨HTTPæ¨¡å¼:', error);
            }
        }
        
        // å®ŒæˆåŠ è½½ï¼Œæ˜¾ç¤ºåº”ç”¨ç•Œé¢
        if (window.LoadingManager) {
            LoadingManager.completeLoading();
            
            // ç›‘å¬åº”ç”¨å®¹å™¨æ˜¾ç¤ºäº‹ä»¶ï¼Œç„¶ååˆå§‹åŒ–ç”¨æˆ·ç•Œé¢
            this.waitForAppContainerVisible();
        } else {
            console.log('âš ï¸ LoadingManagerä¸å­˜åœ¨ï¼Œç›´æ¥åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢');
            // å»¶è¿Ÿä¸€ä¸‹ç¡®ä¿DOMæ¸²æŸ“å®Œæˆ
            setTimeout(() => {
                this.initializeUserInterface();
            }, 100);
        }
    },

    // ç­‰å¾…åº”ç”¨å®¹å™¨æ˜¾ç¤º
    waitForAppContainerVisible() {
        console.log('â³ ç­‰å¾…åº”ç”¨å®¹å™¨æ˜¾ç¤º...');
        
        const checkAppContainer = () => {
            const appContainer = document.getElementById('appContainer');
            const loadingScreen = document.getElementById('loadingScreen');
            
            console.log('ğŸ” æ£€æŸ¥åº”ç”¨å®¹å™¨çŠ¶æ€:');
            console.log('  - appContainerå­˜åœ¨:', !!appContainer);
            console.log('  - appContaineræ˜¾ç¤º:', appContainer?.style.display !== 'none');
            console.log('  - loadingScreenå­˜åœ¨:', !!loadingScreen);
            console.log('  - loadingScreenæ˜¾ç¤º:', loadingScreen?.style.display !== 'none');
            
            if (appContainer && appContainer.style.display !== 'none' && 
                (!loadingScreen || loadingScreen.style.display === 'none')) {
                console.log('âœ… åº”ç”¨å®¹å™¨å·²æ˜¾ç¤ºï¼Œå¼€å§‹åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢');
                this.initializeUserInterface();
            } else {
                console.log('â³ åº”ç”¨å®¹å™¨è¿˜æœªæ˜¾ç¤ºï¼Œç»§ç»­ç­‰å¾…...');
                setTimeout(checkAppContainer, 100);
            }
        };
        
        // å¼€å§‹æ£€æŸ¥
        setTimeout(checkAppContainer, 500); // ç»™LoadingManagerä¸€äº›æ—¶é—´å¼€å§‹åŠ¨ç”»
    },

    // åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢
    async initializeUserInterface() {
        console.log('ğŸ¨ å¼€å§‹åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢');
        console.log('ğŸ” è°ƒè¯•ä¿¡æ¯:');
        console.log('  - TodoManagerå­˜åœ¨:', !!window.TodoManager);
        console.log('  - TodoManager.currentUser:', window.TodoManager?.currentUser);
        console.log('  - UserManagerå­˜åœ¨:', !!window.UserManager);
        console.log('  - UserManager.usersæ•°é‡:', window.UserManager?.users?.length || 0);
        console.log('  - GlobalUserStateå­˜åœ¨:', !!window.GlobalUserState);
        console.log('  - GlobalUserState.currentUserId:', window.GlobalUserState?.currentUserId);
        console.log('  - å½“å‰æ¨¡å—:', window.GlobalUserState?.getCurrentModule());
        
        if (!window.TodoManager) {
            console.error('âŒ TodoManageræœªåˆå§‹åŒ–');
            return;
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰ç”¨æˆ·æ•°æ®å­˜åœ¨
        if (window.UserManager && window.UserManager.users && window.UserManager.users.length > 0) {
            // ç¡®ä¿å½“å‰ç”¨æˆ·å·²è®¾ç½®
            if (!TodoManager.currentUser) {
                console.log('âš ï¸ å½“å‰ç”¨æˆ·æœªè®¾ç½®ï¼Œé‡æ–°è®¾ç½®é»˜è®¤ç”¨æˆ·');
                TodoManager.setDefaultUser();
            }
            
            console.log('ğŸ¯ å½“å‰ç”¨æˆ·ID:', TodoManager.currentUser);
            console.log('ğŸ¯ å½“å‰æ¨¡å—:', GlobalUserState ? GlobalUserState.getCurrentModule() : 'unknown');
            
            // é¦–å…ˆæ¸²æŸ“ç”¨æˆ·æ ‡ç­¾
            if (window.UserManager) {
                console.log('ğŸ”„ å¼€å§‹æ¸²æŸ“ç”¨æˆ·æ ‡ç­¾...');
                window.UserManager.renderUserTabs();
                console.log('âœ… ç”¨æˆ·æ ‡ç­¾æ¸²æŸ“å®Œæˆ');
            }
            
            // ç„¶åæ›´æ–°ç”¨æˆ·é€‰æ‹©å™¨UI
            if (window.GlobalUserState) {
                console.log('ğŸ”„ å¼€å§‹æ›´æ–°ç”¨æˆ·é€‰æ‹©å™¨UI...');
                GlobalUserState.updateUserSelectorUI();
                console.log('âœ… ç”¨æˆ·é€‰æ‹©å™¨UIæ›´æ–°å®Œæˆ');
            }
            
            // æœ€åæ¸²æŸ“TODOå†…å®¹ï¼ˆå¦‚æœå½“å‰æ¨¡å—æ˜¯todoï¼‰
            if (window.GlobalUserState && GlobalUserState.getCurrentModule() === 'todo') {
                console.log('ğŸ”„ å¼€å§‹åŠ è½½å¹¶æ¸²æŸ“TODOå†…å®¹');
                console.log('ğŸ” TODOæ•°æ®è°ƒè¯•:');
                console.log('  - TodoManager.todos:', TodoManager.todos);
                console.log('  - å½“å‰ç”¨æˆ·çš„TODOæ•°æ®:', TodoManager.todos[TodoManager.currentUser]);
                
                // é€šè¿‡è§¦å‘ç”¨æˆ·åˆ‡æ¢äº‹ä»¶æ¥åŠ è½½TODOï¼Œç¡®ä¿ä¸ç”¨æˆ·ç‚¹å‡»åˆ‡æ¢çš„è¡Œä¸ºä¸€è‡´
                if (TodoManager.currentUser) {
                    console.log('ğŸ¯ é€šè¿‡å…¨å±€çŠ¶æ€è§¦å‘ç”¨æˆ·åˆ‡æ¢äº‹ä»¶æ¥åˆå§‹åŒ–TODOæ˜¾ç¤º');
                    
                    // ä¸´æ—¶è®¾ç½®ä¸ºnullï¼Œç¡®ä¿setCurrentUserä¼šè§¦å‘äº‹ä»¶
                    const targetUserId = TodoManager.currentUser;
                    GlobalUserState.currentUserId = null;
                    GlobalUserState.setCurrentUser(targetUserId);
                    
                    console.log('âœ… å¼ºåˆ¶è§¦å‘ç”¨æˆ·åˆ‡æ¢äº‹ä»¶å®Œæˆ');
                } else {
                    console.warn('âš ï¸ å½“å‰ç”¨æˆ·æœªè®¾ç½®ï¼Œæ— æ³•åŠ è½½TODO');
                }
            } else {
                console.log('âš ï¸ å½“å‰æ¨¡å—ä¸æ˜¯todoï¼Œè·³è¿‡TODOæ¸²æŸ“');
            }
        } else {
            console.log('ğŸ¨ æ²¡æœ‰ç”¨æˆ·ï¼Œæ˜¾ç¤ºç©ºç”¨æˆ·çŠ¶æ€');
            TodoManager.showEmptyUserState();
        }
    },

    // ç»‘å®šå…¨å±€äº‹ä»¶
    bindGlobalEvents() {
        // ç»‘å®šæ·»åŠ ç”¨æˆ·æŒ‰é’®äº‹ä»¶
        const addUserBtn = document.getElementById('addUserBtn');
        if (addUserBtn) {
            addUserBtn.addEventListener('click', () => {
                if (window.UserManager && typeof UserManager.addUser === 'function') {
                    UserManager.addUser();
                } else {
                    console.error('UserManager.addUser æ–¹æ³•ä¸å¯ç”¨');
                }
            });
        }
        
        // åº•éƒ¨å¯¼èˆªç‚¹å‡»æ•ˆæœ - ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç¡®ä¿æ­£ç¡®ç»‘å®š
        document.addEventListener('click', (e) => {
            const navItem = e.target.closest('.nav-item');
            if (navItem) {
                const label = navItem.querySelector('.nav-label')?.textContent;
                console.log('å¯¼èˆªåˆ°ï¼š', label);
                
                // æ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆé’ˆå¯¹Todoå’ŒNotesé¡µé¢åˆ‡æ¢ï¼‰
                if ((label === 'Todo' || label === 'Notes') && window.DateManager) {
                    window.DateManager.showLoadingProgress();
                }
                
                // è¿™é‡Œå¯ä»¥æ·»åŠ è·¯ç”±é€»è¾‘
                this.handleNavigation(label);
            }
        });

        // å¤©æ°”æ ç‚¹å‡»å¤„ç†
        const weatherBar = Utils.$('.weather-bar');
        if (weatherBar) {
            weatherBar.addEventListener('click', (e) => {
                if (!window.WeatherManager) {
                    console.error('âŒ WeatherManageræœªåŠ è½½');
                    return;
                }
                
                // å¦‚æœç‚¹å‡»çš„æ˜¯ä½ç½®åŒºåŸŸä¸”ä½ç½®æœªæˆæƒï¼Œè¯·æ±‚ä½ç½®æƒé™
                const locationElement = e.target.closest('.weather-location');
                if (locationElement && locationElement.classList.contains('error')) {
                    console.log('ç”¨æˆ·ç‚¹å‡»ä½ç½®æœªæˆæƒåŒºåŸŸï¼Œè¯·æ±‚ä½ç½®æƒé™');
                    WeatherManager.requestLocationPermission();
                } else {
                    console.log('ç”¨æˆ·ç‚¹å‡»å¤©æ°”æ ï¼Œåˆ·æ–°å¤©æ°”æ•°æ®');
                    WeatherManager.refreshWeather();
                }
            });
            
            // æ·»åŠ æ‚¬åœæç¤º
            weatherBar.style.cursor = 'pointer';
            weatherBar.title = 'ç‚¹å‡»åˆ·æ–°å¤©æ°”æ•°æ®ï¼Œä½ç½®æœªæˆæƒæ—¶ç‚¹å‡»å¯è¯·æ±‚æƒé™';
        }

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', (event) => {
            console.error('å…¨å±€é”™è¯¯:', event.error);
        });

        // é¡µé¢å¯è§æ€§å˜åŒ–å¤„ç†
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // é¡µé¢å˜ä¸ºå¯è§æ—¶ï¼Œæ›´æ–°å½“å‰æ—¶é—´å’Œå¤©æ°”
                if (window.DateManager) {
                    DateManager.updateCurrentDate();
                }
                
                // æ£€æŸ¥å¤©æ°”æ•°æ®æ˜¯å¦éœ€è¦æ›´æ–°
                if (window.WeatherManager && WeatherManager.weatherData?.lastUpdated) {
                    const lastUpdate = new Date(WeatherManager.weatherData.lastUpdated);
                    const now = new Date();
                    const diffMinutes = (now - lastUpdate) / (1000 * 60);
                    
                    // å¦‚æœè¶…è¿‡15åˆ†é’Ÿï¼Œåˆ·æ–°å¤©æ°”
                    if (diffMinutes > 15) {
                        console.log('é¡µé¢é‡æ–°æ¿€æ´»ï¼Œåˆ·æ–°å¤©æ°”æ•°æ®');
                        WeatherManager.fetchRealWeatherData();
                    }
                }
            }
        });

        // åœ¨çº¿/ç¦»çº¿çŠ¶æ€å¤„ç†
        window.addEventListener('online', () => {
            console.log('ç½‘ç»œè¿æ¥æ¢å¤ï¼Œåˆ·æ–°å¤©æ°”æ•°æ®');
            if (window.WeatherManager) {
                WeatherManager.fetchRealWeatherData();
            }
        });

        window.addEventListener('offline', () => {
            console.log('ç½‘ç»œè¿æ¥æ–­å¼€ï¼Œå°†ä½¿ç”¨ç¼“å­˜æ•°æ®');
        });

        // è®¾å¤‡IDæ›´æ–°å¤„ç†
        window.addEventListener('deviceIdUpdated', (event) => {
            console.log('ğŸ”„ è®¾å¤‡IDå·²æ›´æ–°:', event.detail.deviceId);
            
            // å»¶è¿Ÿé‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®ï¼Œè®©è®¾å¤‡IDç”Ÿæ•ˆ
            setTimeout(async () => {
                try {
                    if (window.UserManager && typeof UserManager.loadUsers === 'function') {
                        console.log('ğŸ”„ é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®...');
                        await UserManager.loadUsers();
                        console.log('âœ… ç”¨æˆ·æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
                    }
                } catch (error) {
                    console.error('âŒ é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
                }
            }, 1000);
        });

        // WebSocketæ¶ˆæ¯å¤„ç†å°†åœ¨WebSocketClientåˆå§‹åŒ–åå¤„ç†
        // è¿™äº›å¤„ç†å™¨ç°åœ¨é€šè¿‡WebSocketClientçš„handleMessageæ–¹æ³•å¤„ç†
        console.log('ğŸ”Œ LinkåŠŸèƒ½WebSocketå¤„ç†å™¨å·²å‡†å¤‡');
    },

    // å¤„ç†å¯¼èˆª
    handleNavigation(page) {
        switch (page) {
            case 'Todo':
                // æ˜¾ç¤ºTodoé¡µé¢
                this.showTodoPage();
                break;
            case 'Notes':
                // æ˜¾ç¤ºNotesé¡µé¢
                this.showNotesPage();
                break;
            case 'Link':
                // æ˜¾ç¤ºLinké¡µé¢ï¼ˆåœ¨SPAå†…åˆ‡æ¢ï¼‰
                this.showLinkPage();
                break;
            case 'Profile':
                // æ˜¾ç¤ºProfileé¡µé¢
                this.showProfilePage();
                break;
            default:
                console.log('æœªçŸ¥å¯¼èˆªç›®æ ‡:', page);
        }
    },

    // æ˜¾ç¤ºTodoé¡µé¢
    async showTodoPage() {
        console.log('åˆ‡æ¢åˆ°Todoé¡µé¢');
        
        // æ¢å¤å·¦ä¾§è¾¹æ æ˜¾ç¤º
        if (window.ProfileManager) {
            ProfileManager.showLeftSidebar();
        }
        
        // è®¾ç½®å…¨å±€çŠ¶æ€ä¸ºtodoæ¨¡å—
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('todo');
        }
        
        if (window.TodoManager) {
            const currentUser = GlobalUserState ? GlobalUserState.getCurrentUser() : TodoManager.currentUser;
            console.log('æ¸²æŸ“TODOé¡µé¢ï¼Œç”¨æˆ·:', currentUser);
            
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨äºUserManagerä¸­
            if (currentUser && window.UserManager && window.UserManager.users) {
                const userExists = UserManager.users.find(u => u.id === currentUser);
                if (!userExists) {
                    console.log('âš ï¸ å½“å‰ç”¨æˆ·ä¸åœ¨ç”¨æˆ·åˆ—è¡¨ä¸­ï¼Œå¯èƒ½æ˜¯æ–°å…³è”çš„ç”¨æˆ·ï¼Œé‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®...');
                    try {
                        await UserManager.loadUsersFromAPI();
                        console.log('âœ… ç”¨æˆ·æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
                    } catch (error) {
                        console.error('âŒ é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
                    }
                }
            }
            
            // ç¡®ä¿TODOæ•°æ®å·²åŠ è½½
            if (currentUser && (!TodoManager.todos[currentUser] || TodoManager.todos[currentUser].length === 0)) {
                console.log('ğŸ”„ TODOæ•°æ®æœªåŠ è½½ï¼Œæ­£åœ¨åŠ è½½...');
                try {
                    await TodoManager.loadTodosFromAPI();
                    console.log('âœ… TODOæ•°æ®åŠ è½½å®Œæˆ');
                } catch (error) {
                    console.error('âŒ TODOæ•°æ®åŠ è½½å¤±è´¥:', error);
                }
            }
            
            TodoManager.renderTodoPanel(currentUser);
            
            // éšè—è¿›åº¦æ¡ - å»¶é•¿æ˜¾ç¤ºæ—¶é—´è®©ç”¨æˆ·çœ‹åˆ°æ•ˆæœ
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 600);
        } else {
            console.error('TodoManageræœªåˆå§‹åŒ–');
            // å³ä½¿å‡ºé”™ä¹Ÿéšè—è¿›åº¦æ¡
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 300);
        }
    },

    // æ˜¾ç¤ºNotesé¡µé¢ï¼ˆä¼˜åŒ–ç‰ˆï¼Œé¿å…é‡å¤åˆå§‹åŒ–ï¼‰
    async showNotesPage() {
        console.log('åˆ‡æ¢åˆ°Notesé¡µé¢');
        
        try {
            this._initializeNotesPageUI();
            
            if (window.NotesManager) {
                await this._handleNotesManagerAvailable();
            } else {
                this._showNotesPlaceholder();
            }
        } catch (error) {
            this._handleNotesPageError(error);
        }
    },

    // åˆå§‹åŒ–Notesé¡µé¢UI
    _initializeNotesPageUI() {
        if (window.ProfileManager) {
            ProfileManager.showLeftSidebar();
        }
        
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('notes');
        }
    },

    // å¤„ç†NotesManagerå¯ç”¨çš„æƒ…å†µ
    async _handleNotesManagerAvailable() {
        await this._ensureNotesManagerOnline();
        
        const currentUser = this._getCurrentUserForNotes();
        console.log('åˆ‡æ¢åˆ°Notesé¡µé¢ï¼Œå½“å‰ç”¨æˆ·:', currentUser);
        
        await this._ensureUserDataValid(currentUser);
        await this._ensureNotesDataLoaded(currentUser);
        
        NotesManager.renderNotesPanel(currentUser);
        this._hideLoadingProgressDelayed(600);
    },

    // ç¡®ä¿NotesManageråœ¨çº¿
    async _ensureNotesManagerOnline() {
        if (NotesManager.isOnline === false) {
            NotesManager.isOnline = await ApiClient.testConnection();
        }
    },

    // è·å–å½“å‰ç”¨æˆ·
    _getCurrentUserForNotes() {
        return GlobalUserState ? 
               GlobalUserState.getCurrentUser() : 
               NotesManager.currentUser;
    },

    // ç¡®ä¿ç”¨æˆ·æ•°æ®æœ‰æ•ˆ
    async _ensureUserDataValid(currentUser) {
        if (currentUser && window.UserManager && window.UserManager.users) {
            const userExists = UserManager.users.find(u => u.id === currentUser);
            if (!userExists) {
                await this._reloadUserData();
            }
        }
    },

    // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
    async _reloadUserData() {
        console.log('âš ï¸ å½“å‰ç”¨æˆ·ä¸åœ¨ç”¨æˆ·åˆ—è¡¨ä¸­ï¼Œå¯èƒ½æ˜¯æ–°å…³è”çš„ç”¨æˆ·ï¼Œé‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®...');
        try {
            await UserManager.loadUsersFromAPI();
            console.log('âœ… ç”¨æˆ·æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
        } catch (error) {
            console.error('âŒ é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
        }
    },

    // ç¡®ä¿Notesæ•°æ®å·²åŠ è½½
    async _ensureNotesDataLoaded(currentUser) {
        if (this._shouldLoadNotesData(currentUser)) {
            await this._loadNotesData();
        }
    },

    // æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½Notesæ•°æ®
    _shouldLoadNotesData(currentUser) {
        return currentUser && 
               (!NotesManager.notes[currentUser] || 
                NotesManager.notes[currentUser].length === 0);
    },

    // åŠ è½½Notesæ•°æ®
    async _loadNotesData() {
        console.log('ğŸ”„ Notesæ•°æ®æœªåŠ è½½ï¼Œæ­£åœ¨åŠ è½½...');
        try {
            await NotesManager.loadNotesFromAPI();
            console.log('âœ… Notesæ•°æ®åŠ è½½å®Œæˆ');
        } catch (error) {
            console.error('âŒ Notesæ•°æ®åŠ è½½å¤±è´¥:', error);
        }
    },

    // æ˜¾ç¤ºNoteså ä½ç¬¦
    _showNotesPlaceholder() {
        const contentArea = Utils.$('#contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="notes-content-panel">
                    <div class="notes-placeholder">
                        <h3>Notes åŠŸèƒ½</h3>
                        <p>æ­£åœ¨åŠ è½½ç¬”è®°åŠŸèƒ½...</p>
                    </div>
                </div>
            `;
        }
        this._hideLoadingProgressDelayed(600);
    },

    // å¤„ç†Notesé¡µé¢é”™è¯¯
    _handleNotesPageError(error) {
        console.error('åŠ è½½Notesé¡µé¢å¤±è´¥:', error);
        this._hideLoadingProgressDelayed(300);
    },

    // å»¶è¿Ÿéšè—åŠ è½½è¿›åº¦
    _hideLoadingProgressDelayed(delay) {
        setTimeout(() => {
            if (window.DateManager) window.DateManager.hideLoadingProgress();
        }, delay);
    },

    // æ˜¾ç¤ºProfileé¡µé¢
    async showProfilePage() {
        console.log('åˆ‡æ¢åˆ°Profileé¡µé¢');
        
        try {
            // è®¾ç½®å…¨å±€çŠ¶æ€ä¸ºprofileæ¨¡å—
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentModule('profile');
            }
            
            if (window.ProfileManager) {
                // æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
                if (!ProfileManager.currentAppUser) {
                    console.log('é¦–æ¬¡åŠ è½½Profileï¼Œå¼€å§‹åˆå§‹åŒ–');
                    await ProfileManager.init();
                }
                
                // æ¸²æŸ“Profileé¡µé¢
                await ProfileManager.renderProfilePanel();
                
                // å»¶é•¿æ˜¾ç¤ºæ—¶é—´è®©ç”¨æˆ·çœ‹åˆ°æ•ˆæœ
                setTimeout(() => {
                    if (window.DateManager) window.DateManager.hideLoadingProgress();
                }, 600);
            } else {
                console.error('âŒ ProfileManageræœªåŠ è½½');
                
                // æ˜¾ç¤ºé”™è¯¯å ä½å†…å®¹
                const contentArea = document.getElementById('contentArea');
                if (contentArea) {
                    contentArea.innerHTML = `
                        <div class="profile-content-panel">
                            <div class="profile-error">
                                <div class="error-icon">âŒ</div>
                                <h3>åŠ è½½å¤±è´¥</h3>
                                <p>ProfileåŠŸèƒ½æœªæ­£ç¡®åŠ è½½</p>
                            </div>
                        </div>
                    `;
                }
                
                // å³ä½¿å‡ºé”™ä¹Ÿè¦éšè—è¿›åº¦æ¡
                setTimeout(() => {
                    if (window.DateManager) window.DateManager.hideLoadingProgress();
                }, 300);
            }
        } catch (error) {
            console.error('åŠ è½½Profileé¡µé¢å¤±è´¥:', error);
            
            // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="profile-content-panel">
                        <div class="profile-error">
                            <div class="error-icon">âŒ</div>
                            <h3>åŠ è½½å¤±è´¥</h3>
                            <p>${error.message}</p>
                            <button class="btn btn-primary" onclick="App.showProfilePage()">é‡è¯•</button>
                        </div>
                    </div>
                `;
            }
            
            // å³ä½¿å‡ºé”™ä¹Ÿè¦éšè—è¿›åº¦æ¡
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 300);
        }
    },

    // æ˜¾ç¤ºLinké¡µé¢
    async showLinkPage() {
        console.log('åˆ‡æ¢åˆ°Linké¡µé¢');
        
        try {
            // æ¢å¤å·¦ä¾§è¾¹æ æ˜¾ç¤º
            if (window.ProfileManager) {
                ProfileManager.showLeftSidebar();
            }
            
            // è®¾ç½®å…¨å±€çŠ¶æ€ä¸ºlinkæ¨¡å—
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentModule('link');
            }
            
            // åˆ›å»ºLinké¡µé¢çš„å†…å®¹
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="content-panel">
                        <!-- LinkçŠ¶æ€æ˜¾ç¤ºåŒº -->
                        <div class="link-status-area" id="linkStatusArea">
                            <div class="link-status-loading">
                                <div class="loading-spinner"></div>
                                <p>æ­£åœ¨æ£€æŸ¥å…³è”çŠ¶æ€...</p>
                            </div>
                        </div>
                        
                        <!-- Linkå†…å®¹åŒºåŸŸ -->
                        <div class="link-content-area">
                            <!-- ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤ºåŒº -->
                            <div class="user-info-display" id="userInfoDisplay">
                                <div class="empty-state">
                                    <div class="empty-icon">ğŸ‘¤</div>
                                    <p>è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªç”¨æˆ·</p>
                                    <p class="empty-subtitle">æŸ¥çœ‹ç”¨æˆ·çš„è¯¦ç»†ä¿¡æ¯</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                console.log('âœ… Linké¡µé¢HTMLå·²åˆ›å»º');
            }
            
            // åˆå§‹åŒ–Linké¡µé¢çš„äº‹ä»¶ç›‘å¬
            this.initializeLinkPageEvents();
            
            // æ£€æŸ¥å¹¶æ˜¾ç¤ºLinkè¿æ¥çŠ¶æ€
            setTimeout(async () => {
                await this.displayLinkConnectionStatus();
                this.displayDefaultUserInLink();
            }, 100);
            
            console.log('âœ… Linké¡µé¢åŠ è½½å®Œæˆ');
            
        } catch (error) {
            console.error('åŠ è½½Linké¡µé¢å¤±è´¥:', error);
            
            // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="content-panel">
                        <div class="link-error">
                            <div class="error-icon">âŒ</div>
                            <h3>åŠ è½½å¤±è´¥</h3>
                            <p>${error.message}</p>
                            <button class="btn btn-primary" onclick="App.showLinkPage()">é‡è¯•</button>
                        </div>
                    </div>
                `;
            }
        }
    },
    
    // åˆå§‹åŒ–Linké¡µé¢äº‹ä»¶ç›‘å¬
    initializeLinkPageEvents() {
        console.log('ğŸ¨ åˆå§‹åŒ–Linké¡µé¢äº‹ä»¶ç›‘å¬...');
        
        // ç›‘å¬ç”¨æˆ·é€‰æ‹©äº‹ä»¶
        const handleUserSelected = (event) => {
            const selectedUser = event.detail;
            console.log('ğŸ‘¤ [SPA Link] æ¥æ”¶åˆ°ç”¨æˆ·é€‰æ‹©äº‹ä»¶:', selectedUser);
            this.displayUserInfoInLink(selectedUser);
        };
        
        // ç§»é™¤æ—§çš„ç›‘å¬å™¨ï¼ˆé¿å…é‡å¤ç»‘å®šï¼‰
        document.removeEventListener('userSelected', handleUserSelected);
        // æ·»åŠ æ–°çš„ç›‘å¬å™¨
        document.addEventListener('userSelected', handleUserSelected);
        
        console.log('âœ… Linké¡µé¢äº‹ä»¶ç›‘å¬åˆå§‹åŒ–å®Œæˆ');
    },
    
    // æ˜¾ç¤ºLinkè¿æ¥çŠ¶æ€
    async displayLinkConnectionStatus() {
        try {
            console.log('ğŸ” [Link] æ£€æŸ¥è¿æ¥çŠ¶æ€...');
            
            const linkStatusArea = document.getElementById('linkStatusArea');
            if (!linkStatusArea) return;
            
            const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            if (!currentAppUser) {
                linkStatusArea.innerHTML = `
                    <div class="link-status-error">
                        <div class="status-icon">âŒ</div>
                        <h3>æœªç™»å½•</h3>
                        <p>è¯·å…ˆç™»å½•åæŸ¥çœ‹å…³è”çŠ¶æ€</p>
                    </div>
                `;
                return;
            }
            
            // æ£€æŸ¥ç”¨æˆ·çš„å…³è”å…³ç³»
            let response;
            try {
                if (window.WebSocketClient && window.WebSocketClient.isConnected) {
                    console.log('ğŸ” [Link] ä½¿ç”¨WebSocketæ£€æŸ¥è¿æ¥çŠ¶æ€...');
                    response = await window.WebSocketClient.links.checkLinkStatus(currentAppUser);
                } else {
                    console.log('ğŸ” [Link] WebSocketæœªè¿æ¥ï¼Œä½¿ç”¨HTTPæ¨¡å¼...');
                    // HTTPé™çº§æ¨¡å¼
                    const apiResponse = await fetch(`/api/links/user/${currentAppUser}/status`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
                        }
                    });
                    
                    if (!apiResponse.ok) {
                        throw new Error(`HTTP ${apiResponse.status}: ${apiResponse.statusText}`);
                    }
                    
                    const data = await apiResponse.json();
                    response = { success: true, data: data };
                }
            } catch (error) {
                console.error('âŒ [Link] æ£€æŸ¥è¿æ¥çŠ¶æ€å¤±è´¥:', error);
                
                // æ˜¾ç¤ºæ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                let errorMessage = 'æ— æ³•è·å–å…³è”çŠ¶æ€';
                if (error.message.includes('è¯·æ±‚è¶…æ—¶')) {
                    errorMessage = 'WebSocketè¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                } else if (error.message.includes('HTTP')) {
                    errorMessage = `æœåŠ¡å™¨é”™è¯¯: ${error.message}`;
                }
                
                linkStatusArea.innerHTML = `
                    <div class="link-status-error">
                        <div class="status-icon">âš ï¸</div>
                        <h3>æ£€æŸ¥å¤±è´¥</h3>
                        <p>${errorMessage}</p>
                        <button class="btn btn-secondary" onclick="App.displayLinkConnectionStatus()" style="margin-top: 10px;">é‡è¯•</button>
                    </div>
                `;
                return;
            }
            
            if (response.success && response.data.links && response.data.links.length > 0) {
                // æœ‰å…³è”å…³ç³»ï¼Œæ˜¾ç¤ºè¿æ¥çŠ¶æ€
                const links = response.data.links;
                console.log('âœ… [Link] æ‰¾åˆ°å…³è”å…³ç³»:', links);
                
                linkStatusArea.innerHTML = `
                    <div class="link-status-connected">
                        <div class="status-icon">ğŸ”—</div>
                        <h3>å·²å»ºç«‹å…³è”</h3>
                        <div class="link-connections">
                            ${links.map(link => `
                                <div class="link-connection-item">
                                    <div class="connection-info">
                                        <span class="connection-partner">${link.manager_username || link.linked_username}</span>
                                        <span class="connection-user">${link.username}</span>
                                    </div>
                                    <div class="connection-status">
                                        <span class="status-badge active">æ´»è·ƒ</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <p class="link-description">æ‚¨å¯ä»¥åœ¨å·¦ä¾§çœ‹åˆ°å…³è”ç”¨æˆ·ï¼Œç‚¹å‡»Todoæˆ–NotesæŸ¥çœ‹å…±äº«æ•°æ®</p>
                    </div>
                `;
            } else {
                // æ²¡æœ‰å…³è”å…³ç³»
                linkStatusArea.innerHTML = `
                    <div class="link-status-empty">
                        <div class="status-icon">ğŸ”—</div>
                        <h3>æš‚æ— å…³è”</h3>
                        <p>æ‚¨è¿˜æ²¡æœ‰ä¸å…¶ä»–ç”¨æˆ·å»ºç«‹å…³è”å…³ç³»</p>
                        <p class="link-hint">å½“å…¶ä»–ç”¨æˆ·å‘æ‚¨å‘é€å…³è”é‚€è¯·æ—¶ï¼Œæ‚¨ä¼šæ”¶åˆ°é€šçŸ¥</p>
                    </div>
                `;
            }
            
        } catch (error) {
            console.error('âŒ [Link] æ˜¾ç¤ºè¿æ¥çŠ¶æ€å¤±è´¥:', error);
        }
    },
    
    // åœ¨Linké¡µé¢æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯
    displayUserInfoInLink(user) {
        console.log('ğŸ¨ [SPA Link] æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯:', user);
        console.log('ğŸ” [SPA Link] æ£€æŸ¥ userInfoDisplay å…ƒç´ æ˜¯å¦å­˜åœ¨...');
        
        const userInfoDisplay = document.getElementById('userInfoDisplay');
        console.log('ğŸ” [SPA Link] userInfoDisplay å…ƒç´ :', userInfoDisplay);
        
        if (userInfoDisplay && user) {
            userInfoDisplay.innerHTML = `
                <div class="selected-user-info">
                    <div class="user-avatar" style="background-color: ${user.avatar_color}">
                        ${user.display_name.charAt(0)}
                    </div>
                    <h3>${user.display_name}</h3>
                    <div class="user-details">
                        <div class="link-detail-item">
                            <span class="detail-label">ç”¨æˆ·å:</span>
                            <span class="detail-value">${user.username}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">æ˜¾ç¤ºåç§°:</span>
                            <span class="detail-value">${user.display_name}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">é‚®ç®±:</span>
                            <span class="detail-value">${user.email || 'æœªè®¾ç½®'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">æ‰‹æœºå·:</span>
                            <span class="detail-value">${user.phone || 'æœªè®¾ç½®'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">æ€§åˆ«:</span>
                            <span class="detail-value">${user.gender === 'male' ? 'ç”·' : user.gender === 'female' ? 'å¥³' : user.gender === 'other' ? 'å…¶ä»–' : 'æœªè®¾ç½®'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">ç”Ÿæ—¥:</span>
                            <span class="detail-value">${user.birthday ? new Date(user.birthday).toLocaleDateString() : 'æœªè®¾ç½®'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">å¤´åƒé¢œè‰²:</span>
                            <span class="detail-value">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: ${user.avatar_color}; border-radius: 50%; vertical-align: middle; margin-right: 8px;"></span>
                                ${user.avatar_color}
                            </span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">åˆ›å»ºæ—¶é—´:</span>
                            <span class="detail-value">${new Date(user.created_at).toLocaleString()}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">æœ€åæ›´æ–°:</span>
                            <span class="detail-value">${new Date(user.updated_at).toLocaleString()}</span>
                        </div>
                    </div>
                    
                    <!-- LinkåŠŸèƒ½åŒºåŸŸ -->
                    <div class="link-function-area" id="linkFunctionArea">
                        <div class="link-section-title">ç”¨æˆ·å…³è”</div>
                        <div class="link-content" id="linkContent-${user.id}">
                            <div class="loading-link">æ­£åœ¨æ£€æŸ¥å…³è”çŠ¶æ€...</div>
                        </div>
                    </div>
                </div>
            `;
            
            console.log('âœ… [SPA Link] ç”¨æˆ·ä¿¡æ¯å·²æ›´æ–°');
            
            // å»¶è¿ŸåŠ è½½LinkåŠŸèƒ½å†…å®¹
            setTimeout(() => {
                this.loadLinkFunctionContent(user);
            }, 100);
        } else {
            console.error('âŒ [SPA Link] userInfoDisplayå…ƒç´ æœªæ‰¾åˆ°æˆ–ç”¨æˆ·ä¸ºç©º');
        }
    },
    
    // åŠ è½½LinkåŠŸèƒ½å†…å®¹
    async loadLinkFunctionContent(user) {
        try {
            console.log('ğŸ”— [SPA Link] åŠ è½½ç”¨æˆ·å…³è”åŠŸèƒ½:', user.id);
            
            const linkContentEl = this._getLinkContentElement(user.id);
            if (!linkContentEl) return;
            
            const currentAppUser = this._getCurrentAppUser();
            if (!currentAppUser) {
                linkContentEl.innerHTML = '<div class="link-error">ç”¨æˆ·æœªç™»å½•</div>';
                return;
            }
            
            await this._loadAndRenderLinkStatus(user, currentAppUser, linkContentEl);
            console.log('âœ… [SPA Link] å…³è”åŠŸèƒ½ç•Œé¢å·²åŠ è½½');
        } catch (error) {
            console.error('âŒ [SPA Link] åŠ è½½å…³è”åŠŸèƒ½å¤±è´¥:', error);
            this._renderErrorState(user.id, 'åŠ è½½å…³è”åŠŸèƒ½å¤±è´¥');
        }
    },

    // è·å–å…³è”å†…å®¹å…ƒç´ 
    _getLinkContentElement(userId) {
        const linkContentEl = document.getElementById(`linkContent-${userId}`);
        if (!linkContentEl) {
            console.error('âŒ [SPA Link] æ‰¾ä¸åˆ°å…³è”å†…å®¹å®¹å™¨');
            return null;
        }
        return linkContentEl;
    },

    // è·å–å½“å‰åº”ç”¨ç”¨æˆ·
    _getCurrentAppUser() {
        return window.GlobalUserState ? 
               window.GlobalUserState.getAppUserId() : 
               localStorage.getItem('wenting_current_app_user');
    },

    // åŠ è½½å¹¶æ¸²æŸ“å…³è”çŠ¶æ€
    async _loadAndRenderLinkStatus(user, currentAppUser, linkContentEl) {
        try {
            console.log('ğŸ” [SPA Link] æ­£åœ¨æ£€æŸ¥ç”¨æˆ·å…³è”çŠ¶æ€...');
            
            const response = await this._fetchLinkStatus(currentAppUser);
            const allLinks = this._parseLinkResponse(response);
            
            if (response.success && allLinks.length > 0) {
                this.renderLinkedUserInterface(user, allLinks, linkContentEl);
            } else {
                this.renderLinkInputInterface(user, linkContentEl);
            }
        } catch (error) {
            console.error('âŒ [SPA Link] æ£€æŸ¥å…³è”çŠ¶æ€å¤±è´¥:', error);
            this._logLinkStatusError(error, currentAppUser, user);
            this.renderLinkInputInterface(user, linkContentEl);
        }
    },

    // è·å–å…³è”çŠ¶æ€
    async _fetchLinkStatus(currentAppUser) {
        if (window.WebSocketClient && window.WebSocketClient.isConnected) {
            return await window.WebSocketClient.links.checkLinkStatus(currentAppUser);
        } else {
            return await this._fetchLinkStatusViaHTTP(currentAppUser);
        }
    },

    // é€šè¿‡HTTPè·å–å…³è”çŠ¶æ€
    async _fetchLinkStatusViaHTTP(currentAppUser) {
        const apiResponse = await fetch(`/api/links/user/${currentAppUser}/status`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
            }
        });
        
        if (!apiResponse.ok) {
            throw new Error(`HTTP ${apiResponse.status}: ${apiResponse.statusText}`);
        }
        
        const data = await apiResponse.json();
        return { success: true, data: data };
    },

    // è§£æå…³è”å“åº”æ•°æ®
    _parseLinkResponse(response) {
        console.log('ğŸ”— [SPA Link] ç”¨æˆ·å…³è”çŠ¶æ€:', response);
        
        let allLinks = [];
        if (response.data?.links) {
            if (Array.isArray(response.data.links)) {
                // æ–°æ ¼å¼ï¼šç›´æ¥æ˜¯æ•°ç»„
                allLinks = response.data.links;
                console.log('ğŸ” [Debug] ä½¿ç”¨æ–°æ ¼å¼æ•°ç»„:', allLinks.length);
            } else if (response.data.links.asManager || response.data.links.asLinked) {
                // æ—§æ ¼å¼ï¼šåˆå¹¶asManagerå’ŒasLinked
                allLinks = this._mergeLegacyLinkFormats(response.data.links);
            }
        }
        
        console.log('ğŸ” [Debug] æœ€ç»ˆåˆå¹¶çš„linksæ•°ç»„:', allLinks);
        return allLinks;
    },

    // åˆå¹¶æ—§æ ¼å¼çš„å…³è”æ•°æ®
    _mergeLegacyLinkFormats(links) {
        const allLinks = [];
        if (links.asManager) {
            allLinks.push(...links.asManager);
        }
        if (links.asLinked) {
            allLinks.push(...links.asLinked);
        }
        console.log('ğŸ” [Debug] ä½¿ç”¨æ—§æ ¼å¼å¯¹è±¡ï¼Œåˆå¹¶åæ•°ç»„é•¿åº¦:', allLinks.length);
        return allLinks;
    },

    // è®°å½•å…³è”çŠ¶æ€é”™è¯¯æ—¥å¿—
    _logLinkStatusError(error, currentAppUser, user) {
        console.error('âŒ [Debug] é”™è¯¯è¯¦æƒ…:', error.message);
        console.error('âŒ [Debug] å½“å‰ç”¨æˆ·:', currentAppUser);
        console.error('âŒ [Debug] è¢«é€‰ä¸­ç”¨æˆ·:', user);
    },

    // æ¸²æŸ“é”™è¯¯çŠ¶æ€
    _renderErrorState(userId, errorMessage) {
        const linkContentEl = document.getElementById(`linkContent-${userId}`);
        if (linkContentEl) {
            linkContentEl.innerHTML = `<div class="link-error">${errorMessage}</div>`;
        }
    },
    
    // æ¸²æŸ“å…³è”è¾“å…¥ç•Œé¢
    renderLinkInputInterface(user, container) {
        container.innerHTML = `
            <div class="link-input-area">
                <div class="link-description">
                    å°† <strong>${user.display_name}</strong> çš„å¥åº·æ•°æ®ä¸å…¶ä»–ç”¨æˆ·å…³è”ï¼Œå®ç°æ•°æ®åŒæ­¥ã€‚
                </div>
                <div class="link-input-group">
                    <input type="text" 
                           id="linkUserInput-${user.id}" 
                           class="link-user-input" 
                           placeholder="è¾“å…¥è¦å…³è”çš„ç”¨æˆ·åï¼ˆå¦‚ï¼šwhitebladeï¼‰"
                           maxlength="10">
                    <button id="linkUserBtn-${user.id}" 
                            class="link-user-btn btn-primary" 
                            onclick="App.sendLinkRequest(${user.id})">
                        å‘é€å…³è”
                    </button>
                </div>
                <div class="link-tips">
                    ğŸ’¡ æç¤ºï¼šå…³è”ååŒæ–¹éƒ½èƒ½ç®¡ç† ${user.display_name} çš„å¥åº·æ•°æ®ï¼Œæ•°æ®ä¼šå®æ—¶åŒæ­¥ã€‚
                </div>
            </div>
        `;
    },
    
    // æ¸²æŸ“å·²å…³è”ç”¨æˆ·ç•Œé¢
    renderLinkedUserInterface(user, links, container) {
        const currentAppUser = localStorage.getItem('wenting_current_app_user');
        const linkInfo = links[0]; // å–ç¬¬ä¸€ä¸ªå…³è”å…³ç³»
        
        // ç¡®å®šå¯¹æ–¹ç”¨æˆ·
        const linkedUser = linkInfo.manager_app_user === currentAppUser ? 
                          linkInfo.linked_app_user : linkInfo.manager_app_user;
        const isManager = linkInfo.manager_app_user === currentAppUser;
        
        container.innerHTML = `
            <div class="link-linked-area">
                <div class="link-description">
                    <strong>${user.display_name}</strong> çš„å¥åº·æ•°æ®å·²ä¸å…¶ä»–ç”¨æˆ·å…³è”ã€‚
                </div>
                
                <!-- ç¬¬ä¸€è¡Œï¼šå…³è”çŠ¶æ€å’Œç”¨æˆ·ä¿¡æ¯ -->
                <div class="link-info-row">
                    <div class="link-status-badge success">âœ“ å·²å…³è”</div>
                    <div class="link-partner-info">
                        <span class="partner-label">å…³è”ç”¨æˆ·:</span>
                        <span class="partner-name">${linkedUser}</span>
                    </div>
                </div>
                
                <!-- ç¬¬äºŒè¡Œï¼šè§’è‰²å’Œæ—¶é—´ä¿¡æ¯ -->
                <div class="link-info-row">
                    <div class="link-role-info">
                        <span class="role-label">æ‚¨çš„è§’è‰²:</span>
                        <span class="role-badge ${isManager ? 'manager' : 'linked'}">${isManager ? 'ç®¡ç†å‘˜' : 'å…³è”ç”¨æˆ·'}</span>
                    </div>
                    <div class="link-time-info">
                        <span class="time-label">å…³è”æ—¶é—´:</span>
                        <span class="time-value">${new Date(linkInfo.created_at).toLocaleDateString()}</span>
                    </div>
                </div>
                
                <!-- ç¬¬ä¸‰è¡Œï¼šæ“ä½œæŒ‰é’® -->
                <div class="link-actions-row">
                    <button class="link-unlink-btn" 
                            onclick="App.confirmUnlink(${user.id}, ${linkInfo.id}, '${linkedUser}')">
                        ğŸ”— å–æ¶ˆå…³è”
                    </button>
                </div>
                
                <div class="link-tips">
                    ğŸ’¡ å–æ¶ˆå…³è”åï¼Œå¯¹æ–¹å°†æ— æ³•ç»§ç»­ç®¡ç† ${user.display_name} çš„å¥åº·æ•°æ®
                </div>
            </div>
        `;
    },
    
    // å‘é€å…³è”è¯·æ±‚ï¼ˆä¸»å…¥å£ï¼‰
    async sendLinkRequest(supervisedUserId) {
        try {
            console.log('ğŸ”— [SPA Link] å‘é€å…³è”è¯·æ±‚ï¼Œè¢«ç›‘ç®¡ç”¨æˆ·ID:', supervisedUserId);
            
            // è·å–å¹¶éªŒè¯è¡¨å•å…ƒç´ 
            const elements = this._getLinkRequestElements(supervisedUserId);
            if (!elements) return;
            
            // éªŒè¯è¾“å…¥å¹¶è·å–ç›®æ ‡ç”¨æˆ·å
            const targetUsername = this._validateLinkInput(elements.inputEl);
            if (!targetUsername) return;
            
            // è·å–å¹¶éªŒè¯è¢«ç›‘ç®¡ç”¨æˆ·ä¿¡æ¯
            const supervisedUser = this._getSupervisedUser(supervisedUserId);
            if (!supervisedUser) return;
            
            // å‘é€é‚€è¯·
            await this._sendInvitation(elements, targetUsername, supervisedUserId, supervisedUser);
            
        } catch (error) {
            console.error('âŒ [SPA Link] å‘é€å…³è”è¯·æ±‚å¤±è´¥:', error);
            this.showLinkNotification('error', 'å‘é€å…³è”è¯·æ±‚å¤±è´¥');
            this._resetButtonState(supervisedUserId);
        }
    },

    // è·å–å…³è”è¯·æ±‚ç›¸å…³DOMå…ƒç´ 
    _getLinkRequestElements(supervisedUserId) {
        const inputEl = document.getElementById(`linkUserInput-${supervisedUserId}`);
        const btnEl = document.getElementById(`linkUserBtn-${supervisedUserId}`);
        
        if (!inputEl || !btnEl) {
            console.error('âŒ [SPA Link] æ‰¾ä¸åˆ°è¾“å…¥å…ƒç´ ');
            return null;
        }
        
        return { inputEl, btnEl };
    },

    // éªŒè¯å…³è”è¾“å…¥
    _validateLinkInput(inputEl) {
        const targetUsername = inputEl.value.trim();
        
        if (!targetUsername) {
            this.showLinkNotification('error', 'è¯·è¾“å…¥è¦å…³è”çš„ç”¨æˆ·å');
            return null;
        }
        
        // éªŒè¯ç”¨æˆ·åæ ¼å¼
        if (!/^[a-z0-9]{1,10}$/.test(targetUsername)) {
            this.showLinkNotification('error', 'ç”¨æˆ·åæ ¼å¼ä¸æ­£ç¡®ï¼Œåªèƒ½åŒ…å«å°å†™å­—æ¯å’Œæ•°å­—ï¼Œé•¿åº¦1-10å­—ç¬¦');
            return null;
        }
        
        // æ£€æŸ¥æ˜¯å¦å°è¯•å…³è”è‡ªå·±
        const currentAppUser = this._getCurrentAppUser();
        if (targetUsername === currentAppUser) {
            this.showLinkNotification('error', 'ä¸èƒ½å…³è”è‡ªå·±');
            return null;
        }
        
        return targetUsername;
    },


    // è·å–è¢«ç›‘ç®¡ç”¨æˆ·ä¿¡æ¯
    _getSupervisedUser(supervisedUserId) {
        const supervisedUser = window.UserManager?.users?.find(u => u.id === supervisedUserId);
        if (!supervisedUser) {
            this.showLinkNotification('error', 'æ‰¾ä¸åˆ°è¢«ç›‘ç®¡ç”¨æˆ·ä¿¡æ¯');
            return null;
        }
        return supervisedUser;
    },

    // å‘é€é‚€è¯·
    async _sendInvitation(elements, targetUsername, supervisedUserId, supervisedUser) {
        const { inputEl, btnEl } = elements;
        
        // è®¾ç½®åŠ è½½çŠ¶æ€
        this._setButtonLoading(btnEl, 'æ£€æŸ¥ç”¨æˆ·...');
        
        try {
            btnEl.textContent = 'å‘é€é‚€è¯·...';
            
            // å‘é€é‚€è¯·
            const invitationResponse = await this._sendInvitationRequest(targetUsername, supervisedUserId, supervisedUser);
            console.log('ğŸ“¨ [SPA Link] é‚€è¯·å‘é€ç»“æœ:', invitationResponse);
            
            // å¤„ç†å“åº”
            this._handleInvitationResponse(invitationResponse, targetUsername, inputEl);
            
        } catch (error) {
            console.error('âŒ [SPA Link] WebSocketè¯·æ±‚å¤±è´¥:', error);
            this.showLinkNotification('error', error.message || 'å‘é€è¯·æ±‚å¤±è´¥');
        } finally {
            // é‡ç½®æŒ‰é’®
            this._resetButton(btnEl);
        }
    },

    // å‘é€é‚€è¯·è¯·æ±‚
    async _sendInvitationRequest(targetUsername, supervisedUserId, supervisedUser) {
        const currentAppUser = this._getCurrentAppUser();
        const message = `${currentAppUser} æƒ³è¦ä¸æ‚¨å…³è” ${supervisedUser.display_name} çš„å¥åº·æ•°æ®`;
        
        if (window.WebSocketClient && window.WebSocketClient.isConnected) {
            return await window.WebSocketClient.links.sendInvitation(targetUsername, supervisedUserId, message);
        } else {
            return await this._sendInvitationViaHTTP(targetUsername, supervisedUserId, message);
        }
    },

    // é€šè¿‡HTTPå‘é€é‚€è¯·
    async _sendInvitationViaHTTP(targetUsername, supervisedUserId, message) {
        const apiResponse = await fetch('/api/links/requests', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
            },
            body: JSON.stringify({
                toAppUser: targetUsername,
                supervisedUserId: supervisedUserId,
                message: message
            })
        });
        
        return { success: apiResponse.ok, data: await apiResponse.json() };
    },

    // å¤„ç†é‚€è¯·å“åº”
    _handleInvitationResponse(invitationResponse, targetUsername, inputEl) {
        if (invitationResponse.success) {
            const message = invitationResponse.isOverride 
                ? `é‚€è¯·å·²æ›´æ–°å¹¶é‡æ–°å‘é€ç»™ ${targetUsername}` 
                : `å…³è”é‚€è¯·å·²å‘é€ç»™ ${targetUsername}`;
            this.showLinkNotification('success', message);
            inputEl.value = '';
        } else {
            this._handleInvitationError(invitationResponse, targetUsername);
        }
    },

    // å¤„ç†é‚€è¯·é”™è¯¯
    _handleInvitationError(invitationResponse, targetUsername) {
        if (invitationResponse.error === 'TARGET_USER_OFFLINE') {
            this.showLinkNotification('warning', `${targetUsername} å½“å‰ä¸åœ¨çº¿ï¼Œè¯·ç¨åå†è¯•æˆ–é€šè¿‡å…¶ä»–æ–¹å¼è”ç³»å¯¹æ–¹`);
        } else {
            this.showLinkNotification('error', invitationResponse.message || invitationResponse.error || 'å‘é€é‚€è¯·å¤±è´¥');
        }
    },

    // è®¾ç½®æŒ‰é’®åŠ è½½çŠ¶æ€
    _setButtonLoading(btnEl, text) {
        btnEl.disabled = true;
        btnEl.textContent = text;
    },

    // é‡ç½®æŒ‰é’®çŠ¶æ€
    _resetButton(btnEl) {
        btnEl.disabled = false;
        btnEl.textContent = 'å‘é€å…³è”';
    },

    // é‡ç½®æŒ‰é’®çŠ¶æ€ï¼ˆé€šè¿‡IDæŸ¥æ‰¾ï¼‰
    _resetButtonState(supervisedUserId) {
        const btnEl = document.getElementById(`linkUserBtn-${supervisedUserId}`);
        if (btnEl) {
            this._resetButton(btnEl);
        }
    },
    
    // å‘é€WebSocketæ¶ˆæ¯å¹¶ç­‰å¾…å“åº”
    async sendWebSocketMessage(message) {
        return new Promise((resolve, reject) => {
            // æ£€æŸ¥WebSocketè¿æ¥ - ä¿®å¤å¯¹è±¡åç§°ä¸ä¸€è‡´é—®é¢˜
            if (!window.WebSocketClient || !window.WebSocketClient.isConnected) {
                reject(new Error('WebSocketæœªè¿æ¥'));
                return;
            }
            
            // ç”Ÿæˆæ¶ˆæ¯IDç”¨äºåŒ¹é…å“åº”
            const messageId = Date.now().toString();
            message.messageId = messageId;
            message.timestamp = Date.now();
            
            // è®¾ç½®å“åº”ç›‘å¬å™¨
            const responseType = `${message.type}_RESPONSE`;
            const timeoutId = setTimeout(() => {
                reject(new Error('è¯·æ±‚è¶…æ—¶'));
            }, 10000); // 10ç§’è¶…æ—¶
            
            const handleResponse = (event) => {
                try {
                    const response = JSON.parse(event.data);
                    if (response.type === responseType && response.messageId === messageId) {
                        clearTimeout(timeoutId);
                        window.WebSocketClient.ws.removeEventListener('message', handleResponse);
                        resolve(response);
                    }
                } catch (e) {
                    // å¿½ç•¥è§£æé”™è¯¯
                }
            };
            
            // ç›‘å¬å“åº”
            window.WebSocketClient.ws.addEventListener('message', handleResponse);
            
            // å‘é€æ¶ˆæ¯
            try {
                window.WebSocketClient.ws.send(JSON.stringify(message));
            } catch (error) {
                clearTimeout(timeoutId);
                window.WebSocketClient.ws.removeEventListener('message', handleResponse);
                reject(error);
            }
        });
    },
    
    // æ˜¾ç¤ºLinké€šçŸ¥
    showLinkNotification(type, message) {
        console.log(`ğŸ”” [SPA Link] æ˜¾ç¤º${type}é€šçŸ¥:`, message);
        
        // åˆ›å»ºé€šçŸ¥å…ƒç´ 
        const notification = document.createElement('div');
        notification.className = `link-notification link-notification-${type}`;
        notification.innerHTML = `
            <div class="link-notification-content">
                <div class="link-notification-icon">
                    ${type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}
                </div>
                <div class="link-notification-message">${message}</div>
                <button class="link-notification-close" onclick="this.parentElement.parentElement.remove()">Ã—</button>
            </div>
        `;
        
        // æ·»åŠ åˆ°é¡µé¢
        document.body.appendChild(notification);
        
        // è‡ªåŠ¨æ¶ˆå¤±
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    },
    
    // æ˜¾ç¤ºæ•°æ®åŒæ­¥é€šçŸ¥ï¼ˆæ›´è¯¦ç»†çš„æç¤ºï¼‰
    showDataSyncNotification(type, message) {
        console.log(`ğŸ”„ [æ•°æ®åŒæ­¥] æ˜¾ç¤º${type}é€šçŸ¥:`, message);
        
        // åˆ›å»ºæ›´è¯¦ç»†çš„é€šçŸ¥å…ƒç´ 
        const notification = document.createElement('div');
        notification.className = `data-sync-notification data-sync-notification-${type}`;
        notification.innerHTML = `
            <div class="data-sync-notification-content">
                <div class="data-sync-notification-header">
                    <div class="data-sync-notification-icon">
                        ${type === 'success' ? 'ğŸ‰' : type === 'info' ? 'ğŸ“Š' : type === 'warning' ? 'âš ï¸' : 'âŒ'}
                    </div>
                    <div class="data-sync-notification-title">æ•°æ®åŒæ­¥é€šçŸ¥</div>
                    <button class="data-sync-notification-close" onclick="this.parentElement.parentElement.parentElement.remove()">Ã—</button>
                </div>
                <div class="data-sync-notification-body">
                    <p>${message}</p>
                    <div class="data-sync-details">
                        <small>ğŸ“ è¿™æ„å‘³ç€TODOé¡¹ç›®ã€å¥åº·ç¬”è®°ç­‰æ•°æ®å·²å®ŒæˆåŒæ­¥</small>
                    </div>
                </div>
            </div>
        `;
        
        // æ·»åŠ åˆ°é¡µé¢
        document.body.appendChild(notification);
        
        // è¾ƒé•¿çš„æ˜¾ç¤ºæ—¶é—´ï¼Œå› ä¸ºåŒ…å«é‡è¦ä¿¡æ¯
        setTimeout(() => {
            if (notification.parentElement) {
                notification.classList.add('data-sync-fade-out');
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 500);
            }
        }, 8000);
    },
    
    // æ˜¾ç¤ºå…³è”é‚€è¯·å¯¹è¯æ¡†
    showLinkInvitationDialog(invitationData) {
        console.log('ğŸ”” [SPA Link] æ˜¾ç¤ºå…³è”é‚€è¯·å¯¹è¯æ¡†:', invitationData);
        
        const { fromUser, supervisedUserName, message, timestamp, expiresIn } = invitationData;
        
        // åˆ›å»ºæ¨¡æ€å¯¹è¯æ¡†
        const modal = document.createElement('div');
        modal.className = 'link-invitation-modal';
        modal.innerHTML = `
            <div class="link-invitation-dialog">
                <div class="link-invitation-header">
                    <div class="link-invitation-icon">ğŸ”—</div>
                    <h3>å…³è”é‚€è¯·</h3>
                </div>
                <div class="link-invitation-body">
                    <div class="link-invitation-from">
                        æ¥è‡ªï¼š<strong>${fromUser}</strong>
                    </div>
                    <div class="link-invitation-target">
                        å…³è”ç”¨æˆ·ï¼š<strong>${supervisedUserName}</strong>
                    </div>
                    <div class="link-invitation-message">
                        ${message}
                    </div>
                    <div class="link-invitation-time">
                        ${new Date(timestamp).toLocaleString()}
                    </div>
                </div>
                <div class="link-invitation-actions">
                    <button class="btn btn-success" onclick="App.respondToLinkInvitation('accept', '${fromUser}', '${supervisedUserName}', ${invitationData.requestId})">
                        æ¥å—
                    </button>
                    <button class="btn btn-secondary" onclick="App.respondToLinkInvitation('reject', '${fromUser}', '${supervisedUserName}', ${invitationData.requestId})">
                        æ‹’ç»
                    </button>
                </div>
                <div class="link-invitation-expire">
                    é‚€è¯·å°†åœ¨ ${Math.floor(expiresIn / 60000)} åˆ†é’Ÿåè¿‡æœŸ
                </div>
            </div>
        `;
        
        // æ·»åŠ åˆ°é¡µé¢
        document.body.appendChild(modal);
        
        // è‡ªåŠ¨è¿‡æœŸå¤„ç†
        setTimeout(() => {
            if (modal.parentElement) {
                modal.remove();
                console.log('â° [SPA Link] å…³è”é‚€è¯·å·²è¿‡æœŸ');
            }
        }, expiresIn);
    },
    
    // å“åº”å…³è”é‚€è¯·
    async respondToLinkInvitation(action, fromUser, supervisedUserName, requestId) {
        try {
            console.log(`ğŸ“ [SPA Link] å“åº”å…³è”é‚€è¯·: ${action}`, { fromUser, supervisedUserName, requestId });
            
            const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            if (!currentAppUser) {
                this.showLinkNotification('error', 'ç”¨æˆ·æœªç™»å½•');
                return;
            }
            
            // å‘é€å“åº”
            let response;
            try {
                if (window.WebSocketClient && window.WebSocketClient.isConnected) {
                    if (action === 'accept') {
                        response = await window.WebSocketClient.links.acceptInvitation(requestId);
                    } else {
                        response = await window.WebSocketClient.links.rejectInvitation(requestId);
                    }
                } else {
                    // HTTPé™çº§æ¨¡å¼
                    const apiResponse = await fetch(`/api/links/requests/${requestId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
                        },
                        body: JSON.stringify({
                            action: action,
                            appUser: currentAppUser
                        })
                    });
                    response = { success: apiResponse.ok, data: await apiResponse.json() };
                }
            } catch (error) {
                response = { success: false, error: error.message };
            }
            
            console.log('ğŸ“¨ [SPA Link] é‚€è¯·å“åº”ç»“æœ:', response);
            
            if (response.success) {
                if (action === 'accept') {
                    this.showLinkNotification('success', `å·²æ¥å—ä¸ ${fromUser} çš„å…³è”é‚€è¯·ï¼Œæ­£åœ¨åˆ·æ–°æ•°æ®...`);
                    
                    // ğŸ”¥ ä¿®å¤ï¼šä¸åœ¨è¿™é‡Œè°ƒç”¨ refreshApplicationAfterLinkï¼Œè®© WebSocket çš„ LINK_ESTABLISHED æ¶ˆæ¯å¤„ç†
                    console.log('âœ… [Link] é‚€è¯·æ¥å—æˆåŠŸï¼Œç­‰å¾… WebSocket LINK_ESTABLISHED æ¶ˆæ¯è§¦å‘æ•°æ®åˆ·æ–°');
                    
                } else {
                    this.showLinkNotification('info', `å·²æ‹’ç»ä¸ ${fromUser} çš„å…³è”é‚€è¯·`);
                }
            } else {
                this.showLinkNotification('error', response.error || 'å¤„ç†é‚€è¯·å¤±è´¥');
            }
            
            // å…³é—­å¯¹è¯æ¡†
            const modal = document.querySelector('.link-invitation-modal');
            if (modal) {
                modal.remove();
            }
            
        } catch (error) {
            console.error('âŒ [SPA Link] å“åº”é‚€è¯·å¤±è´¥:', error);
            this.showLinkNotification('error', 'å“åº”é‚€è¯·å¤±è´¥');
        }
    },
    
    // LinkæˆåŠŸååˆ·æ–°åº”ç”¨æ•°æ®
    async refreshApplicationAfterLink() {
        if (this._isDuplicateRefreshCall()) return;
        
        this._refreshingAfterLink = true;
        
        try {
            console.log('ğŸ”„ [Link] å¼€å§‹åˆ·æ–°åº”ç”¨æ•°æ®...');
            
            await this._refreshUserData();
            await this._refreshApplicationData();
            await this._navigateToLinkPage();
            await this._ensureDefaultUser();
            
            this.showLinkNotification('success', 'å…³è”å»ºç«‹æˆåŠŸï¼å·²è‡ªåŠ¨è·³è½¬åˆ°Linké¡µé¢æŸ¥çœ‹è¿æ¥çŠ¶æ€');
            console.log('âœ… [Link] åº”ç”¨æ•°æ®åˆ·æ–°å®Œæˆ');
            
        } catch (error) {
            console.error('âŒ [Link] åˆ·æ–°åº”ç”¨æ•°æ®å¤±è´¥:', error);
            this.showLinkNotification('error', 'æ•°æ®åˆ·æ–°å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°é¡µé¢');
        } finally {
            this._refreshingAfterLink = false;
        }
    },

    // æ£€æŸ¥æ˜¯å¦ä¸ºé‡å¤åˆ·æ–°è°ƒç”¨
    _isDuplicateRefreshCall() {
        if (this._refreshingAfterLink) {
            console.log('âš ï¸ [Link] æ•°æ®åˆ·æ–°å·²åœ¨è¿›è¡Œä¸­ï¼Œè·³è¿‡é‡å¤è°ƒç”¨');
            return true;
        }
        return false;
    },

    // åˆ·æ–°ç”¨æˆ·æ•°æ®
    async _refreshUserData() {
        if (window.UserManager && typeof UserManager.loadUsersFromAPI === 'function') {
            console.log('ğŸ”„ [Link] é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®...');
            await UserManager.loadUsersFromAPI();
            console.log('âœ… [Link] ç”¨æˆ·æ•°æ®é‡æ–°åŠ è½½å®Œæˆï¼Œç”¨æˆ·æ•°é‡:', UserManager.users?.length || 0);
            
            this._logLoadedUserData();
        }
        
        this._updateUserInterface();
    },

    // è®°å½•åŠ è½½çš„ç”¨æˆ·æ•°æ®
    _logLoadedUserData() {
        if (UserManager.users && UserManager.users.length > 0) {
            console.log('ğŸ” [Link] åŠ è½½çš„ç”¨æˆ·æ•°æ®:', UserManager.users.map(u => ({ 
                id: u.id, 
                username: u.username, 
                app_user_id: u.app_user_id 
            })));
        }
    },

    // æ›´æ–°ç”¨æˆ·ç•Œé¢
    _updateUserInterface() {
        if (window.UserManager && typeof UserManager.renderUserTabs === 'function') {
            console.log('ğŸ”„ [Link] é‡æ–°æ¸²æŸ“ç”¨æˆ·æ ‡ç­¾...');
            UserManager.renderUserTabs();
            console.log('âœ… [Link] ç”¨æˆ·æ ‡ç­¾é‡æ–°æ¸²æŸ“å®Œæˆ');
        }
        
        if (window.GlobalUserState) {
            console.log('ğŸ”„ [Link] æ›´æ–°å…¨å±€ç”¨æˆ·çŠ¶æ€...');
            GlobalUserState.updateUserSelectorUI();
            console.log('âœ… [Link] å…¨å±€ç”¨æˆ·çŠ¶æ€æ›´æ–°å®Œæˆ');
        }
    },

    // åˆ·æ–°åº”ç”¨æ•°æ®
    async _refreshApplicationData() {
        await this._refreshTodoData();
        await this._refreshNotesData();
    },

    // åˆ·æ–°TODOæ•°æ®
    async _refreshTodoData() {
        if (window.TodoManager) {
            console.log('ğŸ”„ [Link] é‡æ–°åŠ è½½TODOæ•°æ®...');
            await TodoManager.loadTodosFromAPI();
            console.log('âœ… [Link] TODOæ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
        }
    },

    // åˆ·æ–°Notesæ•°æ®
    async _refreshNotesData() {
        if (window.NotesManager) {
            console.log('ğŸ”„ [Link] é‡æ–°åŠ è½½Notesæ•°æ®...');
            await NotesManager.loadNotesFromAPI();
            console.log('âœ… [Link] Notesæ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
        }
    },

    // å¯¼èˆªåˆ°Linké¡µé¢
    async _navigateToLinkPage() {
        console.log('ğŸ”„ [Link] è‡ªåŠ¨è·³è½¬åˆ°Linké¡µé¢...');
        await this.showLinkPage();
    },

    // ç¡®ä¿æœ‰é»˜è®¤ç”¨æˆ·
    async _ensureDefaultUser() {
        if (UserManager.users && UserManager.users.length > 0 && window.GlobalUserState) {
            const currentUser = GlobalUserState.getCurrentUser();
            const userExists = UserManager.users.find(u => u.id === currentUser);
            
            if (!currentUser || !userExists) {
                this._setDefaultUser();
            } else {
                console.log('âœ… [Link] å½“å‰ç”¨æˆ·æœ‰æ•ˆ:', currentUser);
            }
        }
    },

    // è®¾ç½®é»˜è®¤ç”¨æˆ·
    _setDefaultUser() {
        const firstUser = UserManager.users[0];
        console.log('ğŸ”„ [Link] è®¾ç½®é»˜è®¤ç”¨æˆ·:', firstUser.username, 'ID:', firstUser.id);
        GlobalUserState.setCurrentUser(firstUser.id);
        
        setTimeout(() => {
            this._activateUserTab(firstUser);
        }, 500);
    },

    // æ¿€æ´»ç”¨æˆ·æ ‡ç­¾
    _activateUserTab(user) {
        const userTab = document.querySelector(`[data-user-id="${user.id}"]`);
        if (userTab) {
            document.querySelectorAll('.user-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            userTab.classList.add('active');
            console.log('âœ… [Link] ç”¨æˆ·æ ‡ç­¾å·²é€‰ä¸­:', user.username);
        }
    },
    
    // å¤„ç†æ•°æ®åŒæ­¥æ›´æ–°
    handleDataSyncUpdate(syncData) {
        try {
            console.log('ğŸ”„ [æ•°æ®åŒæ­¥] å¤„ç†åŒæ­¥æ›´æ–°:', syncData);
            
            // æ­£ç¡®è§£æ„åµŒå¥—çš„æ•°æ®ç»“æ„
            const { table, operation, data } = syncData.data || syncData;
            
            // æ˜¾ç¤ºåŒæ­¥é€šçŸ¥
            this.showDataSyncOperationNotification(operation, table, data);
            
            // æ ¹æ®æ•°æ®ç±»å‹åˆ·æ–°ç›¸åº”çš„ç•Œé¢
            if (table === 'todos' && window.TodoManager) {
                console.log('ğŸ”„ [æ•°æ®åŒæ­¥] åˆ·æ–°TODOæ•°æ®');
                
                // è·å–å½“å‰ç”¨æˆ·å’Œæ—¥æœŸ
                const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : null;
                const currentDate = window.DateManager ? DateManager.selectedDate : new Date();
                
                if (currentUserId) {
                    // æ¸…é™¤ç¼“å­˜å¹¶é‡æ–°åŠ è½½æ•°æ®
                    const dateStr = currentDate.toISOString().split('T')[0];
                    const cacheKey = `${currentUserId}_${dateStr}`;
                    if (TodoManager.todoCache) {
                        TodoManager.todoCache.delete(cacheKey);
                        console.log('ğŸ§¹ [æ•°æ®åŒæ­¥] æ¸…é™¤TODOç¼“å­˜:', cacheKey);
                    }
                    
                    // å»¶è¿Ÿä¸€ä¸‹å†åˆ·æ–°ï¼Œç¡®ä¿æœåŠ¡å™¨æ•°æ®å·²åŒæ­¥
                    setTimeout(async () => {
                        try {
                            await TodoManager.loadTodosForDate(currentDate, currentUserId);
                            console.log('âœ… [æ•°æ®åŒæ­¥] TODOæ•°æ®åˆ·æ–°å®Œæˆ');
                        } catch (error) {
                            console.error('âŒ [æ•°æ®åŒæ­¥] TODOæ•°æ®åˆ·æ–°å¤±è´¥:', error);
                        }
                    }, 500);
                }
                
            } else if (table === 'notes' && window.NotesManager) {
                console.log('ğŸ”„ [æ•°æ®åŒæ­¥] åˆ·æ–°Notesæ•°æ®');
                
                const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : null;
                if (currentUserId) {
                    setTimeout(async () => {
                        try {
                            await NotesManager.loadNotesFromAPI();
                            if (GlobalUserState.getCurrentModule() === 'notes') {
                                NotesManager.renderNotesPanel(currentUserId);
                            }
                            console.log('âœ… [æ•°æ®åŒæ­¥] Notesæ•°æ®åˆ·æ–°å®Œæˆ');
                        } catch (error) {
                            console.error('âŒ [æ•°æ®åŒæ­¥] Notesæ•°æ®åˆ·æ–°å¤±è´¥:', error);
                        }
                    }, 500);
                }
            }
            
        } catch (error) {
            console.error('âŒ [æ•°æ®åŒæ­¥] å¤„ç†åŒæ­¥æ›´æ–°å¤±è´¥:', error);
        }
    },
    
    // æ˜¾ç¤ºæ•°æ®åŒæ­¥æ“ä½œé€šçŸ¥
    showDataSyncOperationNotification(operation, table, data = {}) {
        const tableNames = {
            'todos': 'TODO',
            'notes': 'Notes'
        };
        
        const operationNames = {
            'create': 'æ–°å¢',
            'update': 'æ›´æ–°', 
            'delete': 'åˆ é™¤',
            'complete': 'å®Œæˆ',
            'uncomplete': 'å–æ¶ˆå®Œæˆ'
        };
        
        const tableName = tableNames[table] || table;
        const operationName = operationNames[operation] || operation;
        const itemTitle = data.title ? `"${data.title}"` : '';
        
        // åˆ›å»ºåŒæ­¥é€šçŸ¥
        const notification = document.createElement('div');
        notification.className = 'data-sync-notification';
        notification.innerHTML = `
            <div class="data-sync-content">
                <div class="data-sync-icon">ğŸ”„</div>
                <div class="data-sync-message">
                    å…³è”ç”¨æˆ·${operationName}äº†${tableName}${itemTitle}ï¼Œæ­£åœ¨åŒæ­¥...
                </div>
            </div>
        `;
        
        // æ·»åŠ åˆ°é¡µé¢
        document.body.appendChild(notification);
        
        // æ˜¾ç¤ºåŠ¨ç”»
        setTimeout(() => notification.classList.add('show'), 100);
        
        // è‡ªåŠ¨æ¶ˆå¤±
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentElement) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, 3000);
    },
    
    // ç¡®è®¤å–æ¶ˆå…³è”
    confirmUnlink(supervisedUserId, linkId, linkedUser) {
        console.log('ğŸ”— [SPA Link] ç¡®è®¤å–æ¶ˆå…³è”:', { supervisedUserId, linkId, linkedUser });
        
        // åˆ›å»ºç¡®è®¤å¯¹è¯æ¡†
        const modal = document.createElement('div');
        modal.className = 'link-unlink-modal';
        modal.innerHTML = `
            <div class="link-unlink-dialog">
                <div class="link-unlink-header">
                    <div class="link-unlink-icon">âš ï¸</div>
                    <h3>ç¡®è®¤å–æ¶ˆå…³è”</h3>
                </div>
                <div class="link-unlink-body">
                    <p>æ‚¨ç¡®å®šè¦å–æ¶ˆä¸ <strong>${linkedUser}</strong> çš„å…³è”å…³ç³»å—ï¼Ÿ</p>
                    <div class="link-unlink-warning">
                        âš ï¸ å–æ¶ˆå…³è”åï¼š
                        <ul>
                            <li>å¯¹æ–¹å°†æ— æ³•ç»§ç»­ç®¡ç†è¯¥ç”¨æˆ·çš„å¥åº·æ•°æ®</li>
                            <li>æ•°æ®åŒæ­¥å°†åœæ­¢</li>
                            <li>éœ€è¦é‡æ–°å‘é€é‚€è¯·æ‰èƒ½æ¢å¤å…³è”</li>
                        </ul>
                    </div>
                </div>
                <div class="link-unlink-actions">
                    <button class="btn btn-danger" onclick="App.executeUnlink(${supervisedUserId}, ${linkId}, '${linkedUser}')">
                        ç¡®è®¤å–æ¶ˆ
                    </button>
                    <button class="btn btn-secondary" onclick="this.parentElement.parentElement.parentElement.remove()">
                        å–æ¶ˆ
                    </button>
                </div>
            </div>
        `;
        
        // æ·»åŠ åˆ°é¡µé¢
        document.body.appendChild(modal);
    },
    
    // æ‰§è¡Œå–æ¶ˆå…³è”
    async executeUnlink(supervisedUserId, linkId, linkedUser) {
        try {
            console.log('ğŸ”— [SPA Link] æ‰§è¡Œå–æ¶ˆå…³è”:', { supervisedUserId, linkId, linkedUser });
            
            const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            if (!currentAppUser) {
                this.showLinkNotification('error', 'ç”¨æˆ·æœªç™»å½•');
                return;
            }
            
            // å‘é€å–æ¶ˆå…³è”è¯·æ±‚
            let response;
            try {
                if (window.WebSocketClient && window.WebSocketClient.isConnected) {
                    response = await window.WebSocketClient.links.cancelLink(linkId);
                } else {
                    // HTTPé™çº§æ¨¡å¼
                    const apiResponse = await fetch(`/api/links/${linkId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
                        },
                        body: JSON.stringify({
                            appUser: currentAppUser
                        })
                    });
                    const responseData = await apiResponse.json();
                    response = { success: apiResponse.ok, data: responseData };
                }
            } catch (error) {
                response = { success: false, error: error.message };
            }
            
            console.log('ğŸ”— [SPA Link] å–æ¶ˆå…³è”ç»“æœ:', response);
            
            if (response.success) {
                this.showLinkNotification('success', `å·²å–æ¶ˆä¸ ${linkedUser} çš„å…³è”`);
                
                // å…³é—­ç¡®è®¤å¯¹è¯æ¡†
                const modal = document.querySelector('.link-unlink-modal');
                if (modal) {
                    modal.remove();
                }
                
                // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®å’ŒLinké¡µé¢
                setTimeout(async () => {
                    try {
                        // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
                        if (window.UserManager) {
                            await UserManager.loadUsersFromAPI();
                        }
                        
                        // é‡æ–°åŠ è½½LinkåŠŸèƒ½å†…å®¹ï¼Œæ˜¾ç¤ºå‘é€å…³è”ç•Œé¢
                        const user = window.UserManager?.users?.find(u => u.id === supervisedUserId);
                        if (user) {
                            this.displayUserInfoInLink(user);
                        }
                        
                        // é‡æ–°æ£€æŸ¥å…³è”çŠ¶æ€
                        await this.displayLinkConnectionStatus();
                    } catch (error) {
                        console.error('é‡æ–°åŠ è½½æ•°æ®å¤±è´¥:', error);
                    }
                }, 1000);
                
            } else {
                this.showLinkNotification('error', response.data?.message || response.error || 'å–æ¶ˆå…³è”å¤±è´¥');
            }
            
        } catch (error) {
            console.error('âŒ [SPA Link] å–æ¶ˆå…³è”å¤±è´¥:', error);
            this.showLinkNotification('error', 'å–æ¶ˆå…³è”å¤±è´¥');
        }
    },

    // å¤„ç†LinkçŠ¶æ€å˜æ›´é€šçŸ¥
    handleLinkStatusChange(type, data) {
        console.log(`ğŸ”— [SPA Link] å¤„ç†LinkçŠ¶æ€å˜æ›´:`, type, data);
        
        switch (type) {
            case 'LINK_INVITATION_ACCEPTED':
                this.showLinkNotification('success', `${data.acceptedBy} æ¥å—äº†æ‚¨çš„å…³è”é‚€è¯·`);
                break;
                
            case 'LINK_INVITATION_REJECTED':
                this.showLinkNotification('info', `${data.rejectedBy} æ‹’ç»äº†æ‚¨çš„å…³è”é‚€è¯·`);
                break;
                
            case 'LINK_ESTABLISHED':
                this.showLinkNotification('success', `ä¸ ${data.linkedUser} çš„å…³è”å·²å»ºç«‹`);
                
                // å¦‚æœæœ‰æ•°æ®åŒæ­¥æç¤ºï¼Œæ˜¾ç¤ºè¯¦ç»†é€šçŸ¥
                if (data.syncMessage) {
                    setTimeout(() => {
                        this.showDataSyncNotification('info', data.syncMessage);
                    }, 2000);
                }
                
                // å¦‚æœå½“å‰åœ¨Linké¡µé¢ï¼Œåˆ·æ–°æ˜¾ç¤º
                if (document.querySelector('.link-content-area')) {
                    setTimeout(async () => {
                        try {
                            // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
                            if (window.UserManager) {
                                await UserManager.loadUsersFromAPI();
                            }
                            
                            // é‡æ–°æ£€æŸ¥å…³è”çŠ¶æ€
                            await this.displayLinkConnectionStatus();
                            
                            // å¦‚æœæœ‰é€‰ä¸­çš„ç”¨æˆ·ï¼Œé‡æ–°æ˜¾ç¤ºè¯¥ç”¨æˆ·ä¿¡æ¯
                            const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                            if (currentUser) {
                                const user = window.UserManager?.users?.find(u => u.id === currentUser);
                                if (user) {
                                    this.displayUserInfoInLink(user);
                                }
                            }
                        } catch (error) {
                            console.error('å¤„ç†å…³è”å»ºç«‹é€šçŸ¥æ—¶é‡æ–°åŠ è½½æ•°æ®å¤±è´¥:', error);
                        }
                    }, 1000);
                }
                break;
                
            case 'LINK_ACCEPTED':
                this.showLinkNotification('success', `${data.acceptedBy} æ¥å—äº†æ‚¨çš„å…³è”é‚€è¯·`);
                
                // ğŸ”¥ ä¿®å¤ï¼šåƒå–æ¶ˆå…³è”ä¸€æ ·ï¼Œå…ˆæ£€æŸ¥æ˜¯å¦åœ¨Linké¡µé¢
                if (document.querySelector('.link-content-area')) {
                    // å¦‚æœå½“å‰åœ¨Linké¡µé¢ï¼Œç›´æ¥æ›´æ–°é¡µé¢çŠ¶æ€ï¼ˆå’ŒLINK_CANCELLEDä¿æŒä¸€è‡´ï¼‰
                    console.log('âœ… [Link] å‘èµ·æ–¹å½“å‰åœ¨Linké¡µé¢ï¼Œç›´æ¥æ›´æ–°é¡µé¢çŠ¶æ€');
                    setTimeout(async () => {
                        try {
                            // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
                            if (window.UserManager) {
                                await UserManager.loadUsersFromAPI();
                            }
                            
                            // é‡æ–°æ£€æŸ¥å…³è”çŠ¶æ€
                            await this.displayLinkConnectionStatus();
                            
                            // å¦‚æœæœ‰é€‰ä¸­çš„ç”¨æˆ·ï¼Œé‡æ–°æ˜¾ç¤ºè¯¥ç”¨æˆ·ä¿¡æ¯
                            const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                            console.log('ğŸ” [Link] LINK_ACCEPTED å¤„ç† - å½“å‰é€‰ä¸­ç”¨æˆ·ID:', currentUser);
                            console.log('ğŸ” [Link] LINK_ACCEPTED å¤„ç† - å¯ç”¨ç”¨æˆ·åˆ—è¡¨:', window.UserManager?.users?.map(u => ({id: u.id, username: u.username})));
                            
                            if (currentUser) {
                                const user = window.UserManager?.users?.find(u => u.id === currentUser);
                                console.log('ğŸ” [Link] LINK_ACCEPTED å¤„ç† - æ‰¾åˆ°çš„ç”¨æˆ·:', user);
                                if (user) {
                                    console.log('ğŸ”„ [Link] LINK_ACCEPTED å¤„ç† - å¼€å§‹è°ƒç”¨ displayUserInfoInLink...');
                                    this.displayUserInfoInLink(user);
                                } else {
                                    console.error('âŒ [Link] LINK_ACCEPTED å¤„ç† - æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„ç”¨æˆ·å¯¹è±¡');
                                }
                            } else {
                                console.error('âŒ [Link] LINK_ACCEPTED å¤„ç† - å½“å‰æ²¡æœ‰é€‰ä¸­çš„ç”¨æˆ·');
                            }
                        } catch (error) {
                            console.error('å¤„ç†å…³è”æ¥å—é€šçŸ¥æ—¶æ›´æ–°Linké¡µé¢å¤±è´¥:', error);
                        }
                    }, 1000);
                } else {
                    // å¦‚æœä¸åœ¨Linké¡µé¢ï¼Œè·³è½¬åˆ°Linké¡µé¢
                    console.log('âœ… [Link] å‘èµ·æ–¹ä¸åœ¨Linké¡µé¢ï¼Œè·³è½¬å¹¶åˆ·æ–°åº”ç”¨æ•°æ®');
                    setTimeout(async () => {
                        await this.refreshApplicationAfterLink();
                    }, 1000);
                }
                
                // æ˜¾ç¤ºæ•°æ®åŒæ­¥å®Œæˆæç¤º
                if (data.syncMessage) {
                    setTimeout(() => {
                        this.showDataSyncNotification('success', data.syncMessage);
                    }, 3000); // å»¶è¿Ÿä¸€ç‚¹é¿å…ä¸é¡µé¢æ“ä½œå†²çª
                }
                break;
                
            case 'LINK_CANCELLED':
                this.showLinkNotification('warning', `${data.cancelledBy} å·²å–æ¶ˆå…³è”å…³ç³»`);
                // å¦‚æœå½“å‰åœ¨Linké¡µé¢ï¼Œåˆ·æ–°é¡µé¢æ˜¾ç¤ºå‘é€å…³è”ç•Œé¢
                if (document.querySelector('.link-content-area')) {
                    setTimeout(async () => {
                        try {
                            // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
                            if (window.UserManager) {
                                await UserManager.loadUsersFromAPI();
                            }
                            
                            // é‡æ–°æ£€æŸ¥å…³è”çŠ¶æ€
                            await this.displayLinkConnectionStatus();
                            
                            // å¦‚æœæœ‰é€‰ä¸­çš„ç”¨æˆ·ï¼Œé‡æ–°æ˜¾ç¤ºè¯¥ç”¨æˆ·ä¿¡æ¯
                            const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                            if (currentUser) {
                                const user = window.UserManager?.users?.find(u => u.id === currentUser);
                                if (user) {
                                    this.displayUserInfoInLink(user);
                                }
                            }
                        } catch (error) {
                            console.error('å¤„ç†å…³è”å–æ¶ˆé€šçŸ¥æ—¶é‡æ–°åŠ è½½æ•°æ®å¤±è´¥:', error);
                        }
                    }, 1000);
                }
                break;
                
            default:
                console.log('âš ï¸ [SPA Link] æœªå¤„ç†çš„LinkçŠ¶æ€ç±»å‹:', type);
        }
    },
    
    // æ˜¾ç¤ºé»˜è®¤é€‰ä¸­ç”¨æˆ·çš„ä¿¡æ¯
    displayDefaultUserInLink() {
        console.log('ğŸ” [SPA Link] æ£€æŸ¥é»˜è®¤é€‰ä¸­ç”¨æˆ·...');
        
        const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : null;
        if (currentUserId && window.UserManager && window.UserManager.users) {
            const selectedUser = window.UserManager.users.find(user => user.id === currentUserId);
            if (selectedUser) {
                console.log('ğŸ‘¤ [SPA Link] æ‰¾åˆ°é»˜è®¤ç”¨æˆ·ï¼Œæ˜¾ç¤ºä¿¡æ¯:', selectedUser.username);
                this.displayUserInfoInLink(selectedUser);
            } else {
                console.log('âš ï¸ [SPA Link] æœªæ‰¾åˆ°é»˜è®¤ç”¨æˆ·å¯¹è±¡');
            }
        } else {
            console.log('â„¹ï¸ [SPA Link] æ²¡æœ‰é»˜è®¤ç”¨æˆ·æˆ–ç”¨æˆ·ç®¡ç†å™¨æœªå°±ç»ª');
        }
    },

    // åº”ç”¨çŠ¶æ€ç®¡ç†
    getState() {
        return {
            currentUser: TodoManager.currentUser,
            selectedDate: DateManager.selectedDate,
            todos: TodoManager.todos,
            users: UserManager.users,
            weather: WeatherManager.weatherData
        };
    },

    // é‡ç½®åº”ç”¨
    reset() {
        DialogUtils.showWarning('é‡ç½®åŠŸèƒ½å·²ç¦ç”¨ï¼Œåº”ç”¨å®Œå…¨ä¾èµ–æœåŠ¡å™¨æ•°æ®ã€‚', 'åŠŸèƒ½æç¤º');
    },

    // å¯¼å‡ºæ•°æ®
    exportData() {
        const data = {
            version: '1.0',
            exportTime: new Date().toISOString(),
            ...this.getState()
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `wenting_backup_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
    },

    // å¯¼å…¥æ•°æ®
    importData(fileInput) {
        const file = fileInput.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                
                if (data.version && data.todos) {
                    // å¯¼å…¥æ•°æ®
                    if (data.todos) TodoManager.todos = data.todos;
                    if (data.users) UserManager.users = data.users;
                    if (data.weather) WeatherManager.weatherData = data.weather;
                    
                    // ä¿å­˜æ•°æ®
                    TodoManager.saveTodos();
                    UserManager.saveUsers();
                    WeatherManager.saveWeatherData();
                    
                    DialogUtils.showSuccess('æ•°æ®å¯¼å…¥æˆåŠŸï¼é¡µé¢å°†åˆ·æ–°ã€‚').then(() => {
                        location.reload();
                    });
                } else {
                    DialogUtils.showError('æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶æ ¼å¼', 'å¯¼å…¥å¤±è´¥');
                }
            } catch (error) {
                DialogUtils.showError('å¯¼å…¥å¤±è´¥ï¼š' + error.message, 'å¯¼å…¥å¤±è´¥');
            }
        };
        reader.readAsText(file);
    },

    // ğŸ”¥ æ–°å¢ï¼šç¡®ä¿WebSocketæ³¨å†Œçš„æ–¹æ³•
    ensureWebSocketRegistration() {
        let attempts = 0;
        const MAX_ATTEMPTS = 10;
        const CHECK_INTERVAL = 500; // 500ms

        const tryRegistration = () => {
            attempts++;
            console.log(`ğŸ”„ [WebSocket] å°è¯•æ³¨å†Œ (${attempts}/${MAX_ATTEMPTS})`);

            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;
            const userId = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;

            console.log('ğŸ” [WebSocket] æ³¨å†Œä¿¡æ¯æ£€æŸ¥:', { deviceId, appUserId, userId });

            if (deviceId && appUserId) {
                console.log('âœ… [WebSocket] æ³¨å†Œä¿¡æ¯å®Œæ•´ï¼Œå‘é€æ³¨å†Œæ¶ˆæ¯');
                WebSocketClient.sendRegistrationMessage();
                return;
            }

            if (attempts < MAX_ATTEMPTS) {
                console.log(`â³ [WebSocket] æ³¨å†Œä¿¡æ¯ä¸å®Œæ•´ï¼Œ${CHECK_INTERVAL}msåé‡è¯•...`);
                setTimeout(tryRegistration, CHECK_INTERVAL);
            } else {
                console.error('âŒ [WebSocket] è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ³¨å†Œå¤±è´¥');
                console.log('ğŸ’¡ [WebSocket] è¯·æ£€æŸ¥ç”¨æˆ·ç™»å½•çŠ¶æ€å’Œè®¾å¤‡IDç”Ÿæˆ');
            }
        };

        // ç«‹å³å°è¯•ä¸€æ¬¡ï¼Œç„¶åæ ¹æ®éœ€è¦é‡è¯•
        tryRegistration();
    }
};

// å¯åŠ¨åº”ç”¨
App.init();

// å°†Appæš´éœ²åˆ°å…¨å±€ï¼Œæ–¹ä¾¿è°ƒè¯•
window.App = App;

// è°ƒè¯•æ–¹æ³•ï¼šæ¸…é™¤ä½ç½®ç¼“å­˜å¹¶é‡æ–°è·å–
window.debugClearLocation = function() {
    console.log('ğŸ”§ è°ƒè¯•ï¼šæ¸…é™¤ä½ç½®ç¼“å­˜å¹¶é‡æ–°è·å–');
    WeatherManager.clearLocationCache();
    WeatherManager.getCurrentLocation().then(() => {
        WeatherManager.fetchRealWeatherData();
        WeatherManager.updateWeatherDisplay();
    });
};
