

// 应用配置
const APP_CONFIG = {

    // 天气配置
    weather: {
        location: '深圳',
        icon: '☀️',
        condition: '晴朗',
        temperature: '22°C',
        wind: {
            level: '3级',
            label: '风力'
        },
        humidity: {
            value: '65%',
            label: '湿度'
        }
    }
};


// 工具函数
const Utils = {
    // DOM选择器 - 单个元素
    $: (selector) => {
        return document.querySelector(selector);
    },

    // DOM选择器 - 多个元素
    $$: (selector) => {
        return Array.from(document.querySelectorAll(selector));
    },

    // 格式化日期
    formatDate: (date) => {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        return {
            month: months[date.getMonth()],
            date: date.getDate(),
            weekday: weekdays[date.getDay()],
            full: `${months[date.getMonth()]} ${date.getDate()}`
        };
    },

    // 计算日期范围
    calculateDateRange: (periodText) => {
        const now = new Date();
        let endDate = new Date(now);
        
        if (periodText.includes('周')) {
            const weeks = parseInt(periodText);
            endDate.setDate(now.getDate() + weeks * 7 - 1);
        } else if (periodText.includes('个月')) {
            const months_count = parseInt(periodText);
            endDate.setMonth(now.getMonth() + months_count);
            endDate.setDate(now.getDate() - 1);
        } else {
            return ''; // 对于"每日"等不需要显示日期范围
        }
        
        const startMonth = now.getMonth() + 1;
        const startDay = now.getDate();
        const endMonth = endDate.getMonth() + 1;
        const endDay = endDate.getDate();
        
        return `${startMonth}/${startDay}-${endMonth}/${endDay}`;
    },

    // 生成唯一ID
    generateId: () => {
        return 'id_' + Math.random().toString(36).substr(2, 9);
    },

    // 防抖函数
    debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    // 深拷贝
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Array) return obj.map(item => Utils.deepClone(item));
        if (typeof obj === 'object') {
            const clonedObj = {};
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    clonedObj[key] = Utils.deepClone(obj[key]);
                }
            }
            return clonedObj;
        }
    },

    // 节流函数
    throttle: (func, limit) => {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },

    // HTML转义函数，防止XSS攻击
    escapeHtml: (text) => {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
};


// 设备管理器 - 基于设备指纹的设备识别
const DeviceManager = {
    deviceId: null,
    deviceInfo: null,

    // 初始化设备管理器
    init() {
        console.log('🔧 初始化设备管理器...');
        this.deviceId = this.getOrCreateDeviceId();
        this.deviceInfo = this.getDeviceInfo();
        
        console.log('📱 设备ID:', this.deviceId);
        console.log('📊 设备信息:', this.deviceInfo);
        
        // 在页面上显示设备信息（调试用）
        this.displayDeviceInfo();
        
        return this.deviceId;
    },

    // 获取或创建设备ID
    getOrCreateDeviceId() {
        // 先尝试从localStorage获取已存在的设备ID
        let deviceId = localStorage.getItem('wenting_device_id');
        
        if (deviceId) {
            console.log('📱 找到已存在的设备ID:', deviceId);
            return deviceId;
        }
        
        // 如果没有，则生成新的设备ID
        deviceId = this.generateDeviceId();
        localStorage.setItem('wenting_device_id', deviceId);
        
        console.log('🆕 生成新的设备ID:', deviceId);
        return deviceId;
    },

    // 生成设备指纹ID
    generateDeviceId() {
        const fingerprint = this.generateDeviceFingerprint();
        
        // 使用指纹生成一个相对稳定的设备ID
        const deviceId = this.hashString(fingerprint);
        
        console.log('🔍 设备指纹:', fingerprint);
        console.log('🆔 生成的设备ID:', deviceId);
        
        return deviceId;
    },

    // 生成设备指纹
    generateDeviceFingerprint() {
        const components = [];
        
        // 1. 用户代理字符串
        components.push(navigator.userAgent);
        
        // 2. 屏幕分辨率
        components.push(`${screen.width}x${screen.height}`);
        
        // 3. 屏幕色深
        components.push(screen.colorDepth.toString());
        
        // 4. 时区偏移
        components.push(new Date().getTimezoneOffset().toString());
        
        // 5. 语言设置
        components.push(navigator.language || navigator.userLanguage || 'unknown');
        
        // 6. 平台信息
        components.push(navigator.platform);
        
        // 7. 是否支持触摸
        components.push(('ontouchstart' in window).toString());
        
        // 8. 设备内存（如果支持）
        if (navigator.deviceMemory) {
            components.push(navigator.deviceMemory.toString());
        }
        
        // 9. 硬件并发数
        if (navigator.hardwareConcurrency) {
            components.push(navigator.hardwareConcurrency.toString());
        }
        
        // 10. Canvas指纹（简化版）
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Device fingerprint test 🔍', 2, 2);
            components.push(canvas.toDataURL());
        } catch (e) {
            components.push('canvas-error');
        }
        
        return components.join('|');
    },

    // 简单的字符串哈希函数
    hashString(str) {
        let hash = 0;
        if (str.length === 0) return hash.toString();
        
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 转换为32位整数
        }
        
        // 转换为正数并添加前缀
        const deviceId = 'device_' + Math.abs(hash).toString(16);
        return deviceId;
    },

    // 获取设备信息
    getDeviceInfo() {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTablet = /iPad|Android(?!.*Mobile)/i.test(navigator.userAgent);
        
        let deviceType = 'desktop';
        if (isTablet) {
            deviceType = 'tablet';
        } else if (isMobile) {
            deviceType = 'mobile';
        }
        
        return {
            type: deviceType,
            isMobile: isMobile,
            isTablet: isTablet,
            isDesktop: !isMobile && !isTablet,
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            screen: {
                width: screen.width,
                height: screen.height,
                colorDepth: screen.colorDepth
            },
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };
    },

    // 在页面上显示设备信息（调试用）
    displayDeviceInfo() {
        // 在天气栏添加设备标识
        const locationElement = document.querySelector('.weather-location');
        if (locationElement && this.deviceInfo) {
            const deviceTypeIcon = this.getDeviceTypeIcon();
            const shortDeviceId = this.deviceId.substring(this.deviceId.length - 6);
            
            // 在位置信息后添加设备标识
            const originalTitle = locationElement.title || '';
            locationElement.title = `${originalTitle}\n设备: ${deviceTypeIcon} ${this.deviceInfo.type} (${shortDeviceId})`;
            
            // 可选：在位置文本后添加设备图标
            if (locationElement.textContent && !locationElement.textContent.includes('📱') && !locationElement.textContent.includes('💻')) {
                locationElement.textContent += ` ${deviceTypeIcon}`;
            }
        }
        
        console.log('📱 设备信息已显示在天气栏');
    },

    // 获取设备类型图标
    getDeviceTypeIcon() {
        switch (this.deviceInfo.type) {
            case 'mobile':
                return '📱';
            case 'tablet':
                return '📱';
            case 'desktop':
            default:
                return '💻';
        }
    },

    // 获取当前设备ID
    getCurrentDeviceId() {
        return this.deviceId;
    },

    // 获取设备信息
    getDeviceInformation() {
        return this.deviceInfo;
    },

    // 重置设备ID（调试用）
    resetDeviceId() {
        localStorage.removeItem('wenting_device_id');
        console.log('🔄 设备ID已重置，请刷新页面');
        return this.init();
    },

    // 检查是否为新设备
    isNewDevice() {
        return !localStorage.getItem('wenting_device_id');
    }
};

// 导出到全局
window.DeviceManager = DeviceManager;

// 调试方法
window.debugResetDevice = function() {
    console.log('🔧 调试：重置设备ID');
    DeviceManager.resetDeviceId();
    location.reload();
};

window.debugShowDeviceInfo = function() {
    console.log('📱 当前设备信息:');
    console.log('  设备ID:', DeviceManager.getCurrentDeviceId());
    console.log('  设备信息:', DeviceManager.getDeviceInformation());
};


// API客户端 - 连接前端和后端
const ApiClient = {
    // 动态获取API基础URL
    get baseURL() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol;
        let apiHost;

        // 自动适配 cloudflare tunnel 的 https 域名
        if (protocol === 'https:' && hostname.endsWith('.trycloudflare.com')) {
            // 直接用当前域名的 https，且不加端口
            apiHost = `https://${hostname}`;
        } else if (hostname === '192.168.3.5') {
            apiHost = 'http://192.168.3.5:3001';
        } else if (hostname === 'localhost' || hostname === '127.0.0.1') {
            apiHost = 'http://localhost:3001';
        } else {
            // 默认使用当前主机的3001端口
            apiHost = `http://${hostname}:3001`;
        }

        return `${apiHost}/api`;
    },
    
    // 通用请求方法
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        
        // 添加设备ID和当前登录用户到请求头
        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const currentAppUser = localStorage.getItem('wenting_current_app_user');
        
        const config = {
            headers: {
                'Content-Type': 'application/json',
                'X-Device-ID': deviceId,
                'X-App-User': currentAppUser,
                ...options.headers
            },
            ...options
        };

        if (config.body && typeof config.body === 'object') {
            config.body = JSON.stringify(config.body);
        }

        try {
            console.log('🌐 发送API请求:', url, config);
            const response = await fetch(url, config);
            console.log('📡 收到响应:', response.status, response.statusText);
            
            let data;
            try {
                data = await response.json();
                console.log('📄 响应数据:', data);
            } catch (jsonError) {
                console.error('JSON解析失败:', jsonError);
                throw new Error('服务器响应格式错误');
            }
            
            if (!response.ok) {
                let errorMessage = data.message || `HTTP error! status: ${response.status}`;
                
                // 如果有详细的验证错误，显示它们
                if (data.errors && Array.isArray(data.errors)) {
                    errorMessage += ': ' + data.errors.join(', ');
                }
                
                console.error('❌ API请求失败:', errorMessage);
                console.error('❌ 完整错误信息:', data);
                throw new Error(errorMessage);
            }
            
            return data;
        } catch (error) {
            console.error('❌ API请求异常:', error);
            
            // 处理网络错误
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
                throw new Error('网络连接失败，请检查服务器是否运行');
            }
            
            throw error;
        }
    },

    // GET请求
    async get(endpoint) {
        return this.request(endpoint, { method: 'GET' });
    },

    // POST请求
    async post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            body: data
        });
    },

    // PUT请求
    async put(endpoint, data) {
        return this.request(endpoint, {
            method: 'PUT',
            body: data
        });
    },

    // DELETE请求
    async delete(endpoint) {
        return this.request(endpoint, { method: 'DELETE' });
    },

    // 用户相关API
    users: {
        // 获取所有用户（按设备和注册用户过滤）
        async getAll() {
            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = localStorage.getItem('wenting_current_app_user');
            
            console.log('🔍 ApiClient.users.getAll 调试信息:');
            console.log('  - deviceId:', deviceId);
            console.log('  - appUserId:', appUserId);
            console.log('  - localStorage keys:', Object.keys(localStorage));
            
            if (!deviceId) {
                console.error('❌ 设备ID未初始化');
                throw new Error('设备ID未初始化，请刷新页面重试');
            }
            
            if (!appUserId) {
                console.error('❌ 用户未登录，跳转到登录页');
                // 自动跳转到登录页
                window.location.href = 'login.html';
                throw new Error('用户未登录，正在跳转到登录页...');
            }
            
            const url = `/users?device_id=${encodeURIComponent(deviceId)}&app_user_id=${encodeURIComponent(appUserId)}`;
            console.log('📡 发送用户列表请求:', url);
            
            return ApiClient.get(url);
        },

        // 根据ID获取用户
        async getById(id) {
            return ApiClient.get(`/users/${id}`);
        },

        // 创建用户
        async create(userData) {
            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = localStorage.getItem('wenting_current_app_user');
            
            console.log('🔍 ApiClient.users.create 调试信息:');
            console.log('  - deviceId:', deviceId);
            console.log('  - appUserId:', appUserId);
            
            if (!deviceId) {
                console.error('❌ 设备ID未初始化');
                throw new Error('设备ID未初始化，请刷新页面重试');
            }
            
            if (!appUserId) {
                console.error('❌ 用户未登录，跳转到登录页');
                // 自动跳转到登录页
                window.location.href = 'login.html';
                throw new Error('用户未登录，正在跳转到登录页...');
            }
            
            // 添加设备ID和注册用户ID到用户数据
            const userDataWithDevice = {
                ...userData,
                device_id: deviceId,
                app_user_id: appUserId
            };
            
            console.log('📤 发送创建用户请求，数据:', userDataWithDevice);
            
            return ApiClient.post('/users', userDataWithDevice);
        },

        // 更新用户
        async update(id, userData) {
            return ApiClient.put(`/users/${id}`, userData);
        },

        // 删除用户
        async delete(id) {
            return ApiClient.delete(`/users/${id}`);
        },

        // 获取用户设置
        async getSettings(id) {
            return ApiClient.get(`/users/${id}/settings`);
        },

        // 更新用户设置
        async updateSettings(id, settings) {
            return ApiClient.put(`/users/${id}/settings`, settings);
        }
    },

    // TODO相关API
    todos: {
        // 获取用户的所有TODO
        async getByUserId(userId) {
            return ApiClient.get(`/todos/user/${userId}`);
        },

        // 获取用户今日TODO
        async getTodayTodos(userId) {
            return ApiClient.get(`/todos/user/${userId}/today`);
        },

        // 获取用户指定日期的TODO
        async getTodosForDate(userId, date) {
            return ApiClient.get(`/todos/user/${userId}/date/${date}`);
        },

        // 根据ID获取TODO
        async getById(id) {
            return ApiClient.get(`/todos/${id}`);
        },

        // 创建TODO
        async create(todoData) {
            return ApiClient.post('/todos', todoData);
        },

        // 更新TODO
        async update(id, todoData) {
            return ApiClient.put(`/todos/${id}`, todoData);
        },

        // 删除TODO
        async delete(id, deletionType = 'all', deletionDate = null) {
            return ApiClient.request(`/todos/${id}`, {
                method: 'DELETE',
                body: { deletion_type: deletionType, deletion_date: deletionDate }
            });
        },

        // 完成TODO
        async complete(id, userId, date, notes = '') {
            return ApiClient.post(`/todos/${id}/complete`, {
                user_id: userId,
                date: date,
                notes
            });
        },

        // 取消完成TODO
        async uncomplete(id, date) {
            return ApiClient.post(`/todos/${id}/uncomplete`, {
                date: date
            });
        }
    },

    // 重复模式相关API
    patterns: {
        // 获取所有重复模式
        async getAll() {
            return ApiClient.get('/patterns');
        },

        // 获取预设重复模式
        async getPresets() {
            return ApiClient.get('/patterns/presets');
        },

        // 根据ID获取重复模式
        async getById(id) {
            return ApiClient.get(`/patterns/${id}`);
        },

        // 创建重复模式
        async create(patternData) {
            return ApiClient.post('/patterns', patternData);
        },

        // 创建预设重复模式
        async createPreset(name) {
            return ApiClient.post(`/patterns/presets/${name}`);
        },

        // 检查日期是否匹配模式
        async checkDateMatch(id, targetDate, startDate) {
            return ApiClient.post(`/patterns/${id}/check`, {
                targetDate,
                startDate
            });
        },

        // 获取下一个匹配日期
        async getNextMatchDate(id, currentDate, startDate) {
            return ApiClient.post(`/patterns/${id}/next`, {
                currentDate,
                startDate
            });
        },

        // 获取时间范围内的匹配日期
        async getMatchDatesInRange(id, startDate, rangeStart, rangeEnd) {
            return ApiClient.post(`/patterns/${id}/range`, {
                startDate,
                rangeStart,
                rangeEnd
            });
        }
    },

    // Notes相关API
    notes: {
        // 获取用户的所有Notes
        async getByUserId(userId) {
            return ApiClient.get(`/notes/user/${userId}`);
        },

        // 根据ID获取Note
        async getById(id) {
            return ApiClient.get(`/notes/${id}`);
        },

        // 创建Note
        async create(noteData) {
            return ApiClient.post('/notes', noteData);
        },

        // 更新Note
        async update(id, noteData) {
            return ApiClient.put(`/notes/${id}`, noteData);
        },

        // 删除Note
        async delete(id) {
            return ApiClient.delete(`/notes/${id}`);
        },

        // 搜索Notes
        async search(searchTerm, userId = null) {
            const params = userId ? `?userId=${userId}` : '';
            return ApiClient.get(`/notes/search/${encodeURIComponent(searchTerm)}${params}`);
        },

        // 生成AI建议（传递真实天气数据）
        async generateAISuggestions(id) {
            // 获取用户位置信息
            console.log('🔍 开始获取用户位置和天气信息...');
            
            let userLocation = null;
            
            // 检查WeatherManager是否存在和初始化
            if (!window.WeatherManager) {
                console.log('❌ WeatherManager未初始化，无法获取位置信息');
            } else {
                console.log('✅ WeatherManager已初始化，状态:', {
                    locationReady: window.WeatherManager.locationReady,
                    hasUserLocation: !!window.WeatherManager.userLocation
                });
                
                if (window.WeatherManager.locationReady && window.WeatherManager.userLocation) {
                    userLocation = window.WeatherManager.userLocation;
                    console.log('📍 直接获取到用户位置:', userLocation);
                } else {
                    console.log('⏳ 用户位置还未准备好，尝试等待获取...');
                    
                    // 等待位置获取完成，最多等待5秒
                    let attempts = 0;
                    const maxAttempts = 10; // 5秒内检查10次
                    
                    while (attempts < maxAttempts && !userLocation) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        if (window.WeatherManager.locationReady && window.WeatherManager.userLocation) {
                            userLocation = window.WeatherManager.userLocation;
                            console.log('📍 等待后获取到用户位置:', userLocation);
                            break;
                        }
                        
                        attempts++;
                        console.log(`⏳ 位置获取尝试 ${attempts}/${maxAttempts}`);
                    }
                    
                    if (!userLocation) {
                        console.log('❌ 等待超时，无法获取用户位置');
                        console.log('🔍 最终WeatherManager状态:', {
                            locationReady: window.WeatherManager.locationReady,
                            userLocation: window.WeatherManager.userLocation
                        });
                    }
                }
            }
            
            // 获取天气数据
            console.log('🌤️ 开始获取天气数据...');
            let weatherData = null;
            
            if (window.WeatherManager && window.WeatherManager.weatherData) {
                weatherData = window.WeatherManager.weatherData;
                console.log('🌤️ 获取到天气数据:', weatherData);
            } else {
                console.log('❌ WeatherManager中无天气数据');
            }
            
            console.log('📍 最终发送给AI服务的位置:', userLocation);
            console.log('🌤️ 最终发送给AI服务的天气数据:', weatherData);
            
            return ApiClient.post(`/notes/${id}/ai-suggestions`, {
                userLocation: userLocation,
                weatherData: weatherData
            });
        }
    },

    // 认证相关API
    auth: {
        // 注册
        async register(username, password) {
            // 认证API不需要在headers中添加当前用户信息
            return fetch(`${ApiClient.baseURL}/auth/register`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            }).then(response => response.json());
        },

        // 登录
        async login(username, password) {
            return fetch(`${ApiClient.baseURL}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            }).then(response => response.json());
        },

        // 验证登录状态
        async verify(username) {
            return fetch(`${ApiClient.baseURL}/auth/verify?username=${encodeURIComponent(username)}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());
        },

        // 获取用户资料（用于Profile页面）
        async getProfile(username) {
            return fetch(`${ApiClient.baseURL}/auth/profile/${encodeURIComponent(username)}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());
        }
    },

    // 健康检查
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseURL.replace('/api', '')}/health`);
            return await response.json();
        } catch (error) {
            console.error('健康检查失败:', error);
            return { success: false, message: '服务器连接失败' };
        }
    },

    // 测试连接
    async testConnection() {
        try {
            const health = await this.healthCheck();
            if (health.success) {
                console.log('✅ 后端服务连接成功');
                return true;
            } else {
                console.warn('⚠️ 后端服务响应异常:', health.message);
                return false;
            }
        } catch (error) {
            console.error('❌ 后端服务连接失败:', error.message);
            return false;
        }
    }
};

// 导出到全局
window.ApiClient = ApiClient;


// WebSocket客户端 - 实时通信管理
const WebSocketClient = {
    ws: null,
    isConnected: false,
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    reconnectInterval: 2000,
    heartbeatInterval: null,
    messageHandlers: new Map(),
    
    // 获取WebSocket URL
    getWebSocketURL() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        let wsHost;

        // 自动适配 cloudflare tunnel 的域名
        if (protocol === 'wss:' && hostname.endsWith('.trycloudflare.com')) {
            wsHost = `wss://${hostname}`;
        } else if (hostname === '192.168.3.5') {
            wsHost = 'ws://192.168.3.5:3001';
        } else if (hostname === 'localhost' || hostname === '127.0.0.1') {
            wsHost = 'ws://localhost:3001';
        } else {
            wsHost = `ws://${hostname}:3001`;
        }

        return `${wsHost}/ws`;
    },

    // 初始化WebSocket连接
    async init() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            console.log('⚠️ WebSocket已连接，无需重复初始化');
            return true;
        }

        return new Promise((resolve, reject) => {
            try {
                const wsUrl = this.getWebSocketURL();
                console.log('🔄 正在连接WebSocket:', wsUrl);
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('✅ WebSocket连接成功');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.startHeartbeat();
                    resolve(true);
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        console.error('❌ WebSocket消息解析失败:', error);
                    }
                };

                this.ws.onclose = (event) => {
                    console.log('🔌 WebSocket连接关闭:', event.code, event.reason);
                    this.isConnected = false;
                    this.stopHeartbeat();
                    
                    // 如果不是主动关闭，尝试重连
                    if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
                        this.scheduleReconnect();
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('❌ WebSocket连接错误:', error);
                    this.isConnected = false;
                    reject(error);
                };

            } catch (error) {
                console.error('❌ WebSocket初始化失败:', error);
                reject(error);
            }
        });
    },

    // 发送消息
    async sendMessage(type, data = {}) {
        if (!this.isConnected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocket未连接');
        }

        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const userId = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;

        const message = {
            type,
            deviceId,
            userId,
            data,
            timestamp: Date.now()
        };

        return new Promise((resolve, reject) => {
            try {
                // 注册响应处理器
                const responseType = `${type}_RESPONSE`;
                const errorType = `${type}_ERROR`;
                
                const timeout = setTimeout(() => {
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    reject(new Error('请求超时'));
                }, 10000); // 10秒超时

                this.messageHandlers.set(responseType, (response) => {
                    clearTimeout(timeout);
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    resolve(response);
                });

                this.messageHandlers.set(errorType, (error) => {
                    clearTimeout(timeout);
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    reject(new Error(error.error || '请求失败'));
                });

                // 发送消息
                this.ws.send(JSON.stringify(message));
                console.log('📤 发送WebSocket消息:', type, data);
                
            } catch (error) {
                reject(error);
            }
        });
    },

    // 处理接收到的消息
    handleMessage(message) {
        const { type } = message;
        console.log('📥 收到WebSocket消息:', type, message);

        // 处理响应和错误消息
        if (this.messageHandlers.has(type)) {
            const handler = this.messageHandlers.get(type);
            handler(message);
            return;
        }

        // 处理广播消息
        if (type.endsWith('_BROADCAST')) {
            this.handleBroadcast(message);
            return;
        }

        // 处理心跳
        if (type === 'PONG') {
            console.log('💗 收到心跳响应');
            return;
        }

        console.log('⚠️ 未处理的消息类型:', type);
    },

    // 处理广播消息（其他设备的操作）
    handleBroadcast(message) {
        const { type, data } = message;
        console.log('📡 处理广播消息:', type);

        // 根据消息类型更新界面
        switch (type) {
            case 'TODO_CREATE_BROADCAST':
            case 'TODO_UPDATE_BROADCAST':
            case 'TODO_DELETE_BROADCAST':
            case 'TODO_COMPLETE_BROADCAST':
            case 'TODO_UNCOMPLETE_BROADCAST':
                // 通知TODO管理器更新界面
                if (window.TodoManager) {
                    window.TodoManager.handleWebSocketBroadcast(type, data);
                }
                break;
                
            case 'NOTES_CREATE_BROADCAST':
            case 'NOTES_UPDATE_BROADCAST':
            case 'NOTES_DELETE_BROADCAST':
                // 通知Notes管理器更新界面
                if (window.NotesManager) {
                    window.NotesManager.handleWebSocketBroadcast(type, data);
                }
                break;
        }
    },

    // 心跳检测
    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({
                    type: 'PING',
                    timestamp: Date.now()
                }));
            }
        }, 30000); // 30秒发送一次心跳
    },

    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    },

    // 计划重连
    scheduleReconnect() {
        this.reconnectAttempts++;
        const delay = this.reconnectInterval * this.reconnectAttempts;
        
        console.log(`🔄 计划在 ${delay}ms 后重连 (尝试 ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        
        setTimeout(() => {
            console.log(`🔄 开始第 ${this.reconnectAttempts} 次重连尝试`);
            this.init().catch(error => {
                console.error('❌ 重连失败:', error);
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.scheduleReconnect();
                } else {
                    console.error('❌ 达到最大重连次数，放弃重连');
                    // 降级到HTTP模式
                    this.fallbackToHTTP();
                }
            });
        }, delay);
    },

    // 降级到HTTP模式
    fallbackToHTTP() {
        console.log('📡 WebSocket不可用，降级到HTTP模式');
        // 通知各管理器切换到HTTP模式
        if (window.TodoManager) {
            window.TodoManager.fallbackToHTTP();
        }
        if (window.NotesManager) {
            window.NotesManager.fallbackToHTTP();
        }
    },

    // 关闭连接
    close() {
        this.stopHeartbeat();
        this.messageHandlers.clear();
        
        if (this.ws) {
            this.ws.close(1000, '正常关闭');
            this.ws = null;
        }
        
        this.isConnected = false;
        console.log('👋 WebSocket连接已关闭');
    },

    // TODO相关API方法
    todos: {
        async getTodayTodos(userId) {
            return await WebSocketClient.sendMessage('TODO_GET_TODAY', { userId });
        },

        async getTodosForDate(userId, date) {
            return await WebSocketClient.sendMessage('TODO_GET_BY_DATE', { userId, date });
        },

        async create(todoData) {
            return await WebSocketClient.sendMessage('TODO_CREATE', todoData);
        },

        async update(todoId, updateData) {
            return await WebSocketClient.sendMessage('TODO_UPDATE', { todoId, updateData });
        },

        async delete(todoId, deletionType, deletionDate) {
            return await WebSocketClient.sendMessage('TODO_DELETE', { 
                todoId, deletionType, deletionDate 
            });
        },

        async complete(todoId, userId, date) {
            return await WebSocketClient.sendMessage('TODO_COMPLETE', { 
                todoId, userId, date 
            });
        },

        async uncomplete(todoId, date) {
            return await WebSocketClient.sendMessage('TODO_UNCOMPLETE', { 
                todoId, date 
            });
        }
    },

    // Notes相关API方法
    notes: {
        async getByUserId(userId) {
            return await WebSocketClient.sendMessage('NOTES_GET_BY_USER', { userId });
        },

        async create(noteData) {
            return await WebSocketClient.sendMessage('NOTES_CREATE', noteData);
        },

        async update(noteId, updateData) {
            return await WebSocketClient.sendMessage('NOTES_UPDATE', { noteId, updateData });
        },

        async delete(noteId) {
            return await WebSocketClient.sendMessage('NOTES_DELETE', { noteId });
        },

        async generateAISuggestions(noteId, userLocation, weatherData) {
            return await WebSocketClient.sendMessage('NOTES_AI_SUGGESTIONS', { 
                noteId, userLocation, weatherData 
            });
        }
    },

    // 获取连接状态
    getConnectionStatus() {
        return {
            isConnected: this.isConnected,
            reconnectAttempts: this.reconnectAttempts,
            wsState: this.ws ? this.ws.readyState : null
        };
    }
};

// 页面卸载时关闭连接
window.addEventListener('beforeunload', () => {
    WebSocketClient.close();
});

// 导出到全局
window.WebSocketClient = WebSocketClient;


// 全局用户状态管理器
const GlobalUserState = {
    currentUserId: null,
    currentModule: 'todo', // 'todo' 或 'notes'
    listeners: [],

    // 初始化
    init() {
        console.log('🌐 初始化全局用户状态管理器');
        
        // 只恢复模块状态，用户状态由TodoManager的setDefaultUser决定
        const savedModule = localStorage.getItem('wenting_current_module');
        
        if (savedModule) {
            this.currentModule = savedModule;
        }
        
        // 不从localStorage恢复用户ID，让TodoManager决定默认用户
        console.log('📍 初始化状态:', {
            currentUserId: this.currentUserId,
            currentModule: this.currentModule
        });
        console.log('🔄 用户ID将由TodoManager的setDefaultUser方法设置');
    },

    // 设置当前用户
    setCurrentUser(userId) {
        console.log('👤 切换当前用户:', this.currentUserId, '->', userId);
        
        if (this.currentUserId !== userId) {
            this.currentUserId = userId;
            
            // 保存到localStorage
            localStorage.setItem('wenting_current_user_id', userId.toString());
            
            // 通知所有监听器
            this.notifyListeners('userChanged', { userId: userId });
        }
        
        // 无论是否相同，都更新UI（确保样式正确）
        console.log('🎨 强制更新用户选择器UI...');
        this.updateUserSelectorUI();
        
        // 触发用户选择事件，传递完整的用户对象
        if (window.UserManager && window.UserManager.users) {
            const selectedUser = window.UserManager.users.find(user => user.id === userId);
            console.log('🔍 查找用户对象，用户ID:', userId, '找到的用户:', selectedUser);
            
            if (selectedUser) {
                console.log('📢 准备触发userSelected事件');
                const userSelectedEvent = new CustomEvent('userSelected', {
                    detail: selectedUser
                });
                document.dispatchEvent(userSelectedEvent);
                console.log('✅ userSelected事件已触发，用户:', selectedUser.username);
            } else {
                console.warn('⚠️ 未找到用户ID为', userId, '的用户对象');
            }
        } else {
            console.warn('⚠️ UserManager或用户列表未就绪');
        }
    },

    // 设置当前模块
    setCurrentModule(module) {
        console.log('📋 切换当前模块:', module);
        
        if (this.currentModule !== module) {
            this.currentModule = module;
            
            // 保存到localStorage
            localStorage.setItem('wenting_current_module', module);
            
            // 通知所有监听器
            this.notifyListeners('moduleChanged', { module: module });
        }
    },

    // 获取当前用户ID
    getCurrentUser() {
        // 如果当前没有用户ID，尝试从localStorage恢复
        if (this.currentUserId === null) {
            const savedUserId = localStorage.getItem('wenting_current_user_id');
            if (savedUserId && !isNaN(parseInt(savedUserId))) {
                this.currentUserId = parseInt(savedUserId);
                console.log('💾 从localStorage恢复用户ID:', this.currentUserId);
            }
        }
        return this.currentUserId;
    },

    // 获取当前模块
    getCurrentModule() {
        return this.currentModule;
    },

    // 添加监听器
    addListener(callback) {
        this.listeners.push(callback);
    },

    // 移除监听器
    removeListener(callback) {
        const index = this.listeners.indexOf(callback);
        if (index > -1) {
            this.listeners.splice(index, 1);
        }
    },

    // 通知所有监听器
    notifyListeners(type, data) {
        console.log('📢 通知监听器:', type, data);
        this.listeners.forEach(callback => {
            try {
                callback(type, data);
            } catch (error) {
                console.error('❌ 监听器回调错误:', error);
            }
        });
    },

    // 更新用户选择器UI
    updateUserSelectorUI() {
        console.log('🎨 更新用户选择器UI，当前用户:', this.currentUserId);
        
        // 直接更新样式，不重新渲染整个HTML（避免丢失状态）
        console.log('📝 直接更新用户标签样式');
        const userTabs = document.querySelectorAll('.sidebar-tab');
        console.log('🔍 找到', userTabs.length, '个用户标签');
        
        userTabs.forEach(tab => {
            const tabUserId = parseInt(tab.dataset.tab);
            console.log('🏷️ 处理标签，用户ID:', tabUserId, '当前用户:', this.currentUserId);
            
            if (tabUserId === this.currentUserId) {
                console.log('✅ 设置为选中状态:', tabUserId);
                tab.classList.add('active');
                
                // 更新CSS变量用于颜色条
                if (window.UserManager) {
                    const user = UserManager.getUser(tabUserId);
                    if (user) {
                        tab.style.setProperty('--user-color', user.avatar_color || '#1d9bf0');
                        console.log('🎨 应用选中样式，颜色条:', user.avatar_color);
                    }
                }
            } else {
                console.log('❌ 设置为未选中状态:', tabUserId);
                tab.classList.remove('active');
                
                // 保持颜色条颜色不变
                if (window.UserManager) {
                    const user = UserManager.getUser(tabUserId);
                    if (user) {
                        tab.style.setProperty('--user-color', user.avatar_color || '#1d9bf0');
                    }
                }
            }
        });
    },

    // 绑定用户选择器事件
    bindUserSelectorEvents() {
        console.log('🔗 开始绑定用户选择器事件...');
        
        // 使用事件委托，避免重复绑定问题
        const sidebar = document.querySelector('.left-sidebar');
        if (sidebar) {
            // 移除已存在的事件监听器
            sidebar.removeEventListener('click', this._sidebarClickHandler);
            
            // 绑定事件委托
            this._sidebarClickHandler = (e) => {
                const tab = e.target.closest('.sidebar-tab');
                if (tab) {
                    e.preventDefault();
                    e.stopPropagation();
                    const userId = parseInt(tab.dataset.tab);
                    if (userId && !isNaN(userId)) {
                        console.log('🖱️ 用户按钮点击，切换到用户:', userId);
                        this.setCurrentUser(userId);
                    }
                }
            };
            
            sidebar.addEventListener('click', this._sidebarClickHandler);
            console.log('🔗 用户选择器事件委托绑定完成');
        }
    }
};

// 导出到全局
window.GlobalUserState = GlobalUserState;


// 日期管理模块
const DateManager = {
    selectedDate: new Date(),
    calendarDate: new Date(),
    // 添加优化标记
    isChangingDate: false,
    currentDateElements: null,
    
    // 进度条控制
    showLoadingProgress() {
        const progressEl = document.getElementById('loadingProgress');
        if (progressEl) {
            progressEl.style.display = 'block';
        }
    },
    
    hideLoadingProgress() {
        const progressEl = document.getElementById('loadingProgress');
        if (progressEl) {
            progressEl.style.display = 'none';
        }
    },

    init() {
        this.updateCurrentDate();
        this.updateSelectedDate();
        this.bindEvents();
        // 预缓存DOM元素
        this.currentDateElements = Utils.$$('.current-date');
    },

    // 更新当前日期显示
    updateCurrentDate() {
        const now = new Date();
        const formatted = Utils.formatDate(now);
        
        // 更新weather栏的日期显示
        const currentDateEl = Utils.$('#currentDate');
        const weekdayEl = Utils.$('.weather-date-weekday');
        
        if (currentDateEl) {
            currentDateEl.textContent = formatted.full;
        }
        if (weekdayEl) {
            weekdayEl.textContent = formatted.weekday;
        }
    },

    // 更新选择的日期显示（优化版）
    updateSelectedDate() {
        const formatted = Utils.formatDate(this.selectedDate);
        
        // 使用缓存的DOM元素，避免重复查询
        if (!this.currentDateElements) {
            this.currentDateElements = Utils.$$('.current-date');
        }
        
        if (this.currentDateElements && this.currentDateElements.length > 0) {
            this.currentDateElements.forEach(el => {
                if (el && typeof el.textContent !== 'undefined') {
                    el.textContent = formatted.full;
                }
            });
        }
        
        // 如果不是通过changeDate触发的，才更新TODO显示
        // 避免双重渲染
        if (!this.isChangingDate) {
            this.filterTodosByDate();
        }
    },

    // 根据日期过滤todo项目
    filterTodosByDate() {
        // 通知TodoManager重新渲染当前用户的TODO面板
        // 但是要确保用户数据已经加载完成，避免过早渲染
        if (typeof TodoManager !== 'undefined' && 
            TodoManager.currentUser && 
            typeof UserManager !== 'undefined' && 
            UserManager.users && 
            UserManager.users.length > 0) {
            
            console.log('📅 DateManager触发TODO面板重新渲染，用户:', TodoManager.currentUser);
            TodoManager.renderTodoPanel(TodoManager.currentUser);
        } else {
            console.log('📅 DateManager跳过TODO面板渲染，条件不满足:');
            console.log('  - TodoManager存在:', typeof TodoManager !== 'undefined');
            console.log('  - currentUser存在:', !!TodoManager?.currentUser);
            console.log('  - UserManager存在:', typeof UserManager !== 'undefined');
            console.log('  - 用户数据已加载:', UserManager?.users?.length > 0);
        }
    },

    // 日期切换（优化版）
    changeDate(direction) {
        // 设置标记，避免双重渲染
        this.isChangingDate = true;
        
        this.selectedDate.setDate(this.selectedDate.getDate() + direction);
        
        // 立即更新日期显示（不触发TODO渲染）
        this.updateSelectedDate();
        
        // 检查TodoManager的缓存
        const dateStr = this.selectedDate.toISOString().split('T')[0];
        const currentUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
        const cacheKey = `${currentUser}_${dateStr}`;
        
        let hasCache = false;
        if (window.TodoManager && currentUser && window.TodoManager.todoCache.has(cacheKey)) {
            // 使用TodoManager的缓存数据快速渲染
            const cachedData = window.TodoManager.todoCache.get(cacheKey);
            window.TodoManager.todos[currentUser] = [...cachedData]; // 创建副本
            window.TodoManager.renderTodoPanel(currentUser);
            console.log('📅 DateManager使用缓存快速渲染，用户:', currentUser);
            hasCache = true;
        }
        
        // 如果没有缓存，显示加载进度条
        if (!hasCache) {
            this.showLoadingProgress();
        }
        
        // 异步加载最新数据（不阻塞UI）
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            // 传递正确的用户ID，确保加载正确用户的数据
            const targetUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
            window.TodoManager.loadTodosForDate(this.selectedDate, targetUser, true).then(() => {
                // 数据加载完成后隐藏进度条
                this.hideLoadingProgress();
            }).catch(() => {
                // 即使出错也要隐藏进度条
                this.hideLoadingProgress();
            });
        }
        
        // 重置标记
        this.isChangingDate = false;
    },

    // 返回今天
    goToToday() {
        console.log('goToToday被调用');
        this.selectedDate = new Date();
        console.log('重置为今天:', this.selectedDate);
        this.updateSelectedDate();
        
        // 检查缓存决定是否显示进度条
        const dateStr = this.selectedDate.toISOString().split('T')[0];
        const currentUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
        const cacheKey = `${currentUser}_${dateStr}`;
        
        let hasCache = window.TodoManager && currentUser && window.TodoManager.todoCache.has(cacheKey);
        
        // 如果没有缓存，显示加载进度条
        if (!hasCache) {
            this.showLoadingProgress();
        }
        
        // 通知TodoManager重新加载数据
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            window.TodoManager.loadTodosForDate(this.selectedDate).then(() => {
                this.hideLoadingProgress();
            }).catch(() => {
                this.hideLoadingProgress();
            });
        }
    },

    // 切换日历显示
    toggleDatePicker() {
        console.log('toggleDatePicker 被调用');
        const picker = Utils.$('#datePicker');
        console.log('找到日历元素:', picker);
        const isVisible = picker && picker.classList.contains('show');
        console.log('日历当前可见状态:', isVisible);
        
        if (isVisible) {
            console.log('隐藏日历');
            picker.classList.remove('show');
        } else {
            console.log('显示日历');
            this.calendarDate = new Date(this.selectedDate);
            this.updateCalendar();
            if (picker) {
                picker.classList.add('show');
            }
        }
    },

    // 更改日历月份
    changeMonth(direction) {
        this.calendarDate.setMonth(this.calendarDate.getMonth() + direction);
        this.updateCalendar();
    },

    // 更新日历显示
    updateCalendar() {
        const months = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
        const year = this.calendarDate.getFullYear();
        const month = this.calendarDate.getMonth();
        
        // 更新月份标题
        const monthEl = Utils.$('#calendarMonth');
        if (monthEl) {
            monthEl.textContent = `${year}年${months[month]}`;
        }
        
        // 生成日历日期
        const firstDay = new Date(year, month, 1);
        const startDate = new Date(firstDay);
        startDate.setDate(startDate.getDate() - firstDay.getDay());
        
        const calendarDays = Utils.$('#calendarDays');
        if (calendarDays) {
            calendarDays.innerHTML = '';
            
            for (let i = 0; i < 42; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                const dayButton = document.createElement('button');
                dayButton.className = 'calendar-day';
                dayButton.textContent = date.getDate();
                
                // 检查是否是当前月份
                if (date.getMonth() !== month) {
                    dayButton.classList.add('other-month');
                }
                
                // 检查是否是选中的日期
                if (date.toDateString() === this.selectedDate.toDateString()) {
                    dayButton.classList.add('selected');
                }
                
                dayButton.onclick = () => this.selectDate(date);
                calendarDays.appendChild(dayButton);
            }
        }
    },

    // 选择日期
    selectDate(date) {
        this.selectedDate = new Date(date);
        this.updateSelectedDate();
        this.toggleDatePicker();
        
        // 通知TodoManager重新加载数据
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            window.TodoManager.loadTodosForDate(this.selectedDate);
        }
    },

    // 绑定事件
    bindEvents() {
        // 点击外部关闭日历
        document.addEventListener('click', (event) => {
            const picker = Utils.$('#datePicker');
            const pickerBtn = event.target.closest('.date-picker-btn');
            
            if (picker && !picker.contains(event.target) && !pickerBtn) {
                picker.classList.remove('show');
            }
        });

        // 使用事件委托，避免重复绑定
        this.bindEventsWithDelegation();
    },

    // 使用事件委托绑定事件
    bindEventsWithDelegation() {
        // 使用事件委托绑定今天按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('today-btn')) {
                e.preventDefault();
                e.stopPropagation();
                console.log('今天按钮被点击');
                this.goToToday();
            }
        });

        // 使用事件委托绑定日期导航按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('date-nav-btn')) {
                e.preventDefault();
                e.stopPropagation();
                console.log('日期导航按钮被点击:', e.target.textContent);
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeDate(direction);
            }
        });

        // 使用事件委托绑定日历切换按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('date-picker-btn')) {
                console.log('日历按钮被点击！');
                e.preventDefault();
                e.stopPropagation();
                this.toggleDatePicker();
            }
        });

        // 使用事件委托绑定月份导航按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('calendar-nav')) {
                e.preventDefault();
                e.stopPropagation();
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeMonth(direction);
            }
        });
    },

    // 绑定日期导航事件
    bindDateNavigation() {
        // 绑定日期导航按钮
        const dateNavBtns = Utils.$$('.date-nav-btn');
        console.log('找到日期导航按钮:', dateNavBtns.length);
        dateNavBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                console.log('日期导航按钮被点击:', e.target.textContent);
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeDate(direction);
            });
        });

        // 绑定日历切换按钮
        const pickerBtns = Utils.$$('.date-picker-btn');
        console.log('找到日历切换按钮:', pickerBtns.length);
        pickerBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                this.toggleDatePicker();
            });
        });

        // 绑定月份导航
        const calendarNavBtns = Utils.$$('.calendar-nav');
        console.log('找到月份导航按钮:', calendarNavBtns.length);
        calendarNavBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeMonth(direction);
            });
        });
    }
};

// 全局函数（保持向后兼容）
function changeDate(direction) {
    DateManager.changeDate(direction);
}

function goToToday() {
    DateManager.goToToday();
}

function toggleDatePicker() {
    DateManager.toggleDatePicker();
}

function changeMonth(direction) {
    DateManager.changeMonth(direction);
}

// 将DateManager暴露到全局
window.DateManager = DateManager;


// TODO管理模块 - 完全重写版本
const TodoManager = {
    currentUser: 1,
    todos: {},
    selectedDate: new Date(),
    isOnline: false,
    // 添加缓存机制
    todoCache: new Map(),
    lastLoadedDate: null,

    // 初始化
    async init() {
        console.log('🔄 初始化TODO管理器...');
        
        // 检查后端连接 - 必须联网才能使用
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            this.showOfflineError();
            return;
        }
        
        // 等待用户管理器初始化完成
        await this.waitForUserManager();
        
        // 加载TODO数据
        await this.loadTodosFromAPI();
        
        // 设置默认用户
        this.setDefaultUser();
        
        // 监听全局用户状态变化，但不设置模块
        if (window.GlobalUserState) {
            GlobalUserState.addListener(this.handleGlobalStateChange.bind(this));
        }
        
        // 不在这里渲染界面，等待应用界面显示后再渲染
        // 渲染将在app.js的setTimeout中进行
        
        this.bindEvents();
        
        console.log('✅ TODO管理器初始化完成');
    },

    // 等待用户管理器初始化完成
    async waitForUserManager() {
        if (UserManager.users.length === 0) {
            await new Promise(resolve => {
                const checkUsers = () => {
                    if (UserManager.users.length > 0) {
                        resolve();
                    } else {
                        setTimeout(checkUsers, 100);
                    }
                };
                checkUsers();
            });
        }
    },

    // 从API加载TODO数据
    async loadTodosFromAPI() {
        try {
            console.log('📥 从服务器加载TODO数据...');
            
            // 尝试使用WebSocket，失败则降级到HTTP
            let useWebSocket = true;
            try {
                // 确保WebSocket已连接
                if (!WebSocketClient.isConnected) {
                    await WebSocketClient.init();
                }
            } catch (error) {
                console.warn('⚠️ WebSocket连接失败，使用HTTP模式:', error.message);
                useWebSocket = false;
            }

            // 为每个用户加载TODO数据
            for (const user of UserManager.users) {
                try {
                    let response;
                    if (useWebSocket) {
                        response = await WebSocketClient.todos.getTodayTodos(user.id);
                        this.todos[user.id] = response.data.todos.map(todo => this.convertApiTodoToLocal(todo));
                    } else {
                        response = await ApiClient.todos.getTodayTodos(user.id);
                        if (response.success) {
                            this.todos[user.id] = response.data.map(todo => this.convertApiTodoToLocal(todo));
                        } else {
                            throw new Error(response.message);
                        }
                    }
                } catch (error) {
                    console.warn(`加载用户${user.id}的TODO失败:`, error.message);
                    this.todos[user.id] = [];
                }
            }
            
            console.log('✅ 从服务器加载TODO数据成功');
        } catch (error) {
            console.error('从服务器加载TODO数据失败:', error);
            throw error;
        }
    },

    // 设置默认用户
    setDefaultUser() {
        console.log('🔄 开始设置默认用户...');
        console.log('🔍 用户数据调试:');
        console.log('  - UserManager.users.length:', UserManager.users.length);
        console.log('  - UserManager.users:', UserManager.users);
        
        if (UserManager.users.length > 0) {
            // 检查是否有保存的用户选择
            let savedUserId = null;
            if (window.GlobalUserState) {
                savedUserId = GlobalUserState.getCurrentUser();
                console.log('💾 从全局状态获取保存的用户ID:', savedUserId);
            }
            
            // 按ID排序，选择ID最小的用户（最早添加的用户）
            const sortedUsers = [...UserManager.users].sort((a, b) => a.id - b.id);
            
            // 验证保存的用户ID是否仍然存在
            let defaultUser;
            if (savedUserId && sortedUsers.find(u => u.id == savedUserId)) {
                defaultUser = parseInt(savedUserId);
                console.log('🎯 使用保存的用户ID:', defaultUser);
            } else {
                defaultUser = sortedUsers[0].id;
                console.log('🎯 使用默认第一个用户:', defaultUser, '(用户名:', sortedUsers[0].username, ')');
            }
            
            console.log('📋 所有用户按ID排序:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));
            this.currentUser = defaultUser;
            
            // 直接同步全局状态，不触发事件（事件将在app.js中触发）
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = defaultUser;
                localStorage.setItem('wenting_current_user_id', defaultUser.toString());
                console.log('🔄 直接同步全局用户状态（不触发事件）');
                console.log('🔍 设置后的状态:');
                console.log('  - TodoManager.currentUser:', this.currentUser);
                console.log('  - GlobalUserState.currentUserId:', GlobalUserState.currentUserId);
            }
        } else {
            console.log('📝 没有用户，显示空用户状态');
            this.currentUser = null;
        }
    },

    // 处理全局状态变化
    handleGlobalStateChange(type, data) {
        console.log('📢 TODO管理器收到全局状态变化:', type, data);
        
        if (type === 'userChanged') {
            const newUserId = data.userId;
            console.log('🔄 处理用户切换事件:');
            console.log('  - 当前用户:', this.currentUser);
            console.log('  - 新用户:', newUserId);
            
            // 先更新currentUser，确保后续操作使用正确的用户ID
            const oldUser = this.currentUser;
            this.currentUser = newUserId;
            
            if (oldUser !== newUserId) {
                console.log(`🔄 用户从 ${oldUser} 切换到 ${newUserId}`);
                // 只有当前模块是todo时才渲染
                if (GlobalUserState.getCurrentModule() === 'todo') {
                    console.log('✅ 当前是TODO模块，渲染TODO内容');
                    
                    // 检查缓存决定是否显示进度条
                    const dateStr = (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
                    const cacheKey = `${newUserId}_${dateStr}`;
                    let hasCache = this.todoCache.has(cacheKey);
                    
                    // 如果没有缓存，显示加载进度条
                    if (!hasCache && window.DateManager) {
                        window.DateManager.showLoadingProgress();
                    }
                    
                    this.loadTodosForDate(DateManager.selectedDate || new Date(), newUserId).then(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }).catch(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    });
                } else {
                    console.log('⏸️ 当前不是TODO模块，跳过渲染');
                }
            } else {
                console.log('🔄 用户ID相同，但仍需重新渲染TODO面板（可能是初始化调用）');
                // 即使用户ID相同，也要重新渲染（比如初始化时）
                if (GlobalUserState.getCurrentModule() === 'todo') {
                    console.log('✅ 当前是TODO模块，渲染TODO内容');
                    
                    // 检查缓存决定是否显示进度条  
                    const dateStr = (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
                    const cacheKey = `${newUserId}_${dateStr}`;
                    let hasCache = this.todoCache.has(cacheKey);
                    
                    // 如果没有缓存，显示加载进度条
                    if (!hasCache && window.DateManager) {
                        window.DateManager.showLoadingProgress();
                    }
                    
                    this.loadTodosForDate(DateManager.selectedDate || new Date(), newUserId).then(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }).catch(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    });
                } else {
                    console.log('⏸️ 当前不是TODO模块，跳过渲染');
                }
            }
        }
    },

    // 显示离线错误
    showOfflineError() {
        const contentArea = document.getElementById('contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="offline-error">
                    <div class="error-icon">🌐</div>
                    <h2>需要网络连接</h2>
                    <p>此应用需要连接到服务器才能正常使用。</p>
                    <p>请检查您的网络连接和服务器状态。</p>
                    <button onclick="location.reload()" class="retry-btn">重试</button>
                </div>
            `;
        }
    },

    // 显示空用户状态
    showEmptyUserState() {
        const contentArea = document.getElementById('contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="empty-user-state">
                    <div class="empty-icon">👥</div>
                    <h2>欢迎使用雯婷</h2>
                    <p>还没有用户，请先添加一个用户开始使用。</p>
                    <button onclick="UserManager.addUser()" class="add-first-user-btn">添加第一个用户</button>
                </div>
            `;
        }
    },

    // 将API TODO格式转换为本地格式
    convertApiTodoToLocal(apiTodo) {
        console.log('📥 从服务器接收的TODO数据:', apiTodo);
        console.log('📋 重复周期数据调试:');
        console.log('  cycle_type:', apiTodo.cycle_type);
        console.log('  cycle_duration:', apiTodo.cycle_duration);
        console.log('  cycle_unit:', apiTodo.cycle_unit);
        
        const cycleText = this.getCycleText(apiTodo.cycle_type, apiTodo.cycle_duration, apiTodo.cycle_unit);
        console.log('  计算出的cycle文本:', cycleText);
        
        return {
            id: apiTodo.id,
            text: apiTodo.title,
            note: apiTodo.description || '',
            time: apiTodo.reminder_time === 'all_day' ? '当天' : apiTodo.reminder_time,
            period: this.getRepeatTypeText(apiTodo.repeat_type, apiTodo.repeat_interval),
            periodType: apiTodo.repeat_type,
            customInterval: apiTodo.repeat_interval > 1 ? apiTodo.repeat_interval : null,
            cycle: cycleText,
            cycleType: apiTodo.cycle_type || 'long_term',
            cycleDuration: apiTodo.cycle_duration || null,
            cycleUnit: apiTodo.cycle_unit || 'days',
            completed: apiTodo.is_completed_today || false,
            priority: apiTodo.priority || 'medium',
            createdDate: apiTodo.start_date || new Date().toISOString().split('T')[0]
        };
    },

    // 将本地TODO格式转换为API格式
    convertLocalTodoToApi(localTodo, userId) {
        return {
            user_id: userId,
            title: localTodo.text,
            description: localTodo.note || '',
            reminder_time: localTodo.time === '当天' ? 'all_day' : localTodo.time,
            priority: localTodo.priority || 'medium',
            repeat_type: localTodo.periodType || 'none',
            repeat_interval: localTodo.customInterval || 1,
            cycle_type: localTodo.cycleType || 'long_term',
            cycle_duration: localTodo.cycleDuration || null,
            cycle_unit: localTodo.cycleUnit || 'days',
            start_date: new Date().toISOString().split('T')[0]
        };
    },

    // 获取重复类型的显示文本
    getRepeatTypeText(repeatType, repeatInterval = 1) {
        switch (repeatType) {
            case 'none':
                return '一次性';
            case 'daily':
                return '每天';
            case 'every_other_day':
                return '隔天';
            case 'weekly':
                return '每周';
            case 'monthly':
                return '每月';
            case 'yearly':
                return '每年';
            case 'custom':
                return `每${repeatInterval}天`;
            default:
                return '一次性';
        }
    },

    // 获取重复周期的显示文本
    getCycleText(cycleType, cycleDuration, cycleUnit) {
        if (cycleType === 'long_term') {
            return '长期';
        } else if (cycleType === 'custom' && cycleDuration) {
            const unitText = {
                'days': '天',
                'weeks': '周',
                'months': '月'
            };
            return `${cycleDuration}${unitText[cycleUnit] || '天'}`;
        }
        return '长期';
    },


    // 渲染TODO面板
    renderTodoPanel(userId) {
        console.log('🎨 开始渲染TODO面板，用户ID:', userId);
        console.log('🔍 渲染调试信息:');
        
        const contentArea = document.getElementById('contentArea');
        console.log('  - contentArea存在:', !!contentArea);
        if (!contentArea) {
            console.error('❌ 找不到contentArea元素');
            return;
        }

        // 获取当前选中的日期
        const currentDate = DateManager.selectedDate || new Date();
        console.log('  - 当前日期:', currentDate);
        
        // 获取用户TODO并按时间排序
        const userTodos = this.todos[userId] || [];
        const user = UserManager.getUser(userId);
        console.log('  - 用户信息:', user);
        console.log('  - 用户TODO数量:', userTodos.length);
        console.log('  - 用户TODO详情:', userTodos);
        
        // 获取当前日期的格式化显示
        const currentDateFormatted = this.formatDate(currentDate);
        console.log('  - 格式化日期:', currentDateFormatted);
        
        const panelHtml = `
            <div class="content-panel" id="${userId}-todo-panel">
                <div class="date-controls">
                    <div class="date-center">
                        <div class="today-btn">今天</div>
                        <div class="date-nav-btn">‹</div>
                        <div class="current-date">${currentDateFormatted}</div>
                        <div class="date-nav-btn">›</div>
                    </div>
                    <div class="date-picker-btn">📅</div>
                    <div class="date-picker" id="datePicker">
                        <div class="calendar-header">
                            <button class="calendar-nav">‹</button>
                            <span id="calendarMonth">2025年8月</span>
                            <button class="calendar-nav">›</button>
                        </div>
                        <div class="calendar-grid">
                            <div class="calendar-weekday">日</div>
                            <div class="calendar-weekday">一</div>
                            <div class="calendar-weekday">二</div>
                            <div class="calendar-weekday">三</div>
                            <div class="calendar-weekday">四</div>
                            <div class="calendar-weekday">五</div>
                            <div class="calendar-weekday">六</div>
                        </div>
                        <div class="calendar-grid" id="calendarDays"></div>
                    </div>
                </div>
                <div class="todo-list-container">
                    ${userTodos.map(todo => this.renderTodoItem(todo, userId)).join('')}
                    <button class="new-todo-btn" onclick="TodoManager.showAddTodoForm(${userId})">+ 添加新TODO</button>
                </div>
            </div>
        `;

        console.log('📝 设置contentArea的innerHTML...');
        console.log('📏 panelHtml长度:', panelHtml.length);
        contentArea.innerHTML = panelHtml;
        console.log('✅ TODO面板HTML已设置到contentArea');
    },

    // 渲染单个TODO项
    renderTodoItem(todo, userId) {
        const checkedClass = todo.completed ? 'checked' : '';
        const completedClass = todo.completed ? 'completed' : '';
        const timeSpecificClass = todo.time !== '当天' ? 'specific' : '';
        
        // 根据优先级设置边框颜色
        let priorityClass = '';
        switch (todo.priority) {
            case 'high':
                priorityClass = 'priority-high';
                break;
            case 'medium':
                priorityClass = 'priority-medium';
                break;
            case 'low':
            default:
                priorityClass = 'priority-low';
                break;
        }
        
        // 检查是否有关联用户（同步状态）
        const syncStatus = this.getSyncStatus(userId);
        const syncIndicator = syncStatus.isLinked ? `
            <div class="sync-indicator ${syncStatus.status}" title="${syncStatus.tooltip}">
                <span class="sync-icon">${syncStatus.icon}</span>
            </div>
        ` : '';
        
        return `
            <div class="todo-item todo-card ${priorityClass} ${completedClass}">
                <div class="todo-checkbox ${checkedClass}" onclick="TodoManager.toggleTodo(this)" 
                     data-member="${userId}" data-id="${todo.id}"></div>
                <div class="todo-content" onclick="TodoManager.showEditTodoForm(${todo.id}, ${userId})">
                    <div class="todo-text ${completedClass}">
                        ${todo.text}
                        ${todo.note ? `<div class="todo-note">${todo.note}</div>` : ''}
                    </div>
                    <div class="todo-right">
                        <div class="todo-time ${timeSpecificClass}">${todo.time}</div>
                        <div class="todo-period">${todo.period}</div>
                        <div class="todo-cycle">${todo.cycle}</div>
                        ${syncIndicator}
                    </div>
                </div>
            </div>
        `;
    },

    // 获取同步状态
    getSyncStatus(userId) {
        // 检查用户是否有关联关系
        const user = UserManager.users.find(u => u.id === userId);
        if (!user) {
            return { isLinked: false };
        }
        
        // 检查是否已关联
        if (user.is_linked && user.supervised_app_user) {
            return {
                isLinked: true,
                status: 'synced',
                icon: '🔗',
                tooltip: `已与 ${user.supervised_app_user} 同步`
            };
        }
        
        // 检查是否有待处理的关联请求
        if (this.hasPendingLinkRequest && this.hasPendingLinkRequest(userId)) {
            return {
                isLinked: true,
                status: 'pending',
                icon: '⏳',
                tooltip: '关联请求处理中'
            };
        }
        
        return { isLinked: false };
    },

    // 检查是否有待处理的关联请求
    hasPendingLinkRequest(userId) {
        // 这个方法可以通过全局状态或API调用来实现
        // 暂时返回false，后续可以集成
        return false;
    },

    // 显示同步状态提示
    showSyncStatusToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `sync-toast ${type}`;
        toast.innerHTML = `
            <span class="sync-toast-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
            <span class="sync-toast-message">${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // 显示动画
        setTimeout(() => toast.classList.add('show'), 100);
        
        // 3秒后移除
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    },

    // 切换TODO状态
    async toggleTodo(checkbox) {
        const todoId = parseInt(checkbox.dataset.id);
        const userId = parseInt(checkbox.dataset.member);
        
        if (!todoId || !userId) return;

        // 找到对应的todo项
        const todo = this.todos[userId]?.find(t => t.id === todoId);
        if (!todo) return;

        const wasCompleted = todo.completed;
        const currentDate = DateManager.selectedDate || new Date();
        const dateStr = currentDate.toISOString().split('T')[0];
        
        try {
            // 同步到服务器 - 优先使用WebSocket
            if (WebSocketClient.isConnected) {
                if (wasCompleted) {
                    await WebSocketClient.todos.uncomplete(todoId, dateStr);
                } else {
                    await WebSocketClient.todos.complete(todoId, userId, dateStr);
                }
            } else {
                // 降级到HTTP
                if (wasCompleted) {
                    await ApiClient.todos.uncomplete(todoId, dateStr);
                } else {
                    await ApiClient.todos.complete(todoId, userId, dateStr);
                }
            }

            // 切换本地状态
            todo.completed = !todo.completed;
            
            // 清除当前日期的缓存，确保状态同步
            const cacheKey = `${userId}_${dateStr}`;
            this.todoCache.delete(cacheKey);
            console.log('🧹 TODO状态切换：清除缓存', cacheKey);
            
            // 更新UI
            const todoItem = checkbox.closest('.todo-item');
            const todoContent = checkbox.nextElementSibling;
            const todoText = todoContent?.querySelector('.todo-text');
            
            if (todo.completed) {
                checkbox.classList.add('checked');
                if (todoText) todoText.classList.add('completed');
                if (todoItem) todoItem.classList.add('completed');
            } else {
                checkbox.classList.remove('checked');
                if (todoText) todoText.classList.remove('completed');
                if (todoItem) todoItem.classList.remove('completed');
            }
            
            // 检查是否有关联用户，显示同步状态
            const syncStatus = this.getSyncStatus(userId);
            if (syncStatus.isLinked) {
                const action = todo.completed ? '完成' : '取消完成';
                this.showSyncStatusToast(`${action}状态已同步`, 'success');
            }
            
        } catch (error) {
            console.error('切换TODO状态失败:', error);
            // 恢复原状态
            todo.completed = wasCompleted;
            this.showMessage('操作失败: ' + error.message, 'error');
        }
    },

    // 显示添加TODO表单
    showAddTodoForm(userId) {
        const user = UserManager.getUser(userId);
        if (!user) return;
        
        const formHtml = `
            <div class="modal-overlay" id="addTodoModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>为 ${user.display_name || user.username} 添加新TODO</h3>
                        <button class="modal-close" onclick="TodoManager.closeAddTodoForm()">×</button>
                    </div>
                    <form class="todo-form" onsubmit="TodoManager.handleAddTodo(event, ${userId})">
                        <div class="form-group">
                            <label for="todo_title">标题 *</label>
                            <input type="text" id="todo_title" name="title" required maxlength="200" placeholder="例如：吃鱼肝油">
                        </div>
                        <div class="form-group">
                            <label for="todo_start_date">开始日期</label>
                            <input type="date" id="todo_start_date" name="start_date" value="${(DateManager.selectedDate || new Date()).toISOString().split('T')[0]}">
                        </div>
                        <div class="form-group">
                            <label for="todo_description">备注</label>
                            <textarea id="todo_description" name="description" maxlength="1000" placeholder="详细说明（可选）"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="todo_time">提醒时间</label>
                            <select id="todo_time" name="reminder_time">
                                <option value="all_day">当天</option>
                                <option value="06:00">06:00</option>
                                <option value="07:00">07:00</option>
                                <option value="08:00">08:00</option>
                                <option value="09:00">09:00</option>
                                <option value="10:00">10:00</option>
                                <option value="11:00">11:00</option>
                                <option value="12:00">12:00</option>
                                <option value="13:00">13:00</option>
                                <option value="14:00">14:00</option>
                                <option value="15:00">15:00</option>
                                <option value="16:00">16:00</option>
                                <option value="17:00">17:00</option>
                                <option value="18:00">18:00</option>
                                <option value="19:00">19:00</option>
                                <option value="20:00">20:00</option>
                                <option value="21:00">21:00</option>
                                <option value="22:00">22:00</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo_priority">优先级</label>
                            <select id="todo_priority" name="priority">
                                <option value="low">低</option>
                                <option value="medium" selected>中</option>
                                <option value="high">高</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo_repeat">重复频率</label>
                            <select id="todo_repeat" name="repeat_type" onchange="TodoManager.handleRepeatChange(this)">
                                <option value="none">不重复</option>
                                <option value="daily" selected>每天</option>
                                <option value="every_other_day">隔天</option>
                                <option value="weekly">每周</option>
                                <option value="monthly">每月</option>
                                <option value="yearly">每年</option>
                                <option value="custom">自定义</option>
                            </select>
                        </div>
                        <div class="form-group" id="custom_interval_group" style="display: none;">
                            <label for="custom_interval">自定义间隔</label>
                            <div class="form-row">
                                <input type="number" id="custom_interval" name="custom_interval" min="1" max="365" value="2" style="width: 80px;">
                                <span style="margin-left: 8px;">天一次</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="todo_cycle">重复周期</label>
                            <select id="todo_cycle" name="cycle_type" onchange="TodoManager.handleCycleChange(this)">
                                <option value="long_term" selected>长期</option>
                                <option value="custom">自定义周期</option>
                            </select>
                        </div>
                        <div class="form-group" id="custom_cycle_group" style="display: none;">
                            <label for="cycle_duration">周期时长</label>
                            <div class="form-row" style="display: table !important; width: 100% !important; table-layout: fixed !important; border-collapse: separate !important; border-spacing: 8px 0 !important;">
                                <input type="number" id="cycle_duration" name="cycle_duration" min="1" max="365" value="1" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; text-align: center !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important;">
                                <select id="cycle_unit" name="cycle_unit" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important; cursor: pointer !important;">
                                    <option value="days">天</option>
                                    <option value="weeks">周</option>
                                    <option value="months">月</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-actions">
                            <button type="button" onclick="TodoManager.closeAddTodoForm()">取消</button>
                            <button type="submit">添加TODO</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // 关闭添加TODO表单
    closeAddTodoForm() {
        const modal = document.getElementById('addTodoModal');
        if (modal) {
            modal.remove();
        }
    },

    // 处理添加TODO表单提交
    async handleAddTodo(event, userId) {
        event.preventDefault();
        
        const formData = new FormData(event.target);
        const repeatType = formData.get('repeat_type') || 'none';
        const customInterval = parseInt(formData.get('custom_interval')) || 1;
        const cycleType = formData.get('cycle_type') || 'long_term';
        const cycleDuration = parseInt(formData.get('cycle_duration')) || null;
        const cycleUnit = formData.get('cycle_unit') || 'days';
        
        console.log('📋 表单数据调试:');
        console.log('  cycleType:', cycleType);
        console.log('  cycleDuration:', cycleDuration);
        console.log('  cycleUnit:', cycleUnit);
        
        // 使用当前选中的日期作为开始日期，如果用户修改了日期则使用用户选择的日期
        const selectedStartDate = formData.get('start_date') || (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
        
        const todoData = {
            user_id: userId,
            title: formData.get('title'),
            description: formData.get('description') || '',
            reminder_time: formData.get('reminder_time') || 'all_day',
            priority: formData.get('priority') || 'medium',
            repeat_type: repeatType,
            repeat_interval: repeatType === 'custom' ? customInterval : 1,
            cycle_type: cycleType,
            cycle_duration: cycleType === 'custom' ? cycleDuration : null,
            cycle_unit: cycleType === 'custom' ? cycleUnit : 'days',
            start_date: selectedStartDate
        };
        
        console.log('📤 发送到服务器的TODO数据:', todoData);

        try {
            // 在服务器创建TODO - 优先使用WebSocket
            let response;
            if (WebSocketClient.isConnected) {
                response = await WebSocketClient.todos.create(todoData);
                // WebSocket返回格式调整
                if (response.data && response.data.todo) {
                    const newTodo = this.convertApiTodoToLocal(response.data.todo);
                    console.log('✅ 通过WebSocket创建TODO成功');
                } else {
                    throw new Error('WebSocket响应格式错误');
                }
            } else {
                response = await ApiClient.todos.create(todoData);
                if (response.success) {
                    const newTodo = this.convertApiTodoToLocal(response.data);
                    console.log('✅ 通过HTTP创建TODO成功');
                } else {
                    throw new Error(response.message || '创建TODO失败');
                }
            }
            
            // 关闭表单
            this.closeAddTodoForm();
            
            // 清除该用户的所有缓存，因为新TODO可能是长期重复任务，影响多个日期
            this.clearAllRelatedCache(userId);
            
            // 重新加载当前日期的TODO数据，这样会正确显示/隐藏TODO
            const currentDate = DateManager.selectedDate || new Date();
            await this.loadTodosForDate(currentDate, userId);
            
            // 显示成功消息
            this.showMessage('TODO添加成功！', 'success');
            
        } catch (error) {
            console.error('添加TODO失败:', error);
            this.showMessage('添加TODO失败: ' + error.message, 'error');
        }
    },

    // 处理重复频率变化
    handleRepeatChange(select) {
        const customGroup = document.getElementById('custom_interval_group');
        if (customGroup) {
            customGroup.style.display = select.value === 'custom' ? 'block' : 'none';
        }
    },

    // 处理重复周期变化
    handleCycleChange(select) {
        const customCycleGroup = document.getElementById('custom_cycle_group');
        if (customCycleGroup) {
            customCycleGroup.style.display = select.value === 'custom' ? 'block' : 'none';
        }
    },

    // 显示编辑TODO表单
    showEditTodoForm(todoId, userId) {
        const todo = this.todos[userId]?.find(t => t.id === todoId);
        if (!todo) return;
        
        const user = UserManager.getUser(userId);
        if (!user) return;
        
        const formHtml = `
            <div class="modal-overlay" id="editTodoModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>编辑 ${user.display_name || user.username} 的TODO</h3>
                        <button class="modal-close" onclick="TodoManager.closeEditTodoForm()">×</button>
                    </div>
                    <form class="todo-form" onsubmit="TodoManager.handleEditTodo(event, '${todoId}', ${userId})">
                        <div class="form-group">
                            <label for="edit_todo_title">标题 *</label>
                            <input type="text" id="edit_todo_title" name="title" required maxlength="200" value="${todo.text}" placeholder="例如：吃鱼肝油">
                        </div>
                        <div class="form-group">
                            <label for="edit_todo_start_date">开始日期</label>
                            <input type="date" id="edit_todo_start_date" name="start_date" value="${todo.createdDate}">
                        </div>
                        <div class="form-group">
                            <label for="edit_todo_description">备注</label>
                            <textarea id="edit_todo_description" name="description" maxlength="1000" placeholder="详细说明（可选）">${todo.note || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label for="edit_todo_time">提醒时间</label>
                            <select id="edit_todo_time" name="reminder_time">
                                <option value="all_day" ${todo.time === '当天' ? 'selected' : ''}>当天</option>
                                <option value="06:00" ${todo.time === '06:00' ? 'selected' : ''}>06:00</option>
                                <option value="07:00" ${todo.time === '07:00' ? 'selected' : ''}>07:00</option>
                                <option value="08:00" ${todo.time === '08:00' ? 'selected' : ''}>08:00</option>
                                <option value="09:00" ${todo.time === '09:00' ? 'selected' : ''}>09:00</option>
                                <option value="10:00" ${todo.time === '10:00' ? 'selected' : ''}>10:00</option>
                                <option value="11:00" ${todo.time === '11:00' ? 'selected' : ''}>11:00</option>
                                <option value="12:00" ${todo.time === '12:00' ? 'selected' : ''}>12:00</option>
                                <option value="13:00" ${todo.time === '13:00' ? 'selected' : ''}>13:00</option>
                                <option value="14:00" ${todo.time === '14:00' ? 'selected' : ''}>14:00</option>
                                <option value="15:00" ${todo.time === '15:00' ? 'selected' : ''}>15:00</option>
                                <option value="16:00" ${todo.time === '16:00' ? 'selected' : ''}>16:00</option>
                                <option value="17:00" ${todo.time === '17:00' ? 'selected' : ''}>17:00</option>
                                <option value="18:00" ${todo.time === '18:00' ? 'selected' : ''}>18:00</option>
                                <option value="19:00" ${todo.time === '19:00' ? 'selected' : ''}>19:00</option>
                                <option value="20:00" ${todo.time === '20:00' ? 'selected' : ''}>20:00</option>
                                <option value="21:00" ${todo.time === '21:00' ? 'selected' : ''}>21:00</option>
                                <option value="22:00" ${todo.time === '22:00' ? 'selected' : ''}>22:00</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="edit_todo_priority">优先级</label>
                            <select id="edit_todo_priority" name="priority">
                                <option value="low" ${todo.priority === 'low' ? 'selected' : ''}>低</option>
                                <option value="medium" ${!todo.priority || todo.priority === 'medium' ? 'selected' : ''}>中</option>
                                <option value="high" ${todo.priority === 'high' ? 'selected' : ''}>高</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="edit_todo_repeat">重复频率</label>
                            <select id="edit_todo_repeat" name="repeat_type" onchange="TodoManager.handleEditRepeatChange(this, '${todo.customInterval || 1}')">
                                <option value="none" ${!todo.periodType || todo.periodType === 'none' ? 'selected' : ''}>不重复</option>
                                <option value="daily" ${todo.periodType === 'daily' ? 'selected' : ''}>每天</option>
                                <option value="every_other_day" ${todo.periodType === 'every_other_day' ? 'selected' : ''}>隔天</option>
                                <option value="weekly" ${todo.periodType === 'weekly' ? 'selected' : ''}>每周</option>
                                <option value="monthly" ${todo.periodType === 'monthly' ? 'selected' : ''}>每月</option>
                                <option value="yearly" ${todo.periodType === 'yearly' ? 'selected' : ''}>每年</option>
                                <option value="custom" ${todo.periodType === 'custom' ? 'selected' : ''}>自定义</option>
                            </select>
                        </div>
                        <div class="form-group" id="edit_custom_interval_group" style="display: ${todo.periodType === 'custom' ? 'block' : 'none'};">
                            <label for="edit_custom_interval">自定义间隔</label>
                            <div class="form-row">
                                <input type="number" id="edit_custom_interval" name="custom_interval" min="1" max="365" value="${todo.customInterval || 1}" style="width: 80px;">
                                <span style="margin-left: 8px;">天一次</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="edit_todo_cycle">重复周期</label>
                            <select id="edit_todo_cycle" name="cycle_type" onchange="TodoManager.handleEditCycleChange(this, '${todo.cycleDuration || 1}', '${todo.cycleUnit || 'days'}')">
                                <option value="long_term" ${!todo.cycleType || todo.cycleType === 'long_term' ? 'selected' : ''}>长期</option>
                                <option value="custom" ${todo.cycleType === 'custom' ? 'selected' : ''}>自定义周期</option>
                            </select>
                        </div>
                        <div class="form-group" id="edit_custom_cycle_group" style="display: ${todo.cycleType === 'custom' ? 'block' : 'none'};">
                            <label for="edit_cycle_duration">周期时长</label>
                            <div class="form-row" style="display: table !important; width: 100% !important; table-layout: fixed !important; border-collapse: separate !important; border-spacing: 8px 0 !important;">
                                <input type="number" id="edit_cycle_duration" name="cycle_duration" min="1" max="365" value="${todo.cycleDuration || 1}" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; text-align: center !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important;">
                                <select id="edit_cycle_unit" name="cycle_unit" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important; cursor: pointer !important;">
                                    <option value="days" ${todo.cycleUnit === 'days' ? 'selected' : ''}>天</option>
                                    <option value="weeks" ${todo.cycleUnit === 'weeks' ? 'selected' : ''}>周</option>
                                    <option value="months" ${todo.cycleUnit === 'months' ? 'selected' : ''}>月</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-actions">
                            <button type="button" class="delete-btn" onclick="TodoManager.deleteTodo('${todoId}', ${userId})">删除</button>
                            <button type="button" onclick="TodoManager.closeEditTodoForm()">取消</button>
                            <button type="submit">保存</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // 关闭编辑TODO表单
    closeEditTodoForm() {
        const modal = document.getElementById('editTodoModal');
        if (modal) {
            modal.remove();
        }
    },

    // 处理编辑TODO表单提交
    async handleEditTodo(event, todoId, userId) {
        event.preventDefault();
        
        const formData = new FormData(event.target);
        const repeatType = formData.get('repeat_type') || 'none';
        const customInterval = parseInt(formData.get('custom_interval')) || 1;
        const cycleType = formData.get('cycle_type') || 'long_term';
        const cycleDuration = parseInt(formData.get('cycle_duration')) || null;
        const cycleUnit = formData.get('cycle_unit') || 'days';
        
        const updateData = {
            title: formData.get('title'),
            description: formData.get('description') || '',
            reminder_time: formData.get('reminder_time') || 'all_day',
            priority: formData.get('priority') || 'medium',
            repeat_type: repeatType,
            repeat_interval: repeatType === 'custom' ? customInterval : 1,
            cycle_type: cycleType,
            cycle_duration: cycleType === 'custom' ? cycleDuration : null,
            cycle_unit: cycleType === 'custom' ? cycleUnit : 'days',
            start_date: formData.get('start_date')
        };

        try {
            // 在服务器更新TODO
            const response = await ApiClient.todos.update(todoId, updateData);
            if (response.success) {
                console.log('✅ 在服务器更新TODO成功');
                
                // 关闭表单
                this.closeEditTodoForm();
                
                // 清除该用户的所有缓存，因为编辑可能改变了重复规则，影响多个日期
                this.clearAllRelatedCache(this.currentUser);
                
                // 重新加载当前日期的TODO数据，这样会正确显示/隐藏TODO
                const currentDate = DateManager.selectedDate || new Date();
                await this.loadTodosForDate(currentDate, this.currentUser);
                
                // 显示成功消息
                this.showMessage('TODO更新成功！', 'success');
            } else {
                throw new Error(response.message || '更新TODO失败');
            }
            
        } catch (error) {
            console.error('更新TODO失败:', error);
            this.showMessage('更新TODO失败: ' + error.message, 'error');
        }
    },

    // 处理编辑重复频率变化
    handleEditRepeatChange(select, defaultInterval) {
        const customGroup = document.getElementById('edit_custom_interval_group');
        if (customGroup) {
            customGroup.style.display = select.value === 'custom' ? 'block' : 'none';
            if (select.value === 'custom') {
                const intervalInput = document.getElementById('edit_custom_interval');
                if (intervalInput && !intervalInput.value) {
                    intervalInput.value = defaultInterval;
                }
            }
        }
    },

    // 处理编辑重复周期变化
    handleEditCycleChange(select, defaultDuration, defaultUnit) {
        const customCycleGroup = document.getElementById('edit_custom_cycle_group');
        if (customCycleGroup) {
            customCycleGroup.style.display = select.value === 'custom' ? 'block' : 'none';
            if (select.value === 'custom') {
                const durationInput = document.getElementById('edit_cycle_duration');
                const unitSelect = document.getElementById('edit_cycle_unit');
                if (durationInput && !durationInput.value) {
                    durationInput.value = defaultDuration;
                }
                if (unitSelect && !unitSelect.value) {
                    unitSelect.value = defaultUnit;
                }
            }
        }
    },

    // 删除TODO - 智能删除对话框
    async deleteTodo(todoId, userId) {
        const todo = this.todos[userId]?.find(t => t.id == todoId);
        if (!todo) return;

        // 如果是重复任务，显示删除选项对话框
        if (todo.periodType && todo.periodType !== 'none') {
            this.showDeleteOptionsDialog(todoId, userId, todo);
        } else {
            // 一次性任务，直接确认删除
            if (confirm('确定要删除这个TODO吗？')) {
                await this.performDelete(todoId, userId, 'all');
            }
        }
    },

    // 显示删除选项对话框
    showDeleteOptionsDialog(todoId, userId, todo) {
        const currentDate = DateManager.selectedDate || new Date();
        const currentDateStr = this.formatDate(currentDate);
        
        const dialogHtml = `
            <div class="modal-overlay" id="deleteOptionsModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>删除重复任务</h3>
                        <button class="modal-close" onclick="TodoManager.closeDeleteOptionsDialog()">×</button>
                    </div>
                    <div class="delete-options-content">
                        <p>这是一个重复任务："${todo.text}"</p>
                        <p>你想要删除：</p>
                        <div class="delete-options">
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="single" checked>
                                <span>只删除 ${currentDateStr} 的这个任务</span>
                            </label>
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="from_date">
                                <span>删除 ${currentDateStr} 及以后的所有任务</span>
                            </label>
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="all">
                                <span>删除所有日期的这个任务</span>
                            </label>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" onclick="TodoManager.closeDeleteOptionsDialog()">取消</button>
                        <button type="button" class="delete-btn" onclick="TodoManager.confirmDelete(${todoId}, ${userId})">删除</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', dialogHtml);
    },

    // 关闭删除选项对话框
    closeDeleteOptionsDialog() {
        const modal = document.getElementById('deleteOptionsModal');
        if (modal) {
            modal.remove();
        }
    },

    // 确认删除
    async confirmDelete(todoId, userId) {
        const selectedOption = document.querySelector('input[name="deleteOption"]:checked');
        if (!selectedOption) return;

        const deletionType = selectedOption.value;
        const currentDate = DateManager.selectedDate || new Date();
        const deletionDate = currentDate.toISOString().split('T')[0];

        this.closeDeleteOptionsDialog();
        await this.performDelete(todoId, userId, deletionType, deletionDate);
    },

    // 执行删除操作
    async performDelete(todoId, userId, deletionType, deletionDate = null) {
        try {
            // 在服务器删除TODO
            const response = await ApiClient.todos.delete(todoId, deletionType, deletionDate);
            if (response.success) {
                console.log('✅ 在服务器删除TODO成功');
                
                // 清除该用户的所有缓存，因为删除可能影响多个日期（特别是长期重复任务）
                this.clearAllRelatedCache(this.currentUser);
                
                // 重新加载当前日期的TODO数据
                const currentDate = DateManager.selectedDate || new Date();
                await this.loadTodosForDate(currentDate, this.currentUser);
                
                // 关闭编辑表单（如果打开的话）
                this.closeEditTodoForm();
                
                // 显示成功消息
                this.showMessage(response.message || 'TODO删除成功！', 'success');
            } else {
                throw new Error(response.message || '删除TODO失败');
            }
            
        } catch (error) {
            console.error('删除TODO失败:', error);
            this.showMessage('删除TODO失败: ' + error.message, 'error');
        }
    },

    // 注意：日期导航现在由DateManager统一处理

    // 加载指定日期的TODO（优化版，支持缓存）
    async loadTodosForDate(date, userId = null, silent = false) {
        const dateStr = date.toISOString().split('T')[0];
        const targetUserId = userId || this.currentUser;
        
        if (!silent) {
            console.log('🔄 开始加载指定日期的TODO数据...');
            console.log('📅 目标日期:', dateStr, '用户ID:', targetUserId);
        }
        
        try {
            // 检查缓存 - 确保使用正确的用户ID
            const cacheKey = `${targetUserId}_${dateStr}`;
            if (this.todoCache.has(cacheKey)) {
                if (!silent) console.log('📦 使用缓存数据，用户:', targetUserId);
                const cachedData = this.todoCache.get(cacheKey);
                // 确保数据存储在正确的用户下
                this.todos[targetUserId] = [...cachedData]; // 创建副本避免引用问题
                this.renderTodoPanel(targetUserId);
                this.lastLoadedDate = dateStr;
                return;
            }
            
            if (!silent) console.log('🔍 缓存未命中，从服务器加载数据，用户:', targetUserId);
            
            // 如果指定了用户ID，只加载该用户的数据；否则只加载当前用户的数据
            const usersToLoad = userId ? [UserManager.getUser(userId)].filter(Boolean) : [UserManager.getUser(targetUserId)].filter(Boolean);
            
            for (const user of usersToLoad) {
                try {
                    let response;
                    if (WebSocketClient.isConnected) {
                        if (!silent) console.log(`🔌 使用WebSocket加载用户${user.id}的TODO数据...`);
                        response = await WebSocketClient.todos.getTodosForDate(user.id, dateStr);
                        this.todos[user.id] = response.data.todos.map(todo => this.convertApiTodoToLocal(todo));
                    } else {
                        if (!silent) console.log(`🌐 使用HTTP加载用户${user.id}的TODO数据...`);
                        response = await ApiClient.todos.getTodosForDate(user.id, dateStr);
                        if (response.success) {
                            this.todos[user.id] = response.data.map(todo => this.convertApiTodoToLocal(todo));
                        }
                    }
                    
                    // 存入缓存
                    const userCacheKey = `${user.id}_${dateStr}`;
                    this.todoCache.set(userCacheKey, [...this.todos[user.id]]);
                    
                    if (!silent) {
                        console.log(`✅ 已加载用户${user.id}在${dateStr}的TODO数据，数量:`, this.todos[user.id].length);
                    }
                } catch (error) {
                    console.warn(`加载用户${user.id}在${dateStr}的TODO失败:`, error.message);
                    this.todos[user.id] = [];
                }
            }
            
            // 清理缓存（保留最近5个日期的数据）
            if (this.todoCache.size > 50) { // 10用户 * 5天 = 50个缓存项
                const sortedKeys = Array.from(this.todoCache.keys()).sort();
                const keysToDelete = sortedKeys.slice(0, sortedKeys.length - 50);
                keysToDelete.forEach(key => this.todoCache.delete(key));
            }
            
            // 渲染当前用户的TODO面板
            if (targetUserId) {
                this.renderTodoPanel(targetUserId);
                this.lastLoadedDate = dateStr;
                if (!silent) console.log('✅ TODO面板渲染完成');
            } else {
                console.warn('⚠️ 无法确定要渲染哪个用户的TODO面板');
            }
            
        } catch (error) {
            console.error('加载日期TODO失败:', error);
            if (!silent) this.showMessage('加载TODO失败: ' + error.message, 'error');
        }
    },

    // 格式化日期显示
    formatDate(date) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        
        const month = months[date.getMonth()];
        const day = date.getDate();
        const weekday = weekdays[date.getDay()];
        
        return `${month} ${day} ${weekday}`;
    },

    // 显示消息
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        `;
        
        switch (type) {
            case 'success':
                messageEl.style.backgroundColor = '#4CAF50';
                break;
            case 'error':
                messageEl.style.backgroundColor = '#f44336';
                break;
            case 'warning':
                messageEl.style.backgroundColor = '#ff9800';
                break;
            default:
                messageEl.style.backgroundColor = '#2196F3';
        }
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 3000);
    },

    // 处理WebSocket广播消息（来自其他设备的操作）
    handleWebSocketBroadcast(type, data) {
        console.log('🔄 处理TODO广播消息:', type, data);
        
        switch (type) {
            case 'TODO_CREATE_BROADCAST':
            case 'TODO_UPDATE_BROADCAST':
            case 'TODO_DELETE_BROADCAST':
                // 清除所有用户的缓存，因为广播可能来自其他设备，影响所有用户
                console.log('🧹 广播消息：清除所有缓存');
                this.clearAllRelatedCache();
                // 重新加载当前日期的TODO数据
                this.loadTodosForDate(DateManager.selectedDate || new Date(), this.currentUser);
                break;
                
            case 'TODO_COMPLETE_BROADCAST':
            case 'TODO_UNCOMPLETE_BROADCAST':
                // 完成状态变化也要清除缓存，确保数据同步
                console.log('🧹 完成状态广播：清除相关用户缓存');
                if (data.userId) {
                    this.clearAllRelatedCache(data.userId);
                } else {
                    this.clearAllRelatedCache();
                }
                // 重新加载当前日期的数据
                this.loadTodosForDate(DateManager.selectedDate || new Date(), this.currentUser);
                break;
        }
    },

    // 降级到HTTP模式
    fallbackToHTTP() {
        console.log('📡 TODO模块降级到HTTP模式');
        // 目前的实现已经自动处理降级，无需额外操作
    },

    // 清除所有相关缓存 - 彻底清理方法
    clearAllRelatedCache(userId = null) {
        console.log('🧹 开始清除所有相关缓存...', userId ? `用户${userId}` : '所有用户');
        
        if (userId) {
            // 清除指定用户的所有缓存
            const keysToDelete = [];
            for (const key of this.todoCache.keys()) {
                if (key.startsWith(`${userId}_`)) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => {
                this.todoCache.delete(key);
                console.log('🗑️ 删除缓存:', key);
            });
            console.log(`✅ 已清除用户${userId}的${keysToDelete.length}个缓存项`);
        } else {
            // 清除所有缓存
            const cacheCount = this.todoCache.size;
            this.todoCache.clear();
            console.log(`✅ 已清除所有${cacheCount}个缓存项`);
        }
    },

    // 清除指定用户指定日期范围的缓存
    clearCacheForDateRange(userId, startDate = null, endDate = null) {
        console.log('🧹 清除日期范围缓存...', {userId, startDate, endDate});
        
        const keysToDelete = [];
        for (const key of this.todoCache.keys()) {
            if (!key.startsWith(`${userId}_`)) continue;
            
            const dateStr = key.split('_')[1];
            if (!startDate && !endDate) {
                // 如果没有指定日期范围，清除该用户所有缓存
                keysToDelete.push(key);
            } else if (startDate && endDate) {
                // 检查日期是否在范围内
                if (dateStr >= startDate && dateStr <= endDate) {
                    keysToDelete.push(key);
                }
            } else if (startDate) {
                // 只有开始日期，清除该日期及以后的缓存
                if (dateStr >= startDate) {
                    keysToDelete.push(key);
                }
            }
        }
        
        keysToDelete.forEach(key => {
            this.todoCache.delete(key);
            console.log('🗑️ 删除范围缓存:', key);
        });
        
        console.log(`✅ 已清除用户${userId}的${keysToDelete.length}个日期范围缓存项`);
    },

    // 绑定事件
    bindEvents() {
        // 用户标签点击事件现在由GlobalUserState统一处理
        // 不需要在这里重复绑定事件
    }
};

// 导出到全局
window.TodoManager = TodoManager;


// Notes管理器 - 健康笔记功能
const NotesManager = {
    notes: {},
    currentUser: 1,
    isOnline: false,

    // 初始化
    async init() {
        console.log('🔄 初始化Notes管理器...');
        
        // 检查后端连接
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.warn('⚠️ 后端服务不可用，Notes功能将无法正常工作');
            this.showOfflineError();
            return;
        }

        // 等待用户管理器初始化完成
        await this.waitForUserManager();
        
        // 加载Notes数据
        await this.loadNotesFromAPI();
        
        // 设置默认用户
        this.setDefaultUser();
        
        // 监听全局用户状态变化，但不设置模块
        if (window.GlobalUserState) {
            GlobalUserState.addListener(this.handleGlobalStateChange.bind(this));
        }
        
        // 渲染界面
        this.renderNotesPanel(this.currentUser);
        this.bindEvents();
        
        console.log('✅ Notes管理器初始化完成');
    },

    // 等待用户管理器初始化完成
    async waitForUserManager() {
        if (UserManager.users.length === 0) {
            await new Promise(resolve => {
                const checkUsers = () => {
                    if (UserManager.users.length > 0) {
                        resolve();
                    } else {
                        setTimeout(checkUsers, 100);
                    }
                };
                checkUsers();
            });
        }
    },

    // 从API加载Notes数据
    async loadNotesFromAPI() {
        try {
            for (const user of UserManager.users) {
                console.log(`📥 加载用户 ${user.username} 的Notes...`);
                const response = await ApiClient.notes.getByUserId(user.id);
                
                if (response.success) {
                    this.notes[user.id] = response.data || [];
                    console.log(`✅ 用户 ${user.username} 的Notes加载完成: ${this.notes[user.id].length} 条`);
                } else {
                    console.warn(`⚠️ 加载用户 ${user.username} 的Notes失败:`, response.message);
                    this.notes[user.id] = [];
                }
            }
        } catch (error) {
            console.error('❌ 加载Notes数据失败:', error);
            this.showMessage('加载笔记数据失败: ' + error.message, 'error');
            // 初始化空数据
            UserManager.users.forEach(user => {
                this.notes[user.id] = [];
            });
        }
    },

    // 设置默认用户
    setDefaultUser() {
        if (UserManager.users.length > 0) {
            // 优先使用全局状态的用户
            let defaultUser = UserManager.users[0].id;
            
            if (window.GlobalUserState && GlobalUserState.getCurrentUser()) {
                defaultUser = GlobalUserState.getCurrentUser();
            }
            
            this.currentUser = defaultUser;
            
            // 同步到全局状态
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentUser(defaultUser);
            }
            
            console.log('📍 设置默认用户:', this.currentUser);
        }
    },

    // 处理全局状态变化
    handleGlobalStateChange(type, data) {
        console.log('📢 Notes管理器收到全局状态变化:', type, data);
        
        if (type === 'userChanged') {
            const newUserId = data.userId;
            if (this.currentUser !== newUserId) {
                this.currentUser = newUserId;
                // 只有当前模块是notes时才渲染
                if (GlobalUserState.getCurrentModule() === 'notes') {
                    console.log('✅ 当前是Notes模块，渲染Notes内容');
                    this.renderNotesPanel(newUserId);
                } else {
                    console.log('⏸️ 当前不是Notes模块，跳过渲染');
                }
            }
        }
    },

    // 渲染Notes面板
    renderNotesPanel(userId) {
        const contentArea = Utils.$('#contentArea');
        if (!contentArea) return;

        const userNotes = this.notes[userId] || [];
        console.log(`🎨 渲染用户 ${userId} 的Notes面板，共 ${userNotes.length} 条笔记`);

        const panelHtml = `
            <div class="content-panel" id="${userId}-notes-panel">
                <div class="notes-content">
                    <div class="notes-container">
                        ${userNotes.length > 0 
                            ? userNotes.map(note => this.renderNoteCard(note, userId)).join('')
                            : this.renderEmptyState()
                        }
                    </div>
                </div>
                <button class="new-note-btn" onclick="NotesManager.showAddNoteForm(${userId})">+ 添加新笔记</button>
            </div>
        `;

        contentArea.innerHTML = panelHtml;
    },

    // 渲染笔记卡片
    renderNoteCard(note, userId) {
        const shortDescription = note.description.length > 50 
            ? note.description.substring(0, 50) + '...' 
            : note.description;

        // 获取同步状态
        const syncStatus = this.getSyncStatus(note.user_id);
        const syncIndicator = syncStatus.isLinked ? `
            <div class="sync-indicator ${syncStatus.status}" title="${syncStatus.tooltip}">
                <span class="sync-icon">${syncStatus.icon}</span>
            </div>
        ` : '';

        return `
            <div class="note-card clickable" data-note-id="${note.id}" onclick="NotesManager.showNoteDetails(${note.id})">
                <div class="note-header">
                    <div class="note-title-container">
                        <h3 class="note-title">${Utils.escapeHtml(note.title)}</h3>
                        ${syncIndicator}
                    </div>
                    <div class="note-actions" onclick="event.stopPropagation()">
                        <button class="note-action-btn" onclick="NotesManager.shareNote(${note.id})" title="分享">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.50-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
                            </svg>
                        </button>
                        <button class="note-action-btn" onclick="NotesManager.showEditNoteForm(${note.id})" title="编辑">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                        </button>
                        <button class="note-action-btn delete" onclick="NotesManager.deleteNote(${note.id})" title="删除">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                ${shortDescription ? `<p class="note-description">${Utils.escapeHtml(shortDescription)}</p>` : ''}
                ${note.precautions ? `<div class="note-precautions">
                    <strong>注意事项:</strong> ${Utils.escapeHtml(note.precautions.length > 80 ? note.precautions.substring(0, 80) + '...' : note.precautions)}
                </div>` : ''}
            </div>
        `;
    },

    // 获取同步状态
    getSyncStatus(userId) {
        // 检查用户是否有关联关系
        const user = UserManager.users.find(u => u.id === userId);
        if (!user) {
            return { isLinked: false };
        }
        
        // 检查是否已关联
        if (user.is_linked && user.supervised_app_user) {
            return {
                isLinked: true,
                status: 'synced',
                icon: '🔗',
                tooltip: `已与 ${user.supervised_app_user} 同步`
            };
        }
        
        return { isLinked: false };
    },

    // 显示同步状态提示
    showSyncStatusToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `sync-toast ${type}`;
        toast.innerHTML = `
            <span class="sync-toast-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
            <span class="sync-toast-message">${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // 显示动画
        setTimeout(() => toast.classList.add('show'), 100);
        
        // 3秒后移除
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    },

    // 渲染空状态
    renderEmptyState() {
        return `
            <div class="notes-empty-state">
                <div class="empty-icon">📝</div>
                <h3>还没有健康笔记</h3>
                <p>开始记录您的健康状况和注意事项</p>
            </div>
        `;
    },

    // 显示添加笔记表单
    showAddNoteForm(userId) {
        const formHtml = `
            <div class="modal-overlay" id="addNoteModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>添加健康笔记</h3>
                        <button class="modal-close" onclick="NotesManager.closeNoteForm()">×</button>
                    </div>
                    <form class="note-form" onsubmit="NotesManager.handleAddNote(event, ${userId})">
                        <div class="form-group">
                            <label for="note-title">健康状况标题 *</label>
                            <input type="text" id="note-title" name="title" required maxlength="100" 
                                   placeholder="如：关节炎、血压高、轻度抑郁等">
                        </div>
                        <div class="form-group">
                            <label for="note-description">详细描述</label>
                            <textarea id="note-description" name="description" rows="4" 
                                      placeholder="详细描述您的健康状况..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="note-precautions">注意事项/医嘱</label>
                            <textarea id="note-precautions" name="precautions" rows="3" 
                                      placeholder="医生建议、注意事项等..."></textarea>
                        </div>
                        <div class="form-actions">
                            <button type="button" onclick="NotesManager.closeNoteForm()">取消</button>
                            <button type="submit">保存笔记</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // 处理添加笔记
    async handleAddNote(event, userId) {
        event.preventDefault();
        
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        
        try {
            // 防止重复提交
            submitButton.disabled = true;
            submitButton.textContent = '保存中...';
            
            const formData = new FormData(form);
            const noteData = {
                user_id: parseInt(userId),
                title: formData.get('title').trim(),
                description: formData.get('description').trim(),
                precautions: formData.get('precautions').trim()
            };
            
            console.log('🔄 创建新笔记:', noteData);
            const response = await ApiClient.notes.create(noteData);
            
            if (response.success) {
                console.log('✅ 笔记创建成功:', response.data);
                
                // 更新本地数据
                if (!this.notes[userId]) {
                    this.notes[userId] = [];
                }
                this.notes[userId].unshift(response.data);
                
                // 重新渲染
                this.renderNotesPanel(userId);
                
                // 关闭表单
                this.closeNoteForm();
                
                this.showMessage('笔记添加成功！', 'success');
            } else {
                throw new Error(response.message || '创建笔记失败');
            }
            
        } catch (error) {
            console.error('❌ 添加笔记失败:', error);
            this.showMessage('添加笔记失败: ' + error.message, 'error');
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = '保存笔记';
        }
    },

    // 显示编辑笔记表单
    async showEditNoteForm(noteId) {
        try {
            // 获取笔记详情
            const response = await ApiClient.notes.getById(noteId);
            if (!response.success) {
                throw new Error(response.message);
            }
            
            const note = response.data;
            const formHtml = `
                <div class="modal-overlay" id="editNoteModal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>编辑健康笔记</h3>
                            <button class="modal-close" onclick="NotesManager.closeNoteForm()">×</button>
                        </div>
                        <form class="note-form" onsubmit="NotesManager.handleEditNote(event, ${noteId})">
                            <div class="form-group">
                                <label for="edit-note-title">健康状况标题 *</label>
                                <input type="text" id="edit-note-title" name="title" required maxlength="100" 
                                       value="${Utils.escapeHtml(note.title)}" 
                                       placeholder="如：关节炎、血压高、轻度抑郁等">
                            </div>
                            <div class="form-group">
                                <label for="edit-note-description">详细描述</label>
                                <textarea id="edit-note-description" name="description" rows="4" 
                                          placeholder="详细描述您的健康状况...">${Utils.escapeHtml(note.description || '')}</textarea>
                            </div>
                            <div class="form-group">
                                <label for="edit-note-precautions">注意事项/医嘱</label>
                                <textarea id="edit-note-precautions" name="precautions" rows="3" 
                                          placeholder="医生建议、注意事项等...">${Utils.escapeHtml(note.precautions || '')}</textarea>
                            </div>
                            <div class="form-group">
                                <label for="edit-note-ai-suggestions">AI建议 <span class="form-note">(可编辑和修改)</span></label>
                                <textarea id="edit-note-ai-suggestions" name="ai_suggestions" rows="8" 
                                          placeholder="AI生成的建议内容...">${Utils.escapeHtml(note.ai_suggestions || '')}</textarea>
                            </div>
                            <div class="form-actions">
                                <button type="button" onclick="NotesManager.closeNoteForm()">取消</button>
                                <button type="submit">保存修改</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', formHtml);
        } catch (error) {
            console.error('显示编辑表单失败:', error);
            this.showMessage('加载笔记数据失败: ' + error.message, 'error');
        }
    },

    // 处理编辑笔记
    async handleEditNote(event, noteId) {
        event.preventDefault();
        
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        
        try {
            // 防止重复提交
            submitButton.disabled = true;
            submitButton.textContent = '保存中...';
            
            const formData = new FormData(form);
            const noteData = {
                title: formData.get('title').trim(),
                description: formData.get('description').trim(),
                precautions: formData.get('precautions').trim(),
                ai_suggestions: formData.get('ai_suggestions').trim()
            };
            
            console.log('🔄 更新笔记:', noteId, noteData);
            const response = await ApiClient.notes.update(noteId, noteData);
            
            if (response.success) {
                console.log('✅ 笔记更新成功:', response.data);
                
                // 更新本地数据
                Object.keys(this.notes).forEach(userId => {
                    const noteIndex = this.notes[userId].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[userId][noteIndex] = { ...this.notes[userId][noteIndex], ...response.data };
                    }
                });
                
                // 重新渲染当前用户的面板
                this.renderNotesPanel(this.currentUser);
                
                // 关闭表单
                this.closeNoteForm();
                
                // 如果详情模态框打开，也关闭它
                this.closeNoteDetails();
                
                this.showMessage('笔记更新成功！', 'success');
            } else {
                throw new Error(response.message || '更新笔记失败');
            }
            
        } catch (error) {
            console.error('❌ 更新笔记失败:', error);
            this.showMessage('更新笔记失败: ' + error.message, 'error');
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = '保存修改';
        }
    },

    // 关闭笔记表单
    closeNoteForm() {
        const modal = document.getElementById('addNoteModal') || document.getElementById('editNoteModal');
        if (modal) {
            modal.remove();
        }
    },

    // 显示笔记详情
    async showNoteDetails(noteId) {
        try {
            const response = await ApiClient.notes.getById(noteId);
            if (!response.success) {
                throw new Error(response.message);
            }
            
            const note = response.data;
            const detailsHtml = `
                <div class="modal-overlay" id="noteDetailsModal">
                    <div class="modal-content large">
                        <div class="modal-header">
                            <h3>${Utils.escapeHtml(note.title)}</h3>
                            <button class="modal-close" onclick="NotesManager.closeNoteDetails()">×</button>
                        </div>
                        <div class="note-details">
                            ${note.description ? `
                                <div class="detail-section">
                                    <h4>详细描述</h4>
                                    <p>${Utils.escapeHtml(note.description)}</p>
                                </div>
                            ` : ''}
                            ${note.precautions ? `
                                <div class="detail-section">
                                    <h4>注意事项/医嘱</h4>
                                    <p>${Utils.escapeHtml(note.precautions)}</p>
                                </div>
                            ` : ''}
                            <div class="detail-section">
                                <h4>AI建议</h4>
                                ${note.ai_suggestions ? `
                                    <div class="ai-suggestions-content">${this.formatAISuggestions(note.ai_suggestions)}</div>
                                ` : `
                                    <p class="no-suggestions">暂无AI建议</p>
                                    <button class="generate-ai-btn" onclick="NotesManager.generateAISuggestions(${noteId})">
                                        获取AI建议
                                    </button>
                                `}
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="NotesManager.showEditNoteForm(${noteId})">编辑</button>
                            <button onclick="NotesManager.regenerateAISuggestions(${noteId})" class="regenerate-ai-btn">再次生成AI建议</button>
                            <button onclick="NotesManager.closeNoteDetails()">关闭</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', detailsHtml);
        } catch (error) {
            console.error('显示笔记详情失败:', error);
            this.showMessage('加载笔记详情失败: ' + error.message, 'error');
        }
    },

    // 关闭笔记详情
    closeNoteDetails() {
        const modal = document.getElementById('noteDetailsModal');
        if (modal) {
            modal.remove();
        }
    },

    // 设置AI生成加载状态
    setAIGenerationLoadingState(isLoading) {
        const modal = document.querySelector('.modal-overlay');
        if (!modal) return;

        // 获取所有需要禁用的按钮
        const editButton = modal.querySelector('button[onclick*="showEditNoteForm"]');
        const regenerateButton = modal.querySelector('.regenerate-ai-btn');
        const closeButton = modal.querySelector('button[onclick*="closeNoteDetails"]');
        const generateButton = modal.querySelector('.generate-ai-btn');

        const buttons = [editButton, regenerateButton, closeButton, generateButton].filter(btn => btn);

        if (isLoading) {
            // 启用加载状态
            buttons.forEach(button => {
                if (button) {
                    button.disabled = true;
                    button.style.opacity = '0.6';
                    button.style.cursor = 'not-allowed';
                }
            });

            // 添加加载遮罩
            if (!modal.querySelector('.ai-loading-overlay')) {
                const loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'ai-loading-overlay';
                loadingOverlay.innerHTML = `
                    <div class="ai-loading-spinner">
                        <div class="spinner"></div>
                        <p>AI正在生成健康建议...</p>
                        <small>请勿关闭窗口</small>
                    </div>
                `;
                modal.appendChild(loadingOverlay);
            }
        } else {
            // 禁用加载状态
            buttons.forEach(button => {
                if (button) {
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                }
            });

            // 移除加载遮罩
            const loadingOverlay = modal.querySelector('.ai-loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.remove();
            }
        }
    },

    // 再次生成AI建议
    async regenerateAISuggestions(noteId) {
        try {
            // 设置加载状态
            this.setAIGenerationLoadingState(true);
            
            const regenerateButton = document.querySelector('.regenerate-ai-btn');
            if (regenerateButton) {
                regenerateButton.textContent = '生成AI建议中...';
            }
            
            console.log('🔄 再次生成AI建议，笔记ID:', noteId);
            
            // 调用后端API生成AI建议，传递真实天气数据给Gemini
            console.log('🚀 再次调用API，传递真实天气数据给Gemini');
            const response = await ApiClient.notes.generateAISuggestions(noteId);
            
            if (response.success) {
                console.log('✅ AI建议再次生成成功:', response.data);
                
                // 更新界面显示AI建议
                const aiSuggestionsSection = document.querySelector('.detail-section:last-child .ai-suggestions-content');
                if (aiSuggestionsSection) {
                    // 直接更新AI建议内容
                    aiSuggestionsSection.innerHTML = this.formatAISuggestions(response.data.ai_suggestions);
                }
                
                // 更新本地数据
                Object.keys(this.notes).forEach(userId => {
                    const noteIndex = this.notes[userId].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[userId][noteIndex].ai_suggestions = response.data.ai_suggestions;
                    }
                });
                
                this.showMessage('AI建议再次生成成功！', 'success');
            } else {
                throw new Error(response.message || '再次生成AI建议失败');
            }
            
        } catch (error) {
            console.error('❌ 再次生成AI建议失败:', error);
            this.showMessage('再次生成AI建议失败: ' + error.message, 'error');
        } finally {
            // 恢复所有按钮状态
            this.setAIGenerationLoadingState(false);
            
            const regenerateButton = document.querySelector('.regenerate-ai-btn');
            if (regenerateButton) {
                regenerateButton.textContent = '再次生成AI建议';
            }
        }
    },

    // 生成AI建议
    async generateAISuggestions(noteId) {
        try {
            // 设置加载状态
            this.setAIGenerationLoadingState(true);
            
            const button = document.querySelector('.generate-ai-btn');
            if (button) {
                button.textContent = '生成中...';
            }
            
            console.log('🤖 开始生成AI建议，笔记ID:', noteId);
            
            // 调用后端API生成AI建议，传递真实天气数据给Gemini
            console.log('🚀 调用API，传递真实天气数据给Gemini');
            const response = await ApiClient.notes.generateAISuggestions(noteId);
            
            if (response.success) {
                console.log('✅ AI建议生成成功:', response.data);
                
                // 更新界面显示AI建议
                const aiSuggestionsSection = document.querySelector('.detail-section:last-child');
                if (aiSuggestionsSection) {
                    // 查找AI建议容器
                    const noSuggestionsElement = aiSuggestionsSection.querySelector('.no-suggestions');
                    const generateButton = aiSuggestionsSection.querySelector('.generate-ai-btn');
                    
                    if (noSuggestionsElement && generateButton) {
                        // 替换"暂无AI建议"和按钮为实际建议内容
                        const aiContentHtml = `<div class="ai-suggestions-content">${this.formatAISuggestions(response.data.ai_suggestions)}</div>`;
                        noSuggestionsElement.outerHTML = aiContentHtml;
                        generateButton.remove();
                    }
                }
                
                // 更新本地数据
                Object.keys(this.notes).forEach(userId => {
                    const noteIndex = this.notes[userId].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[userId][noteIndex].ai_suggestions = response.data.ai_suggestions;
                    }
                });
                
                this.showMessage('AI建议生成成功！', 'success');
            } else {
                throw new Error(response.message || '生成AI建议失败');
            }
            
        } catch (error) {
            console.error('❌ 生成AI建议失败:', error);
            this.showMessage('生成AI建议失败: ' + error.message, 'error');
        } finally {
            // 恢复所有按钮状态
            this.setAIGenerationLoadingState(false);
            
            const button = document.querySelector('.generate-ai-btn');
            if (button) {
                button.textContent = '获取AI建议';
            }
        }
    },

    // 删除笔记
    async deleteNote(noteId) {
        if (!confirm('确定要删除这条健康笔记吗？此操作无法撤销。')) {
            return;
        }
        
        try {
            const response = await ApiClient.notes.delete(noteId);
            
            if (response.success) {
                // 从本地数据中移除
                Object.keys(this.notes).forEach(userId => {
                    this.notes[userId] = this.notes[userId].filter(note => note.id !== noteId);
                });
                
                // 重新渲染当前用户的面板
                this.renderNotesPanel(this.currentUser);
                
                this.showMessage('笔记删除成功', 'success');
            } else {
                throw new Error(response.message);
            }
        } catch (error) {
            console.error('删除笔记失败:', error);
            this.showMessage('删除笔记失败: ' + error.message, 'error');
        }
    },



    // 显示离线错误
    showOfflineError() {
        const contentArea = Utils.$('#contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="offline-error">
                    <div class="error-icon">🔌</div>
                    <h2>服务器连接失败</h2>
                    <p>无法连接到后端服务器，请检查：</p>
                    <p>1. 后端服务是否正常运行</p>
                    <p>2. 网络连接是否正常</p>
                    <button class="retry-btn" onclick="location.reload()">重试</button>
                </div>
            `;
        }
    },

    // 显示消息
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        
        document.body.appendChild(messageEl);
        
        // 3秒后自动移除
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 3000);
    },

    // 格式化AI建议内容
    formatAISuggestions(suggestions) {
        if (!suggestions) return '';
        
        // 将markdown格式转换为HTML
        let formatted = suggestions
            // 处理加粗文本 **text** -> <strong>text</strong>
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            // 处理换行
            .replace(/\n/g, '<br>')
            // 处理空行
            .replace(/<br><br>/g, '<br><br>');
        
        // 特别处理今日建议部分
        if (formatted.includes('🌅 今日建议')) {
            // 找到今日建议的开始和结束位置
            const todayStart = formatted.indexOf('<strong>🌅 今日建议</strong>');
            const nextSectionStart = formatted.indexOf('<strong>👩‍⚕️', todayStart);
            
            if (todayStart !== -1) {
                const todayEnd = nextSectionStart !== -1 ? nextSectionStart : formatted.length;
                const todayContent = formatted.substring(todayStart, todayEnd);
                const restContent = formatted.substring(todayEnd);
                const beforeContent = formatted.substring(0, todayStart);
                
                // 为今日建议添加特殊样式
                const highlightedToday = `<div class="today-suggestion-highlight">${todayContent}</div>`;
                formatted = beforeContent + highlightedToday + restContent;
            }
        }
        
        return `<div style="white-space: normal; line-height: 1.6;">${formatted}</div>`;
    },

    // 分享笔记功能
    async shareNote(noteId) {
        try {
            console.log('🔗 开始分享笔记，ID:', noteId);
            
            // 获取笔记详情
            const response = await ApiClient.notes.getById(noteId);
            if (!response.success) {
                throw new Error(response.message);
            }
            
            const note = response.data;
            
            // 创建分享内容
            await this.generateShareImage(note);
            
        } catch (error) {
            console.error('❌ 分享笔记失败:', error);
            this.showMessage('分享笔记失败: ' + error.message, 'error');
        }
    },

    // 生成分享图片
    async generateShareImage(note) {
        try {
            // 创建分享内容容器
            const shareContainer = document.createElement('div');
            shareContainer.className = 'share-content-container';
            shareContainer.style.cssText = `
                position: fixed;
                top: -9999px;
                left: -9999px;
                width: 600px;
                background: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
                z-index: -1;
            `;
            
            // 格式化分享内容
            const shareContent = this.formatShareContent(note);
            shareContainer.innerHTML = shareContent;
            
            document.body.appendChild(shareContainer);
            
            // 检查是否有html2canvas库
            if (typeof html2canvas === 'undefined') {
                // 动态加载html2canvas库
                await this.loadHtml2Canvas();
            }
            
            // 生成图片
            console.log('📸 开始生成分享图片...');
            const canvas = await html2canvas(shareContainer, {
                backgroundColor: '#ffffff',
                scale: 2,
                useCORS: true,
                allowTaint: true,
                width: 600,
                height: shareContainer.offsetHeight
            });
            
            // 清理临时容器
            document.body.removeChild(shareContainer);
            
            // 下载图片
            this.downloadImage(canvas, `健康档案-${note.title}-${new Date().toISOString().split('T')[0]}.png`);
            
            this.showMessage('健康档案图片已生成，正在下载...', 'success');
            
        } catch (error) {
            console.error('❌ 生成分享图片失败:', error);
            this.showMessage('生成分享图片失败: ' + error.message, 'error');
        }
    },

    // 格式化分享内容
    formatShareContent(note) {
        const currentDate = new Date().toLocaleDateString('zh-CN');
        
        return `
            <div style="padding: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <div style="background: white; border-radius: 16px; padding: 32px; color: #333; box-shadow: 0 20px 40px rgba(0,0,0,0.1);">
                    <div style="text-align: center; margin-bottom: 32px;">
                        <h1 style="font-size: 24px; font-weight: 700; color: #1d9bf0; margin: 0 0 8px 0;">雯婷健康档案</h1>
                        <p style="color: #657786; margin: 0; font-size: 14px;">生成日期: ${currentDate}</p>
                    </div>
                    
                    <div style="margin-bottom: 24px;">
                        <h2 style="font-size: 20px; font-weight: 600; color: #14171a; margin: 0 0 12px 0; padding-bottom: 8px; border-bottom: 2px solid #1d9bf0;">${Utils.escapeHtml(note.title)}</h2>
                    </div>
                    
                    ${note.description ? `
                        <div style="margin-bottom: 24px;">
                            <h3 style="font-size: 16px; font-weight: 600; color: #495057; margin: 0 0 8px 0;">详细描述</h3>
                            <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; border-left: 4px solid #28a745;">
                                <p style="margin: 0; line-height: 1.6; color: #495057;">${Utils.escapeHtml(note.description)}</p>
                            </div>
                        </div>
                    ` : ''}
                    
                    ${note.precautions ? `
                        <div style="margin-bottom: 24px;">
                            <h3 style="font-size: 16px; font-weight: 600; color: #495057; margin: 0 0 8px 0;">注意事项/医嘱</h3>
                            <div style="background: #fff3cd; padding: 16px; border-radius: 8px; border-left: 4px solid #ffc107;">
                                <p style="margin: 0; line-height: 1.6; color: #856404;">${Utils.escapeHtml(note.precautions)}</p>
                            </div>
                        </div>
                    ` : ''}
                    
                    ${note.ai_suggestions ? `
                        <div style="margin-bottom: 24px;">
                            <h3 style="font-size: 16px; font-weight: 600; color: #495057; margin: 0 0 8px 0;">AI健康建议</h3>
                            <div style="background: #e7f3ff; padding: 16px; border-radius: 8px; border-left: 4px solid #1d9bf0;">
                                <div style="margin: 0; line-height: 1.6; color: #0c5460;">${this.formatAISuggestionsForShare(note.ai_suggestions)}</div>
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="text-align: center; margin-top: 32px; padding-top: 24px; border-top: 1px solid #e1e8ed;">
                        <p style="margin: 0; font-size: 12px; color: #657786;">此健康档案由雯婷应用生成 | 仅供参考，如有疑问请咨询专业医师</p>
                    </div>
                </div>
            </div>
        `;
    },

    // 格式化AI建议用于分享
    formatAISuggestionsForShare(suggestions) {
        if (!suggestions) return '';
        
        return suggestions
            .replace(/\*\*(.*?)\*\*/g, '<strong style="color: #1d9bf0;">$1</strong>')
            .replace(/\n/g, '<br>')
            .replace(/<br><br>/g, '<br><br>');
    },

    // 动态加载html2canvas库
    async loadHtml2Canvas() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
            script.onload = () => {
                console.log('✅ html2canvas库加载成功');
                resolve();
            };
            script.onerror = () => {
                console.error('❌ html2canvas库加载失败');
                reject(new Error('无法加载图片生成库'));
            };
            document.head.appendChild(script);
        });
    },

    // 下载图片
    downloadImage(canvas, filename) {
        try {
            // 创建下载链接
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            
            // 触发下载
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('✅ 图片下载成功:', filename);
        } catch (error) {
            console.error('❌ 图片下载失败:', error);
            throw error;
        }
    },

    // 绑定事件
    bindEvents() {
        // 用户标签点击事件在TodoManager中已处理，这里不需要重复绑定
    }
};

// 导出到全局
window.NotesManager = NotesManager;


// 用户管理模块
const UserManager = {
    users: [],
    isOnline: false,

    async init() {
        // 确保 ApiClient 已加载
        if (typeof ApiClient === 'undefined') {
            console.error('❌ ApiClient 未定义，请检查脚本加载顺序');
            return;
        }
        
        // 检查后端连接 - 必须联网才能使用
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.error('❌ 无法连接到服务器，应用无法启动');
            return;
        }
        
        await this.loadUsersFromAPI();
        this.bindEvents();
        this.renderUserTabs();
    },

    // 从API加载用户数据
    async loadUsersFromAPI() {
        try {
            const response = await ApiClient.users.getAll();
            if (response.success) {
                this.users = response.data;
                console.log('✅ 从服务器加载用户数据成功，用户数量:', this.users.length);
                
                // 数据库为空，等待用户手动添加用户
                if (this.users.length === 0) {
                    console.log('📝 数据库中没有用户，等待用户手动添加');
                }
            }
        } catch (error) {
            console.error('从服务器加载用户数据失败:', error);
            throw error; // 不降级到本地数据，直接抛出错误
        }
    },

    // 创建默认用户（已废弃 - 用户需要手动添加）
    async createDefaultUsers() {
        console.log('⚠️ createDefaultUsers方法已废弃，请手动添加用户');
        // 不再自动创建任何默认用户
        return;
    },



    // 同步用户数据到服务器
    async syncUserToServer(user) {
        if (!this.isOnline) return false;
        
        try {
            let response;
            if (user.id && user.id > 0) {
                // 更新现有用户
                response = await ApiClient.users.update(user.id, user);
            } else {
                // 创建新用户
                response = await ApiClient.users.create(user);
            }
            
            if (response.success) {
                console.log('✅ 用户数据同步到服务器成功');
                return response.data;
            }
        } catch (error) {
            console.error('同步用户数据到服务器失败:', error);
        }
        return false;
    },

    // 添加新用户
    async addUser() {
        // 添加点击反馈动画
        const btn = event.target;
        btn.style.transform = 'scale(0.9)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        // 显示添加用户表单
        this.showAddUserForm();
    },

    // 显示添加用户表单
    showAddUserForm() {
        const formHtml = `
            <div class="modal-overlay" id="addUserModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>添加新用户</h3>
                        <button class="modal-close" data-action="close-add-user-form">×</button>
                    </div>
                    <form class="user-form" id="addUserForm">
                        <div class="form-group">
                            <label for="username">用户名 *</label>
                            <input type="text" id="username" name="username" required maxlength="50">
                        </div>
                        <div class="form-group">
                            <label for="display_name">显示名称 *</label>
                            <input type="text" id="display_name" name="display_name" required maxlength="100">
                        </div>
                        <div class="form-group">
                            <label for="email">邮箱</label>
                            <input type="email" id="email" name="email" maxlength="100">
                        </div>
                        <div class="form-group">
                            <label for="phone">手机号</label>
                            <input type="tel" id="phone" name="phone" pattern="1[3-9]\\d{9}" maxlength="11">
                        </div>
                        <div class="form-group">
                            <label for="gender">性别</label>
                            <select id="gender" name="gender">
                                <option value="">请选择</option>
                                <option value="male">男</option>
                                <option value="female">女</option>
                                <option value="other">其他</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="birthday">生日</label>
                            <input type="date" id="birthday" name="birthday">
                        </div>
                        <div class="form-group">
                            <label for="avatar_color">头像颜色</label>
                            <input type="color" id="avatar_color" name="avatar_color" value="#1d9bf0">
                        </div>
                        <div class="form-actions">
                            <button type="button" data-action="close-add-user-form">取消</button>
                            <button type="submit">添加用户</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
        
        // 绑定事件监听器
        const modal = document.getElementById('addUserModal');
        if (modal) {
            // 关闭按钮事件
            modal.addEventListener('click', (e) => {
                if (e.target.dataset.action === 'close-add-user-form' || e.target.classList.contains('modal-overlay')) {
                    this.closeAddUserForm();
                }
            });
            
            // 表单提交事件
            const form = modal.querySelector('#addUserForm');
            if (form) {
                form.addEventListener('submit', (e) => this.handleAddUser(e));
            }
        }
    },

    // 关闭添加用户表单
    closeAddUserForm() {
        const modal = document.getElementById('addUserModal');
        if (modal) {
            modal.remove();
        }
    },

    // 处理添加用户表单提交
    async handleAddUser(event) {
        event.preventDefault();
        
        // 防止重复提交
        const submitButton = event.target.querySelector('button[type="submit"]');
        if (submitButton.disabled) {
            console.log('⚠️ 表单正在提交中，忽略重复提交');
            return;
        }
        
        // 禁用提交按钮
        submitButton.disabled = true;
        submitButton.textContent = '提交中...';
        
        const formData = new FormData(event.target);
        const userData = {
            username: formData.get('username'),
            display_name: formData.get('display_name'),
            email: formData.get('email') || null,
            phone: formData.get('phone') || null,
            gender: formData.get('gender') || null,
            birthday: formData.get('birthday') || null,
            avatar_color: formData.get('avatar_color') || '#1d9bf0'
        };

        console.log('📤 准备创建用户:', userData);
        console.log('📋 用户数据详情:');
        Object.keys(userData).forEach(key => {
            console.log(`  ${key}: "${userData[key]}" (类型: ${typeof userData[key]}, 长度: ${userData[key]?.length || 'N/A'})`);
        });

        try {
            // 在服务器创建用户
            console.log('🔄 正在调用API创建用户...');
            const response = await ApiClient.users.create(userData);
            console.log('📥 API响应:', response);
            
            if (response && response.success) {
                const newUser = response.data;
                console.log('✅ 在服务器创建用户成功:', newUser);
                
                // 添加到本地用户列表
                this.users.push(newUser);
                console.log('📝 已添加到本地用户列表，当前用户数:', this.users.length);
                
                // 切换到新创建的用户
                if (window.TodoManager) {
                    window.TodoManager.currentUser = newUser.id;
                    console.log('🎯 已切换TodoManager到新用户:', newUser.id, newUser.username);
                }
                
                // 同步到全局状态管理器
                if (window.GlobalUserState) {
                    GlobalUserState.setCurrentUser(newUser.id);
                    console.log('🎯 已同步GlobalUserState到新用户:', newUser.id, newUser.username);
                }
                
                // 重新渲染用户标签（会显示新用户为活跃状态）
                this.renderUserTabs();
                console.log('🎨 已重新渲染用户标签');
                
                // 关闭表单
                this.closeAddUserForm();
                
                // 显示成功消息
                this.showMessage('用户添加成功！', 'success');
                
                // 加载并显示新用户的TODO列表
                if (window.TodoManager && typeof window.TodoManager.loadTodosFromAPI === 'function') {
                    try {
                        // 为新用户初始化空的TODO数组
                        window.TodoManager.todos[newUser.id] = [];
                        
                        // 重新加载所有用户的TODO数据（包括新用户）
                        await window.TodoManager.loadTodosFromAPI();
                        
                        // 渲染新用户的TODO面板
                        window.TodoManager.renderTodoPanel(newUser.id);
                        console.log('✅ 已加载并显示新用户的TODO列表');
                    } catch (todoError) {
                        console.warn('重新加载TODO数据失败:', todoError);
                        // 即使加载失败，也要显示新用户的空TODO面板
                        window.TodoManager.renderTodoPanel(newUser.id);
                    }
                }
                
            } else {
                console.error('❌ API返回失败响应:', response);
                throw new Error(response?.message || '创建用户失败');
            }
            
        } catch (error) {
            console.error('❌ 添加用户失败:', error);
            console.error('错误详情:', {
                message: error.message,
                stack: error.stack,
                response: error.response
            });
            
            // 检查是否是网络错误
            if (error.message.includes('fetch') || error.message.includes('NetworkError')) {
                this.showMessage('网络连接失败，请检查服务器状态', 'error');
            } else {
                this.showMessage('添加用户失败: ' + error.message, 'error');
            }
        } finally {
            // 恢复提交按钮状态
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = '添加用户';
            }
        }
    },

    // 删除用户
    async removeUser(userId) {
        if (!confirm('确定要删除这个用户吗？这将删除该用户的所有TODO数据。')) {
            return;
        }

        try {
            // 从服务器删除
            const response = await ApiClient.users.delete(userId);
            if (!response.success) {
                throw new Error(response.message || '删除用户失败');
            }
            console.log('✅ 从服务器删除用户成功');

            // 从本地删除
            const index = this.users.findIndex(user => user.id === userId);
            if (index > -1) {
                this.users.splice(index, 1);
                
                // 清理对应的TODO数据
                if (TodoManager.todos && TodoManager.todos[userId]) {
                    delete TodoManager.todos[userId];
                }
                
                // 如果删除的是当前用户，切换到第一个用户
                if (TodoManager.currentUser === userId && this.users.length > 0) {
                    TodoManager.switchUser(this.users[0].id);
                }
                
                this.renderUserTabs();
                this.showMessage('用户删除成功！', 'success');
            }
        } catch (error) {
            console.error('删除用户失败:', error);
            this.showMessage('删除用户失败: ' + error.message, 'error');
        }
    },

    // 渲染用户标签
    renderUserTabs() {
        const sidebar = Utils.$('.left-sidebar');
        if (!sidebar) return;

        // 按ID排序，确保用户按创建顺序显示（ID越小越靠前）
        const sortedUsers = [...this.users].sort((a, b) => a.id - b.id);
        console.log('📋 用户排序:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));

        // 获取当前选中的用户ID
        const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : (TodoManager.currentUser || null);
        console.log('🎯 renderUserTabs - 当前用户ID:', currentUserId);
        
        const tabsHtml = sortedUsers.map(user => {
            const isActive = parseInt(user.id) === parseInt(currentUserId);
            const userColor = user.avatar_color || '#1d9bf0';
            console.log(`🏷️ 用户${user.id}(${user.username}) - 是否选中:`, isActive);
            
            return `
                <div class="sidebar-tab ${isActive ? 'active' : ''}" 
                     data-tab="${user.id}"
                     style="--user-color: ${userColor};">
                    ${user.display_name || user.username}
                </div>
            `;
        }).join('');

        const addButtonHtml = `
            <div class="add-user-btn" data-action="add-user" title="添加新用户">
                +
            </div>
        `;

        sidebar.innerHTML = tabsHtml + addButtonHtml;
        
        // 重新绑定全局用户选择器事件
        if (window.GlobalUserState) {
            GlobalUserState.bindUserSelectorEvents();
        }
        
        // 触发用户标签渲染完成事件，通知其他页面
        const userTabsRenderedEvent = new CustomEvent('userTabsRendered', {
            detail: {
                users: sortedUsers,
                currentUserId: currentUserId
            }
        });
        document.dispatchEvent(userTabsRenderedEvent);
        console.log('📢 触发userTabsRendered事件，用户数:', sortedUsers.length, '当前用户:', currentUserId);
        
        // 如果有当前用户，也触发userSelected事件
        if (currentUserId) {
            const currentUser = sortedUsers.find(user => user.id === currentUserId);
            if (currentUser) {
                console.log('📢 同时触发userSelected事件，用户:', currentUser.username);
                const userSelectedEvent = new CustomEvent('userSelected', {
                    detail: currentUser
                });
                document.dispatchEvent(userSelectedEvent);
            }
        }
    },

    // 获取用户信息
    getUser(userId) {
        return this.users.find(user => user.id === userId);
    },

    // 更新用户信息
    async updateUser(userId, updates) {
        try {
            // 在服务器更新用户
            const response = await ApiClient.users.update(userId, updates);
            if (response.success) {
                const updatedUser = response.data;
                console.log('✅ 在服务器更新用户成功');
                
                // 更新本地用户数据
                const user = this.getUser(userId);
                if (user) {
                    Object.assign(user, updatedUser);
                    this.renderUserTabs();
                    return true;
                }
            } else {
                throw new Error(response.message || '更新用户失败');
            }
        } catch (error) {
            console.error('更新用户失败:', error);
            this.showMessage('更新用户失败: ' + error.message, 'error');
        }
        return false;
    },

    // 显示消息
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        `;
        
        switch (type) {
            case 'success':
                messageEl.style.backgroundColor = '#4CAF50';
                break;
            case 'error':
                messageEl.style.backgroundColor = '#f44336';
                break;
            case 'warning':
                messageEl.style.backgroundColor = '#ff9800';
                break;
            default:
                messageEl.style.backgroundColor = '#2196F3';
        }
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 3000);
    },

    // 绑定事件
    bindEvents() {
        // 事件委托：处理动态生成的添加用户按钮
        document.addEventListener('click', (e) => {
            if (e.target.dataset.action === 'add-user' || e.target.closest('[data-action="add-user"]')) {
                e.preventDefault();
                this.addUser();
            }
        });
    }
};

// 导出到全局
window.UserManager = UserManager;

// 全局函数（保持向后兼容）
function addNewUser() {
    UserManager.addUser();
}


// 天气管理模块
const WeatherManager = {
    weatherData: null,
    userLocation: null,
    autoUpdateTimer: null,
    locationReady: false,

    // Open-Meteo天气代码映射
    weatherCodeMap: {
        0: { condition: '晴朗', icon: '☀️' },
        1: { condition: '基本晴朗', icon: '🌤️' },
        2: { condition: '部分多云', icon: '⛅' },
        3: { condition: '阴天', icon: '☁️' },
        45: { condition: '雾', icon: '🌫️' },
        48: { condition: '冻雾', icon: '🌫️' },
        51: { condition: '细雨', icon: '🌦️' },
        53: { condition: '小雨', icon: '🌦️' },
        55: { condition: '中雨', icon: '🌧️' },
        61: { condition: '小雨', icon: '🌦️' },
        63: { condition: '中雨', icon: '🌧️' },
        65: { condition: '大雨', icon: '🌧️' },
        71: { condition: '小雪', icon: '🌨️' },
        73: { condition: '中雪', icon: '❄️' },
        75: { condition: '大雪', icon: '❄️' },
        80: { condition: '阵雨', icon: '🌦️' },
        81: { condition: '阵雨', icon: '🌦️' },
        82: { condition: '暴雨', icon: '⛈️' },
        95: { condition: '雷雨', icon: '⛈️' },
        96: { condition: '雷雨冰雹', icon: '⛈️' },
        99: { condition: '强雷雨冰雹', icon: '⛈️' }
    },

    async init() {
        console.log('WeatherManager 初始化开始 - 只使用用户实际位置');

        this.loadWeatherData();

        // 必须获取用户实际位置，不使用任何默认位置
        await this.getCurrentLocation();

        if (this.userLocation && this.locationReady) {
            console.log('✅ 用户位置获取成功，开始获取天气数据');
            this.fetchRealWeatherData();
            this.updateWeatherDisplay();
        } else {
            console.log('❌ 无法获取用户位置，天气功能不可用');
            this.showLocationError();
        }

        console.log('WeatherManager 初始化完成，用户位置:', this.userLocation);
    },

    // 清除位置缓存，强制重新获取
    clearLocationCache() {
        localStorage.removeItem('wenting_user_location');
        this.userLocation = null;
        this.locationReady = false;
        console.log('🗑️ 位置缓存已清除');
    },

    // 获取用户地理位置
    async getCurrentLocation() {
        try {
            if (!navigator.geolocation) {
                console.log('❌ 浏览器不支持地理位置，天气功能不可用');
                this.locationReady = false;
                return;
            }

            // 检查是否为HTTPS或localhost
            const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost';
            if (!isSecureContext) {
                console.log('⚠️ 非安全上下文，地理位置API不可用');
                this.locationReady = false;
                return;
            }

            console.log('🌍 请求用户地理位置权限...');
            
            // 显示位置权限请求提示
            this.showLocationPermissionPrompt();

            const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        console.log('✅ 用户授权地理位置成功');
                        this.hideLocationPermissionPrompt();
                        resolve(pos);
                    },
                    (error) => {
                        console.log('❌ 地理位置获取失败:', error.message);
                        this.hideLocationPermissionPrompt();
                        
                        if (error.code === error.PERMISSION_DENIED) {
                            console.log('用户拒绝了地理位置权限');
                        } else if (error.code === error.POSITION_UNAVAILABLE) {
                            console.log('位置信息不可用');
                        } else if (error.code === error.TIMEOUT) {
                            console.log('获取位置超时');
                        }
                        
                        // 不使用默认位置，直接失败
                        reject(error);
                    },
                    {
                        enableHighAccuracy: false, // 降低精度要求，提高成功率
                        timeout: 15000, // 增加超时时间
                        maximumAge: 600000 // 10分钟缓存
                    }
                );
            });

            // 使用用户的实际位置，不做任何地区限制
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            this.userLocation = {
                latitude: lat,
                longitude: lon,
                city: '获取中...'
            };
            this.locationReady = true;

            console.log('✅ 获取到用户实际位置:', this.userLocation);

            // 异步获取城市名称
            this.getCityFromCoords(lat, lon).then(cityName => {
                this.userLocation.city = cityName;
                console.log('🏙️ 城市名称更新:', cityName);
                // 更新显示
                this.updateWeatherDisplay();
            });

            // 获取到位置后立即更新天气
            this.fetchRealWeatherData();

        } catch (error) {
            console.log('❌ 获取用户位置失败:', error.message);
            this.userLocation = null;
            this.locationReady = false;
        }
    },

    // 根据坐标获取城市名称
    async getCityFromCoords(lat, lon) {
        try {
            // 使用免费的反向地理编码服务获取城市名
            const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=zh`);
            if (response.ok) {
                const data = await response.json();
                const city = data.city || data.locality || data.principalSubdivision || '未知位置';
                console.log('🏙️ 获取到城市名:', city);
                return city;
            }
        } catch (error) {
            console.log('反向地理编码失败:', error);
        }

        // 如果反向地理编码失败，返回坐标
        return `${lat.toFixed(2)}°, ${lon.toFixed(2)}°`;
    },

    // 获取真实天气数据
    async fetchRealWeatherData() {
        try {
            if (!this.userLocation || !this.locationReady) {
                console.log('❌ 没有用户位置信息，无法获取天气数据');
                this.showLocationError();
                return null;
            }

            const { latitude, longitude } = this.userLocation;

            const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m&timezone=auto`;

            console.log('正在获取天气数据...', url);

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`API请求失败: ${response.status}`);
            }

            const data = await response.json();
            console.log('天气API响应:', data);

            // 转换API数据为应用格式
            const weatherData = this.convertApiData(data, this.userLocation?.city || '当前位置');

            this.updateWeather(weatherData);
            console.log('天气数据更新成功:', weatherData);

            return weatherData;

        } catch (error) {
            console.error('获取天气数据失败:', error);
            // 如果没有用户位置，显示错误信息
            if (!this.userLocation || !this.locationReady) {
                this.showLocationError();
            }
            return null;
        }
    },

    // 转换API数据格式
    convertApiData(apiData, cityName) {
        const current = apiData.current;
        const weatherCode = current.weather_code;
        const weatherInfo = this.weatherCodeMap[weatherCode] || { condition: '未知', icon: '❓' };

        return {
            location: cityName,
            icon: weatherInfo.icon,
            condition: weatherInfo.condition,
            temperature: Math.round(current.temperature_2m) + '°C',
            wind: {
                level: this.convertWindSpeed(current.wind_speed_10m),
                label: '风力'
            },
            humidity: {
                value: Math.round(current.relative_humidity_2m) + '%',
                label: '湿度'
            },
            lastUpdated: new Date().toISOString(),
            isError: false
        };
    },

    // 转换风速为等级
    convertWindSpeed(windSpeedKmh) {
        if (windSpeedKmh < 6) return '1级';
        if (windSpeedKmh < 12) return '2级';
        if (windSpeedKmh < 20) return '3级';
        if (windSpeedKmh < 29) return '4级';
        if (windSpeedKmh < 39) return '5级';
        if (windSpeedKmh < 50) return '6级';
        if (windSpeedKmh < 62) return '7级';
        if (windSpeedKmh < 75) return '8级';
        if (windSpeedKmh < 89) return '9级';
        if (windSpeedKmh < 103) return '10级';
        if (windSpeedKmh < 118) return '11级';
        return '12级';
    },



    // 显示位置权限请求提示
    showLocationPermissionPrompt() {
        const locationElement = Utils.$('.weather-location');
        if (locationElement) {
            locationElement.textContent = '请求位置权限...';
            locationElement.className = 'weather-location requesting';
            locationElement.title = '正在请求地理位置权限，请允许访问';
        }
    },

    // 隐藏位置权限请求提示
    hideLocationPermissionPrompt() {
        // 提示会在后续的updateWeatherDisplay中被更新
    },

    // 显示位置权限被拒绝的消息
    showLocationDeniedMessage() {
        // 显示一个临时提示消息
        this.showTemporaryMessage('位置权限被拒绝，点击位置区域可重新请求', 'warning');
    },

    // 请求位置权限
    async requestLocationPermission() {
        console.log('🌍 用户主动请求位置权限...');
        
        // 显示位置权限说明对话框
        this.showLocationPermissionDialog();
    },

    // 显示位置权限说明对话框
    showLocationPermissionDialog() {
        const modalHtml = `
            <div class="modal-overlay" id="locationPermissionModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>📍 位置权限请求</h3>
                        <button class="modal-close" onclick="WeatherManager.closeLocationPermissionDialog()">×</button>
                    </div>
                    <div class="location-permission-content">
                        <div class="permission-explanation">
                            <p>🌤️ 天气功能需要获取您的地理位置来提供准确的天气信息。</p>
                            <p>📱 点击"获取位置"后，浏览器会询问您是否允许访问位置信息。</p>
                            <p>🔒 您的位置信息仅用于获取天气数据，不会被存储或分享。</p>
                        </div>
                        <div class="permission-actions">
                            <button class="permission-btn allow" onclick="WeatherManager.startLocationRequest()">
                                📍 获取位置
                            </button>
                            <button class="permission-btn cancel" onclick="WeatherManager.closeLocationPermissionDialog()">
                                取消
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    },

    // 关闭位置权限对话框
    closeLocationPermissionDialog() {
        const modal = document.getElementById('locationPermissionModal');
        if (modal) {
            modal.remove();
        }
    },

    // 开始位置请求
    async startLocationRequest() {
        // 关闭对话框
        this.closeLocationPermissionDialog();
        
        // 显示请求中状态
        this.showLocationPermissionPrompt();
        
        try {
            // 重新获取位置
            await this.getCurrentLocation();
            
            if (this.userLocation && this.locationReady) {
                console.log('✅ 位置权限获取成功');
                this.fetchRealWeatherData();
                this.updateWeatherDisplay();
                this.showTemporaryMessage('位置权限获取成功！', 'success');
            }
        } catch (error) {
            console.log('❌ 位置权限请求失败:', error);
            this.showLocationError();
            this.showTemporaryMessage('位置权限被拒绝，请在浏览器设置中允许位置访问', 'error');
        }
    },

    // 显示临时消息
    showTemporaryMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `weather-message weather-message-${type}`;
        messageEl.textContent = message;
        let backgroundColor = '#2196F3'; // 默认蓝色
        if (type === 'warning') backgroundColor = '#ff9800';
        if (type === 'success') backgroundColor = '#4CAF50';
        if (type === 'error') backgroundColor = '#f44336';
        
        messageEl.style.cssText = `
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: ${backgroundColor};
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10001;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        
        document.body.appendChild(messageEl);
        
        // 3秒后自动移除
        setTimeout(() => {
            if (messageEl.parentNode) {
                messageEl.style.opacity = '0';
                messageEl.style.transition = 'opacity 0.3s ease';
                setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 300);
            }
        }, 3000);
    },

    // 显示位置错误信息
    showLocationError() {
        console.log('显示位置权限错误信息');
        const errorData = {
            location: '位置未授权',
            icon: '❌',
            condition: '需要位置权限',
            temperature: '--°C',
            wind: {
                level: '--',
                label: '风力'
            },
            humidity: {
                value: '--%',
                label: '湿度'
            },
            lastUpdated: new Date().toISOString(),
            isError: true
        };

        this.updateWeather(errorData);

        // 直接更新位置显示，并添加点击事件
        const locationElement = Utils.$('.weather-location');
        if (locationElement) {
            locationElement.textContent = '点击授权位置';
            locationElement.className = 'weather-location error clickable';
            locationElement.title = '点击请求地理位置权限';
            
            // 添加点击事件来请求位置权限
            locationElement.style.cursor = 'pointer';
            locationElement.onclick = () => {
                this.requestLocationPermission();
            };
        }
    },

    // 加载天气数据
    loadWeatherData() {
        const savedWeather = localStorage.getItem('wenting_weather');
        if (savedWeather) {
            this.weatherData = JSON.parse(savedWeather);
            // 检查数据是否过期（超过30分钟）
            if (this.weatherData.lastUpdated) {
                const lastUpdate = new Date(this.weatherData.lastUpdated);
                const now = new Date();
                const diffMinutes = (now - lastUpdate) / (1000 * 60);

                if (diffMinutes > 30) {
                    console.log('天气数据已过期，将重新获取');
                    this.fetchRealWeatherData();
                }
            }
        } else {
            this.weatherData = Utils.deepClone(APP_CONFIG.weather);
        }
    },

    // 保存天气数据
    saveWeatherData() {
        localStorage.setItem('wenting_weather', JSON.stringify(this.weatherData));
    },

    // 更新天气显示
    updateWeatherDisplay() {
        console.log('🔄 updateWeatherDisplay 被调用');
        console.log('更新天气显示，数据:', this.weatherData);
        if (!this.weatherData) {
            console.log('没有天气数据');
            if (!this.userLocation || !this.locationReady) {
                this.showLocationError();
            }
            return;
        }

        const elements = {
            icon: Utils.$('.weather-icon'),
            condition: Utils.$('.weather-condition'),
            temp: Utils.$('.weather-temp'),
            windValue: Utils.$('.weather-wind-value'),
            windLabel: Utils.$('.weather-wind-label'),
            humidityValue: Utils.$('.weather-humidity-value'),
            humidityLabel: Utils.$('.weather-humidity-label'),
            location: Utils.$('.weather-location')
        };

        console.log('🔍 调试：location元素:', elements.location);
        console.log('🔍 调试：weatherData.location:', this.weatherData.location);
        console.log('🔍 调试：userLocation:', this.userLocation);
        console.log('🔍 调试：locationReady:', this.locationReady);

        if (elements.icon) {
            elements.icon.textContent = this.weatherData.icon;
        }

        if (elements.condition) {
            elements.condition.textContent = this.weatherData.condition;
            // 如果是备用数据，添加提示
            if (this.weatherData.isFallback) {
                elements.condition.title = '网络连接问题，显示备用数据';
            }
        }

        if (elements.temp) {
            elements.temp.textContent = this.weatherData.temperature;
        }

        if (elements.windValue) {
            elements.windValue.textContent = this.weatherData.wind.level;
        }

        if (elements.windLabel) {
            elements.windLabel.textContent = this.weatherData.wind.label;
        }

        if (elements.humidityValue) {
            elements.humidityValue.textContent = this.weatherData.humidity.value;
        }

        if (elements.humidityLabel) {
            elements.humidityLabel.textContent = this.weatherData.humidity.label;
        }

        // 更新位置显示
        console.log('🔍 开始更新位置显示');
        if (elements.location) {
            console.log('✅ 找到location元素');
            if (this.weatherData.isError) {
                console.log('❌ 显示错误状态');
                elements.location.textContent = '位置未授权';
                elements.location.className = 'weather-location error';
            } else if (this.weatherData.location) {
                console.log('🏙️ 使用天气数据中的位置:', this.weatherData.location);
                // 优先使用天气数据中的位置信息
                elements.location.textContent = this.weatherData.location;
                elements.location.className = 'weather-location';
                
                // 如果有用户位置坐标，添加到title中
                if (this.userLocation && this.userLocation.latitude && this.userLocation.longitude) {
                    elements.location.title = `纬度: ${this.userLocation.latitude.toFixed(4)}, 经度: ${this.userLocation.longitude.toFixed(4)}`;
                } else {
                    elements.location.title = '基于天气数据的位置';
                }
                console.log('✅ 位置已更新为:', elements.location.textContent);
            } else if (this.userLocation && this.locationReady) {
                console.log('📍 使用用户位置数据:', this.userLocation.city);
                // 备用：使用用户位置数据
                elements.location.textContent = this.userLocation.city || '当前位置';
                elements.location.className = 'weather-location';
                elements.location.title = `纬度: ${this.userLocation.latitude.toFixed(4)}, 经度: ${this.userLocation.longitude.toFixed(4)}`;
            } else {
                console.log('⏳ 显示定位中状态');
                elements.location.textContent = '定位中...';
                elements.location.className = 'weather-location loading';
            }
        } else {
            console.log('❌ 未找到location元素');
        }
    },

    // 更新天气数据
    updateWeather(newWeatherData) {
        this.weatherData = { ...this.weatherData, ...newWeatherData };
        this.saveWeatherData();
        this.updateWeatherDisplay();
    },

    // 手动刷新天气
    async refreshWeather() {
        console.log('手动刷新天气数据...');

        // 添加加载状态
        const weatherBar = Utils.$('.weather-bar');
        const weatherIcon = Utils.$('.weather-icon');

        if (weatherBar) {
            weatherBar.classList.add('loading');
        }
        if (weatherIcon) {
            weatherIcon.classList.add('loading');
        }

        try {
            await this.fetchRealWeatherData();
        } catch (error) {
            console.error('刷新天气失败:', error);
        } finally {
            // 移除加载状态
            setTimeout(() => {
                if (weatherBar) {
                    weatherBar.classList.remove('loading');
                }
                if (weatherIcon) {
                    weatherIcon.classList.remove('loading');
                }
            }, 300); // 延迟一下让用户看到反馈
        }
    },

    // 定时更新天气
    startAutoUpdate(interval = 30 * 60 * 1000) {
        console.log('启动天气自动更新，间隔:', interval / 60000, '分钟');

        // 清除之前的定时器，防止重复创建
        if (this.autoUpdateTimer) {
            clearInterval(this.autoUpdateTimer);
        }

        this.autoUpdateTimer = setInterval(() => {
            console.log('自动更新天气数据...');
            this.fetchRealWeatherData();
        }, interval);
    },

    // 停止自动更新
    stopAutoUpdate() {
        if (this.autoUpdateTimer) {
            clearInterval(this.autoUpdateTimer);
            this.autoUpdateTimer = null;
            console.log('天气自动更新已停止');
        }
    },

    // 根据天气代码获取天气信息（保持兼容性）
    getWeatherIcon(condition) {
        const iconMap = {
            '晴朗': '☀️',
            '多云': '⛅',
            '阴天': '☁️',
            '小雨': '🌦️',
            '大雨': '🌧️',
            '雷雨': '⛈️',
            '雪': '❄️',
            '雾': '🌫️'
        };

        return iconMap[condition] || '☀️';
    },


};

// 暴露WeatherManager到全局作用域，供其他模块使用
window.WeatherManager = WeatherManager;


// 主应用程序
const App = {
    init() {
        // 等待DOM加载完成
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                this.initializeApp();
            });
        } else {
            this.initializeApp();
        }
    },

    // 初始化应用
    async initializeApp() {
        console.log('雯婷应用启动中...');
        
        try {
            // 按顺序初始化各个模块
            await this.initializeModules();
            
            // 绑定全局事件
            this.bindGlobalEvents();
            
            console.log('雯婷应用启动完成');
        } catch (error) {
            console.error('应用初始化失败:', error);
        }
    },

    // 初始化模块
    async initializeModules() {
        // 首先初始化设备管理器
        if (window.DeviceManager) {
            DeviceManager.init();
        }
        
        // 确保 ApiClient 已加载
        if (typeof window.ApiClient === 'undefined') {
            console.error('❌ ApiClient 未加载，请检查脚本加载顺序');
            return;
        }
        
        // 初始化全局用户状态管理器
        if (window.GlobalUserState) {
            GlobalUserState.init();
        }
        
        // 初始化日期管理器
        DateManager.init();
        
        // 初始化天气管理器（等待地理位置获取完成）
        if (window.WeatherManager) {
            await WeatherManager.init();
            // 启动天气自动更新（30分钟间隔）
            WeatherManager.startAutoUpdate();
        } else {
            console.error('❌ WeatherManager未加载');
        }
        
        // 初始化用户管理器（异步，需要等待完成）
        await UserManager.init();
        
        // 初始化TODO管理器（最后初始化，因为它依赖用户管理器）
        await TodoManager.init();
        
        // 初始化Profile管理器
        if (window.ProfileManager) {
            await ProfileManager.init();
        }
        
        // 设置默认模块为todo
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('todo');
            // 绑定全局用户选择器事件
            GlobalUserState.bindUserSelectorEvents();
        }
        
        // 完成加载，显示应用界面
        if (window.LoadingManager) {
            LoadingManager.completeLoading();
            
            // 监听应用容器显示事件，然后初始化用户界面
            this.waitForAppContainerVisible();
        } else {
            console.log('⚠️ LoadingManager不存在，直接初始化用户界面');
            // 延迟一下确保DOM渲染完成
            setTimeout(() => {
                this.initializeUserInterface();
            }, 100);
        }
    },

    // 等待应用容器显示
    waitForAppContainerVisible() {
        console.log('⏳ 等待应用容器显示...');
        
        const checkAppContainer = () => {
            const appContainer = document.getElementById('appContainer');
            const loadingScreen = document.getElementById('loadingScreen');
            
            console.log('🔍 检查应用容器状态:');
            console.log('  - appContainer存在:', !!appContainer);
            console.log('  - appContainer显示:', appContainer?.style.display !== 'none');
            console.log('  - loadingScreen存在:', !!loadingScreen);
            console.log('  - loadingScreen显示:', loadingScreen?.style.display !== 'none');
            
            if (appContainer && appContainer.style.display !== 'none' && 
                (!loadingScreen || loadingScreen.style.display === 'none')) {
                console.log('✅ 应用容器已显示，开始初始化用户界面');
                this.initializeUserInterface();
            } else {
                console.log('⏳ 应用容器还未显示，继续等待...');
                setTimeout(checkAppContainer, 100);
            }
        };
        
        // 开始检查
        setTimeout(checkAppContainer, 500); // 给LoadingManager一些时间开始动画
    },

    // 初始化用户界面
    async initializeUserInterface() {
        console.log('🎨 开始初始化用户界面');
        console.log('🔍 调试信息:');
        console.log('  - TodoManager存在:', !!window.TodoManager);
        console.log('  - TodoManager.currentUser:', window.TodoManager?.currentUser);
        console.log('  - UserManager存在:', !!window.UserManager);
        console.log('  - UserManager.users数量:', window.UserManager?.users?.length || 0);
        console.log('  - GlobalUserState存在:', !!window.GlobalUserState);
        console.log('  - GlobalUserState.currentUserId:', window.GlobalUserState?.currentUserId);
        console.log('  - 当前模块:', window.GlobalUserState?.getCurrentModule());
        
        if (!window.TodoManager) {
            console.error('❌ TodoManager未初始化');
            return;
        }

        // 检查是否有用户数据存在
        if (window.UserManager && window.UserManager.users && window.UserManager.users.length > 0) {
            // 确保当前用户已设置
            if (!TodoManager.currentUser) {
                console.log('⚠️ 当前用户未设置，重新设置默认用户');
                TodoManager.setDefaultUser();
            }
            
            console.log('🎯 当前用户ID:', TodoManager.currentUser);
            console.log('🎯 当前模块:', GlobalUserState ? GlobalUserState.getCurrentModule() : 'unknown');
            
            // 首先渲染用户标签
            if (window.UserManager) {
                console.log('🔄 开始渲染用户标签...');
                window.UserManager.renderUserTabs();
                console.log('✅ 用户标签渲染完成');
            }
            
            // 然后更新用户选择器UI
            if (window.GlobalUserState) {
                console.log('🔄 开始更新用户选择器UI...');
                GlobalUserState.updateUserSelectorUI();
                console.log('✅ 用户选择器UI更新完成');
            }
            
            // 最后渲染TODO内容（如果当前模块是todo）
            if (window.GlobalUserState && GlobalUserState.getCurrentModule() === 'todo') {
                console.log('🔄 开始加载并渲染TODO内容');
                console.log('🔍 TODO数据调试:');
                console.log('  - TodoManager.todos:', TodoManager.todos);
                console.log('  - 当前用户的TODO数据:', TodoManager.todos[TodoManager.currentUser]);
                
                // 通过触发用户切换事件来加载TODO，确保与用户点击切换的行为一致
                if (TodoManager.currentUser) {
                    console.log('🎯 通过全局状态触发用户切换事件来初始化TODO显示');
                    
                    // 临时设置为null，确保setCurrentUser会触发事件
                    const targetUserId = TodoManager.currentUser;
                    GlobalUserState.currentUserId = null;
                    GlobalUserState.setCurrentUser(targetUserId);
                    
                    console.log('✅ 强制触发用户切换事件完成');
                } else {
                    console.warn('⚠️ 当前用户未设置，无法加载TODO');
                }
            } else {
                console.log('⚠️ 当前模块不是todo，跳过TODO渲染');
            }
        } else {
            console.log('🎨 没有用户，显示空用户状态');
            TodoManager.showEmptyUserState();
        }
    },

    // 绑定全局事件
    bindGlobalEvents() {
        // 绑定添加用户按钮事件
        const addUserBtn = document.getElementById('addUserBtn');
        if (addUserBtn) {
            addUserBtn.addEventListener('click', () => {
                if (window.UserManager && typeof UserManager.addUser === 'function') {
                    UserManager.addUser();
                } else {
                    console.error('UserManager.addUser 方法不可用');
                }
            });
        }
        
        // 底部导航点击效果 - 使用事件委托确保正确绑定
        document.addEventListener('click', (e) => {
            const navItem = e.target.closest('.nav-item');
            if (navItem) {
                const label = navItem.querySelector('.nav-label')?.textContent;
                console.log('导航到：', label);
                
                // 显示进度条（针对Todo和Notes页面切换）
                if ((label === 'Todo' || label === 'Notes') && window.DateManager) {
                    window.DateManager.showLoadingProgress();
                }
                
                // 这里可以添加路由逻辑
                this.handleNavigation(label);
            }
        });

        // 天气栏点击处理
        const weatherBar = Utils.$('.weather-bar');
        if (weatherBar) {
            weatherBar.addEventListener('click', (e) => {
                if (!window.WeatherManager) {
                    console.error('❌ WeatherManager未加载');
                    return;
                }
                
                // 如果点击的是位置区域且位置未授权，请求位置权限
                const locationElement = e.target.closest('.weather-location');
                if (locationElement && locationElement.classList.contains('error')) {
                    console.log('用户点击位置未授权区域，请求位置权限');
                    WeatherManager.requestLocationPermission();
                } else {
                    console.log('用户点击天气栏，刷新天气数据');
                    WeatherManager.refreshWeather();
                }
            });
            
            // 添加悬停提示
            weatherBar.style.cursor = 'pointer';
            weatherBar.title = '点击刷新天气数据，位置未授权时点击可请求权限';
        }

        // 全局错误处理
        window.addEventListener('error', (event) => {
            console.error('全局错误:', event.error);
        });

        // 页面可见性变化处理
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // 页面变为可见时，更新当前时间和天气
                if (window.DateManager) {
                    DateManager.updateCurrentDate();
                }
                
                // 检查天气数据是否需要更新
                if (window.WeatherManager && WeatherManager.weatherData?.lastUpdated) {
                    const lastUpdate = new Date(WeatherManager.weatherData.lastUpdated);
                    const now = new Date();
                    const diffMinutes = (now - lastUpdate) / (1000 * 60);
                    
                    // 如果超过15分钟，刷新天气
                    if (diffMinutes > 15) {
                        console.log('页面重新激活，刷新天气数据');
                        WeatherManager.fetchRealWeatherData();
                    }
                }
            }
        });

        // 在线/离线状态处理
        window.addEventListener('online', () => {
            console.log('网络连接恢复，刷新天气数据');
            if (window.WeatherManager) {
                WeatherManager.fetchRealWeatherData();
            }
        });

        window.addEventListener('offline', () => {
            console.log('网络连接断开，将使用缓存数据');
        });
    },

    // 处理导航
    handleNavigation(page) {
        switch (page) {
            case 'Todo':
                // 显示Todo页面
                this.showTodoPage();
                break;
            case 'Notes':
                // 显示Notes页面
                this.showNotesPage();
                break;
            case 'Link':
                // 显示Link页面（在SPA内切换）
                this.showLinkPage();
                break;
            case 'Profile':
                // 显示Profile页面
                this.showProfilePage();
                break;
            default:
                console.log('未知导航目标:', page);
        }
    },

    // 显示Todo页面
    showTodoPage() {
        console.log('切换到Todo页面');
        
        // 恢复左侧边栏显示
        if (window.ProfileManager) {
            ProfileManager.showLeftSidebar();
        }
        
        // 设置全局状态为todo模块
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('todo');
        }
        
        if (window.TodoManager) {
            const currentUser = GlobalUserState ? GlobalUserState.getCurrentUser() : TodoManager.currentUser;
            console.log('渲染TODO页面，用户:', currentUser);
            TodoManager.renderTodoPanel(currentUser);
            
            // 隐藏进度条 - 延长显示时间让用户看到效果
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 600);
        } else {
            console.error('TodoManager未初始化');
            // 即使出错也隐藏进度条
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 300);
        }
    },

    // 显示Notes页面（优化版，避免重复初始化）
    async showNotesPage() {
        console.log('切换到Notes页面');
        
        try {
            // 恢复左侧边栏显示
            if (window.ProfileManager) {
                ProfileManager.showLeftSidebar();
            }
            
            // 设置全局状态为notes模块
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentModule('notes');
            }
            
            if (window.NotesManager) {
                // 检查是否已初始化，避免重复初始化
                if (NotesManager.isOnline === false) {
                    // 重新检查连接状态
                    NotesManager.isOnline = await ApiClient.testConnection();
                }
                
                if (NotesManager.notes && Object.keys(NotesManager.notes).length > 0) {
                    // 已有数据，直接渲染
                    const currentUser = GlobalUserState ? GlobalUserState.getCurrentUser() : NotesManager.currentUser;
                    console.log('Notes数据已存在，直接渲染，用户:', currentUser);
                    NotesManager.renderNotesPanel(currentUser);
                    
                    // 延长显示时间让用户看到效果
                    setTimeout(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }, 600);
                } else {
                    // 首次加载或数据为空，需要初始化
                    console.log('首次加载Notes或数据为空，开始初始化');
                    await NotesManager.init();
                    
                    // 初始化完成后隐藏进度条
                    setTimeout(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }, 600);
                }
            } else {
                // 如果NotesManager还未加载，显示占位内容
                const contentArea = Utils.$('#contentArea');
                if (contentArea) {
                    contentArea.innerHTML = `
                        <div class="notes-content-panel">
                            <div class="notes-placeholder">
                                <h3>Notes 功能</h3>
                                <p>正在加载笔记功能...</p>
                            </div>
                        </div>
                    `;
                }
                
                // 显示占位内容后延迟隐藏进度条
                setTimeout(() => {
                    if (window.DateManager) window.DateManager.hideLoadingProgress();
                }, 600);
            }
        } catch (error) {
            console.error('加载Notes页面失败:', error);
            // 即使出错也要隐藏进度条
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 300);
        }
    },

    // 显示Profile页面
    async showProfilePage() {
        console.log('切换到Profile页面');
        
        try {
            // 设置全局状态为profile模块
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentModule('profile');
            }
            
            if (window.ProfileManager) {
                // 检查是否已初始化
                if (!ProfileManager.currentAppUser) {
                    console.log('首次加载Profile，开始初始化');
                    await ProfileManager.init();
                }
                
                // 渲染Profile页面
                await ProfileManager.renderProfilePanel();
                
                // 延长显示时间让用户看到效果
                setTimeout(() => {
                    if (window.DateManager) window.DateManager.hideLoadingProgress();
                }, 600);
            } else {
                console.error('❌ ProfileManager未加载');
                
                // 显示错误占位内容
                const contentArea = document.getElementById('contentArea');
                if (contentArea) {
                    contentArea.innerHTML = `
                        <div class="profile-content-panel">
                            <div class="profile-error">
                                <div class="error-icon">❌</div>
                                <h3>加载失败</h3>
                                <p>Profile功能未正确加载</p>
                            </div>
                        </div>
                    `;
                }
                
                // 即使出错也要隐藏进度条
                setTimeout(() => {
                    if (window.DateManager) window.DateManager.hideLoadingProgress();
                }, 300);
            }
        } catch (error) {
            console.error('加载Profile页面失败:', error);
            
            // 显示错误状态
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="profile-content-panel">
                        <div class="profile-error">
                            <div class="error-icon">❌</div>
                            <h3>加载失败</h3>
                            <p>${error.message}</p>
                            <button class="btn btn-primary" onclick="App.showProfilePage()">重试</button>
                        </div>
                    </div>
                `;
            }
            
            // 即使出错也要隐藏进度条
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 300);
        }
    },

    // 显示Link页面
    async showLinkPage() {
        console.log('切换到Link页面');
        
        try {
            // 恢复左侧边栏显示
            if (window.ProfileManager) {
                ProfileManager.showLeftSidebar();
            }
            
            // 设置全局状态为link模块
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentModule('link');
            }
            
            // 创建Link页面的内容
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="content-panel">
                        <!-- Link内容区域 -->
                        <div class="link-content-area">
                            <!-- 用户信息显示区 -->
                            <div class="user-info-display" id="userInfoDisplay">
                                <div class="empty-state">
                                    <div class="empty-icon">👤</div>
                                    <p>请从左侧选择一个用户</p>
                                    <p class="empty-subtitle">查看用户的详细信息</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                console.log('✅ Link页面HTML已创建');
            }
            
            // 初始化Link页面的事件监听
            this.initializeLinkPageEvents();
            
            // 检查是否有默认选中的用户并显示其信息
            setTimeout(() => {
                this.displayDefaultUserInLink();
            }, 100);
            
            console.log('✅ Link页面加载完成');
            
        } catch (error) {
            console.error('加载Link页面失败:', error);
            
            // 显示错误状态
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="content-panel">
                        <div class="link-error">
                            <div class="error-icon">❌</div>
                            <h3>加载失败</h3>
                            <p>${error.message}</p>
                            <button class="btn btn-primary" onclick="App.showLinkPage()">重试</button>
                        </div>
                    </div>
                `;
            }
        }
    },
    
    // 初始化Link页面事件监听
    initializeLinkPageEvents() {
        console.log('🎨 初始化Link页面事件监听...');
        
        // 监听用户选择事件
        const handleUserSelected = (event) => {
            const selectedUser = event.detail;
            console.log('👤 [SPA Link] 接收到用户选择事件:', selectedUser);
            this.displayUserInfoInLink(selectedUser);
        };
        
        // 移除旧的监听器（避免重复绑定）
        document.removeEventListener('userSelected', handleUserSelected);
        // 添加新的监听器
        document.addEventListener('userSelected', handleUserSelected);
        
        console.log('✅ Link页面事件监听初始化完成');
    },
    
    // 在Link页面显示用户信息
    displayUserInfoInLink(user) {
        console.log('🎨 [SPA Link] 显示用户信息:', user);
        
        const userInfoDisplay = document.getElementById('userInfoDisplay');
        if (userInfoDisplay && user) {
            userInfoDisplay.innerHTML = `
                <div class="selected-user-info">
                    <div class="user-avatar" style="background-color: ${user.avatar_color}">
                        ${user.display_name.charAt(0)}
                    </div>
                    <h3>${user.display_name}</h3>
                    <div class="user-details">
                        <div class="link-detail-item">
                            <span class="detail-label">用户名:</span>
                            <span class="detail-value">${user.username}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">显示名称:</span>
                            <span class="detail-value">${user.display_name}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">邮箱:</span>
                            <span class="detail-value">${user.email || '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">手机号:</span>
                            <span class="detail-value">${user.phone || '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">性别:</span>
                            <span class="detail-value">${user.gender === 'male' ? '男' : user.gender === 'female' ? '女' : user.gender === 'other' ? '其他' : '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">生日:</span>
                            <span class="detail-value">${user.birthday ? new Date(user.birthday).toLocaleDateString() : '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">头像颜色:</span>
                            <span class="detail-value">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: ${user.avatar_color}; border-radius: 50%; vertical-align: middle; margin-right: 8px;"></span>
                                ${user.avatar_color}
                            </span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">创建时间:</span>
                            <span class="detail-value">${new Date(user.created_at).toLocaleString()}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">最后更新:</span>
                            <span class="detail-value">${new Date(user.updated_at).toLocaleString()}</span>
                        </div>
                    </div>
                </div>
            `;
            
            console.log('✅ [SPA Link] 用户信息已更新');
        } else {
            console.error('❌ [SPA Link] userInfoDisplay元素未找到或用户为空');
        }
    },
    
    // 显示默认选中用户的信息
    displayDefaultUserInLink() {
        console.log('🔍 [SPA Link] 检查默认选中用户...');
        
        const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : null;
        if (currentUserId && window.UserManager && window.UserManager.users) {
            const selectedUser = window.UserManager.users.find(user => user.id === currentUserId);
            if (selectedUser) {
                console.log('👤 [SPA Link] 找到默认用户，显示信息:', selectedUser.username);
                this.displayUserInfoInLink(selectedUser);
            } else {
                console.log('⚠️ [SPA Link] 未找到默认用户对象');
            }
        } else {
            console.log('ℹ️ [SPA Link] 没有默认用户或用户管理器未就绪');
        }
    },

    // 应用状态管理
    getState() {
        return {
            currentUser: TodoManager.currentUser,
            selectedDate: DateManager.selectedDate,
            todos: TodoManager.todos,
            users: UserManager.users,
            weather: WeatherManager.weatherData
        };
    },

    // 重置应用
    reset() {
        alert('重置功能已禁用，应用完全依赖服务器数据。');
    },

    // 导出数据
    exportData() {
        const data = {
            version: '1.0',
            exportTime: new Date().toISOString(),
            ...this.getState()
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `wenting_backup_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
    },

    // 导入数据
    importData(fileInput) {
        const file = fileInput.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                
                if (data.version && data.todos) {
                    // 导入数据
                    if (data.todos) TodoManager.todos = data.todos;
                    if (data.users) UserManager.users = data.users;
                    if (data.weather) WeatherManager.weatherData = data.weather;
                    
                    // 保存数据
                    TodoManager.saveTodos();
                    UserManager.saveUsers();
                    WeatherManager.saveWeatherData();
                    
                    alert('数据导入成功！页面将刷新。');
                    location.reload();
                } else {
                    alert('无效的备份文件格式');
                }
            } catch (error) {
                alert('导入失败：' + error.message);
            }
        };
        reader.readAsText(file);
    }
};

// 启动应用
App.init();

// 将App暴露到全局，方便调试
window.App = App;

// 调试方法：清除位置缓存并重新获取
window.debugClearLocation = function() {
    console.log('🔧 调试：清除位置缓存并重新获取');
    WeatherManager.clearLocationCache();
    WeatherManager.getCurrentLocation().then(() => {
        WeatherManager.fetchRealWeatherData();
        WeatherManager.updateWeatherDisplay();
    });
};
