

// 应用配置
window.APP_CONFIG = {

    // 天气配置 - 初始状态，等待真实数据
    weather: {
        location: '获取位置中...',
        icon: '🌐',
        condition: '加载中',
        temperature: '--°C',
        wind: {
            level: '--',
            label: '风力'
        },
        humidity: {
            value: '--%',
            label: '湿度'
        }
    }
};


// 工具函数
const Utils = {
    // DOM选择器 - 单个元素
    $: (selector) => {
        return document.querySelector(selector);
    },

    // DOM选择器 - 多个元素
    $$: (selector) => {
        return Array.from(document.querySelectorAll(selector));
    },

    // 格式化日期
    formatDate: (date) => {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        return {
            month: months[date.getMonth()],
            date: date.getDate(),
            weekday: weekdays[date.getDay()],
            full: `${months[date.getMonth()]} ${date.getDate()}`
        };
    },

    // 计算日期范围
    calculateDateRange: (periodText) => {
        const now = new Date();
        let endDate = new Date(now);
        
        if (periodText.includes('周')) {
            const weeks = parseInt(periodText);
            endDate.setDate(now.getDate() + weeks * 7 - 1);
        } else if (periodText.includes('个月')) {
            const months_count = parseInt(periodText);
            endDate.setMonth(now.getMonth() + months_count);
            endDate.setDate(now.getDate() - 1);
        } else {
            return ''; // 对于"每日"等不需要显示日期范围
        }
        
        const startMonth = now.getMonth() + 1;
        const startDay = now.getDate();
        const endMonth = endDate.getMonth() + 1;
        const endDay = endDate.getDate();
        
        return `${startMonth}/${startDay}-${endMonth}/${endDay}`;
    },

    // 生成唯一ID
    generateId: () => {
        return 'id_' + Math.random().toString(36).substr(2, 9);
    },

    // 防抖函数
    debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    // 深拷贝
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Array) return obj.map(item => Utils.deepClone(item));
        if (typeof obj === 'object') {
            const clonedObj = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    clonedObj[key] = Utils.deepClone(obj[key]);
                }
            }
            return clonedObj;
        }
    },

    // 节流函数
    throttle: (func, limit) => {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },

    // HTML转义函数，防止XSS攻击
    escapeHtml: (text) => {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
};

// 导出到全局
window.Utils = Utils;


// 设备管理器 - 基于设备指纹的设备识别
const DeviceManager = {
    deviceId: null,
    deviceInfo: null,

    // 初始化设备管理器
    async init() {
        console.log('🔧 初始化设备管理器...');
        this.deviceId = this.getOrCreateDeviceId();
        this.deviceInfo = this.getDeviceInfo();
        
        console.log('📱 设备ID:', this.deviceId);
        console.log('📊 设备信息:', this.deviceInfo);
        
        // 在页面上显示设备信息（调试用）
        this.displayDeviceInfo();
        
        // 确保新用户的设备ID同步到数据库
        const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        if (currentAppUser && this.deviceId) {
            console.log('🔄 为新用户同步设备ID到数据库...');
            // 异步同步，不阻塞初始化
            setTimeout(() => {
                this.syncDeviceIdToDatabase();
            }, 1000);
        }
        
        return this.deviceId;
    },

    // 获取或创建设备ID
    getOrCreateDeviceId() {
        // 先尝试从localStorage获取已存在的设备ID
        let deviceId = localStorage.getItem('wenting_device_id');
        
        if (deviceId) {
            console.log('📱 找到已存在的设备ID:', deviceId);
            return deviceId;
        }
        
        // 检查是否有当前登录用户，如果有，尝试从数据库获取该用户的设备ID
        const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        if (currentAppUser) {
            console.log('🔍 检测到已登录用户:', currentAppUser, '尝试获取其设备ID...');
            const existingDeviceId = this.tryGetExistingDeviceId(currentAppUser);
            if (existingDeviceId) {
                console.log('✅ 找到现有设备ID:', existingDeviceId);
                localStorage.setItem('wenting_device_id', existingDeviceId);
                return existingDeviceId;
            }
        }
        
        // 如果没有，则生成新的设备ID
        deviceId = this.generateDeviceId();
        localStorage.setItem('wenting_device_id', deviceId);
        
        console.log('🆕 生成新的设备ID:', deviceId);
        return deviceId;
    },

    // 生成设备指纹ID
    generateDeviceId() {
        const fingerprint = this.generateDeviceFingerprint();
        
        // 使用指纹生成一个相对稳定的设备ID
        const deviceId = this.hashString(fingerprint);
        
        console.log('🔍 设备指纹:', fingerprint);
        console.log('🆔 生成的设备ID:', deviceId);
        
        return deviceId;
    },

    // 生成设备指纹
    generateDeviceFingerprint() {
        const components = [];
        
        // 1. 用户代理字符串
        components.push(navigator.userAgent);
        
        // 2. 屏幕分辨率
        components.push(`${screen.width}x${screen.height}`);
        
        // 3. 屏幕色深
        components.push(screen.colorDepth.toString());
        
        // 4. 时区偏移
        components.push(new Date().getTimezoneOffset().toString());
        
        // 5. 语言设置
        components.push(navigator.language || navigator.userLanguage || 'unknown');
        
        // 6. 平台信息
        components.push(navigator.platform);
        
        // 7. 是否支持触摸
        components.push(('ontouchstart' in window).toString());
        
        // 8. 设备内存（如果支持）
        if (navigator.deviceMemory) {
            components.push(navigator.deviceMemory.toString());
        }
        
        // 9. 硬件并发数
        if (navigator.hardwareConcurrency) {
            components.push(navigator.hardwareConcurrency.toString());
        }
        
        // 10. Canvas指纹（简化版）
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Device fingerprint test 🔍', 2, 2);
            components.push(canvas.toDataURL());
        } catch (e) {
            components.push('canvas-error');
        }
        
        return components.join('|');
    },

    // 简单的字符串哈希函数
    hashString(str) {
        let hash = 0;
        if (str.length === 0) return hash.toString();
        
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 转换为32位整数
        }
        
        // 转换为正数并添加前缀
        const deviceId = 'device_' + Math.abs(hash).toString(16);
        return deviceId;
    },

    // 获取设备信息
    getDeviceInfo() {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTablet = /iPad|Android(?!.*Mobile)/i.test(navigator.userAgent);
        
        let deviceType = 'desktop';
        if (isTablet) {
            deviceType = 'tablet';
        } else if (isMobile) {
            deviceType = 'mobile';
        }
        
        return {
            type: deviceType,
            isMobile: isMobile,
            isTablet: isTablet,
            isDesktop: !isMobile && !isTablet,
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            screen: {
                width: screen.width,
                height: screen.height,
                colorDepth: screen.colorDepth
            },
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };
    },

    // 在页面上显示设备信息（调试用）
    displayDeviceInfo() {
        // 在天气栏添加设备标识
        const locationElement = document.querySelector('.weather-location');
        if (locationElement && this.deviceInfo) {
            const deviceTypeIcon = this.getDeviceTypeIcon();
            const shortDeviceId = this.deviceId.substring(this.deviceId.length - 6);
            
            // 在位置信息后添加设备标识
            const originalTitle = locationElement.title || '';
            locationElement.title = `${originalTitle}\n设备: ${deviceTypeIcon} ${this.deviceInfo.type} (${shortDeviceId})`;
            
            // 可选：在位置文本后添加设备图标
            if (locationElement.textContent && !locationElement.textContent.includes('📱') && !locationElement.textContent.includes('💻')) {
                locationElement.textContent += ` ${deviceTypeIcon}`;
            }
        }
        
        console.log('📱 设备信息已显示在天气栏');
    },

    // 获取设备类型图标
    getDeviceTypeIcon() {
        switch (this.deviceInfo.type) {
            case 'mobile':
                return '📱';
            case 'tablet':
                return '📱';
            case 'desktop':
            default:
                return '💻';
        }
    },

    // 获取当前设备ID
    getCurrentDeviceId() {
        return this.deviceId;
    },

    // 获取设备信息
    getDeviceInformation() {
        return this.deviceInfo;
    },

    // 重置设备ID（调试用）
    resetDeviceId() {
        localStorage.removeItem('wenting_device_id');
        console.log('🔄 设备ID已重置，请刷新页面');
        return this.init();
    },

    // 检查是否为新设备
    isNewDevice() {
        return !localStorage.getItem('wenting_device_id');
    },

    // 尝试从后端获取现有用户的设备ID
    tryGetExistingDeviceId(appUserId) {
        try {
            // 这是一个同步方法，我们需要用异步方式处理
            // 先返回null，然后通过事件系统处理
            setTimeout(() => {
                this.fetchExistingDeviceIdAsync(appUserId);
            }, 100);
            return null;
        } catch (error) {
            console.error('获取现有设备ID失败:', error);
            return null;
        }
    },

    // 异步获取现有设备ID
    async fetchExistingDeviceIdAsync(appUserId) {
        try {
            // 使用ApiClient的动态URL构建逻辑
            if (!window.ApiClient) {
                console.error('❌ ApiClient未初始化');
                return;
            }
            
            // 调用后端API获取该用户的设备ID
            const data = await window.ApiClient.get(`/auth/device-info/${encodeURIComponent(appUserId)}`);
            if (data.success && data.data && data.data.device_id) {
                const existingDeviceId = data.data.device_id;
                console.log('🔄 从服务器获取到设备ID:', existingDeviceId);
                
                // 更新localStorage中的设备ID
                localStorage.setItem('wenting_device_id', existingDeviceId);
                this.deviceId = existingDeviceId;
                
                // 触发设备ID更新事件
                window.dispatchEvent(new CustomEvent('deviceIdUpdated', {
                    detail: { deviceId: existingDeviceId }
                }));
                
                console.log('✅ 设备ID已同步，请刷新页面或重新加载用户数据');
            }
        } catch (error) {
            console.error('异步获取设备ID失败:', error);
        }
    },

    // 手动设置设备ID（调试用）
    setDeviceId(newDeviceId) {
        console.log('🔧 手动设置设备ID:', newDeviceId);
        localStorage.setItem('wenting_device_id', newDeviceId);
        this.deviceId = newDeviceId;
        
        // 触发设备ID更新事件
        window.dispatchEvent(new CustomEvent('deviceIdUpdated', {
            detail: { deviceId: newDeviceId }
        }));
        
        return newDeviceId;
    },

    // 同步设备ID到数据库中的用户记录
    async syncDeviceIdToDatabase() {
        const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        if (!currentAppUser || !this.deviceId) {
            return;
        }
        
        try {
            console.log('🔄 尝试将设备ID同步到数据库用户记录...');
            
            // 使用ApiClient的动态URL构建逻辑
            if (!window.ApiClient) {
                console.error('❌ ApiClient未初始化');
                return;
            }
            
            const data = await window.ApiClient.post('/auth/update-device-id', {
                app_user_id: currentAppUser,
                device_id: this.deviceId
            });
            
            console.log('✅ 设备ID同步成功:', data);
        } catch (error) {
            console.error('设备ID同步失败:', error);
        }
    }
};

// 导出到全局
window.DeviceManager = DeviceManager;

// 调试方法
window.debugResetDevice = function() {
    console.log('🔧 调试：重置设备ID');
    DeviceManager.resetDeviceId();
    location.reload();
};

window.debugShowDeviceInfo = function() {
    console.log('📱 当前设备信息:');
    console.log('  设备ID:', DeviceManager.getCurrentDeviceId());
    console.log('  设备信息:', DeviceManager.getDeviceInformation());
};

window.debugSetDeviceId = function(deviceId) {
    console.log('🔧 调试：手动设置设备ID');
    DeviceManager.setDeviceId(deviceId);
    console.log('✅ 设备ID已设置，请刷新页面');
};

window.debugSyncDeviceId = function() {
    console.log('🔄 调试：同步设备ID到数据库');
    DeviceManager.syncDeviceIdToDatabase();
};


// API客户端 - 连接前端和后端
const ApiClient = {
    // 动态获取API基础URL
    get baseURL() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol;
        let apiHost;

        // 自动适配 cloudflare tunnel 的 https 域名
        if (protocol === 'https:' && hostname.endsWith('.trycloudflare.com')) {
            // 直接用当前域名的 https，且不加端口
            apiHost = `https://${hostname}`;
        } else if (hostname === '192.168.3.5') {
            apiHost = 'http://192.168.3.5:3001';
        } else if (hostname === 'localhost' || hostname === '127.0.0.1') {
            apiHost = 'http://localhost:3001';
        } else {
            // 默认使用当前主机的3001端口
            apiHost = `http://${hostname}:3001`;
        }

        return `${apiHost}/api`;
    },
    
    // 通用请求方法
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        
        // 添加设备ID和当前登录用户到请求头
        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const currentAppUser = localStorage.getItem('wenting_current_app_user');
        
        const config = {
            headers: {
                'Content-Type': 'application/json',
                'X-Device-ID': deviceId,
                'X-App-User': currentAppUser,
                ...options.headers
            },
            ...options
        };

        if (config.body && typeof config.body === 'object') {
            config.body = JSON.stringify(config.body);
        }

        try {
            console.log('🌐 发送API请求:', url, config);
            const response = await fetch(url, config);
            console.log('📡 收到响应:', response.status, response.statusText);
            
            let data;
            try {
                data = await response.json();
                console.log('📄 响应数据:', data);
            } catch (jsonError) {
                console.error('JSON解析失败:', jsonError);
                throw new Error('服务器响应格式错误');
            }
            
            if (!response.ok) {
                let errorMessage = data.message || `HTTP error! status: ${response.status}`;
                
                // 如果有详细的验证错误，显示它们
                if (data.errors && Array.isArray(data.errors)) {
                    errorMessage += ': ' + data.errors.join(', ');
                }
                
                console.error('❌ API请求失败:', errorMessage);
                console.error('❌ 完整错误信息:', data);
                throw new Error(errorMessage);
            }
            
            return data;
        } catch (error) {
            console.error('❌ API请求异常:', error);
            
            // 处理网络错误
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
                throw new Error('网络连接失败，请检查服务器是否运行');
            }
            
            throw error;
        }
    },

    // GET请求
    async get(endpoint) {
        return this.request(endpoint, { method: 'GET' });
    },

    // POST请求
    async post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            body: data
        });
    },

    // PUT请求
    async put(endpoint, data) {
        return this.request(endpoint, {
            method: 'PUT',
            body: data
        });
    },

    // DELETE请求
    async delete(endpoint) {
        return this.request(endpoint, { method: 'DELETE' });
    },

    // 用户相关API
    users: {
        // 获取所有用户（支持跨设备访问）
        async getAll() {
            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            
            console.log('🔍 ApiClient.users.getAll 调试信息:');
            console.log('  - deviceId:', deviceId);
            console.log('  - appUserId:', appUserId);
            console.log('  - localStorage keys:', Object.keys(localStorage));
            
            if (!appUserId) {
                console.error('❌ 用户未登录，跳转到登录页');
                // 自动跳转到登录页
                window.location.href = 'login.html';
                throw new Error('用户未登录，正在跳转到登录页...');
            }
            
            // 使用跨设备查询模式（推荐）
            let url = `/users?app_user_id=${encodeURIComponent(appUserId)}`;
            
            // 如果有设备ID，也传递给后端（用于审计和兼容性）
            if (deviceId) {
                url += `&device_id=${encodeURIComponent(deviceId)}`;
            }
            
            console.log('📡 发送用户列表请求（跨设备模式）:', url);
            
            return ApiClient.get(url);
        },

        // 根据ID获取用户
        async getById(id) {
            return ApiClient.get(`/users/${id}`);
        },

        // 创建用户
        async create(userData) {
            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            
            console.log('🔍 ApiClient.users.create 调试信息:');
            console.log('  - deviceId:', deviceId);
            console.log('  - appUserId:', appUserId);
            
            if (!deviceId) {
                console.error('❌ 设备ID未初始化');
                throw new Error('设备ID未初始化，请刷新页面重试');
            }
            
            if (!appUserId) {
                console.error('❌ 用户未登录，跳转到登录页');
                // 自动跳转到登录页
                window.location.href = 'login.html';
                throw new Error('用户未登录，正在跳转到登录页...');
            }
            
            // 添加设备ID和注册用户ID到用户数据
            const userDataWithDevice = {
                ...userData,
                device_id: deviceId,
                app_user_id: appUserId
            };
            
            console.log('📤 发送创建用户请求，数据:', userDataWithDevice);
            
            return ApiClient.post('/users', userDataWithDevice);
        },

        // 更新用户
        async update(id, userData) {
            return ApiClient.put(`/users/${id}`, userData);
        },

        // 删除用户
        async delete(id) {
            return ApiClient.delete(`/users/${id}`);
        },

        // 获取用户设置
        async getSettings(id) {
            return ApiClient.get(`/users/${id}/settings`);
        },

        // 更新用户设置
        async updateSettings(id, settings) {
            return ApiClient.put(`/users/${id}/settings`, settings);
        }
    },

    // TODO相关API
    todos: {
        // 获取用户的所有TODO
        async getByUserId(userId) {
            return ApiClient.get(`/todos/user/${userId}`);
        },

        // 获取用户今日TODO
        async getTodayTodos(userId) {
            return ApiClient.get(`/todos/user/${userId}/today`);
        },

        // 获取用户指定日期的TODO
        async getTodosForDate(userId, date) {
            return ApiClient.get(`/todos/user/${userId}/date/${date}`);
        },

        // 根据ID获取TODO
        async getById(id) {
            return ApiClient.get(`/todos/${id}`);
        },

        // 创建TODO
        async create(todoData) {
            return ApiClient.post('/todos', todoData);
        },

        // 更新TODO
        async update(id, todoData) {
            return ApiClient.put(`/todos/${id}`, todoData);
        },

        // 删除TODO
        async delete(id, deletionType = 'all', deletionDate = null) {
            return ApiClient.request(`/todos/${id}`, {
                method: 'DELETE',
                body: { deletion_type: deletionType, deletion_date: deletionDate }
            });
        },

        // 完成TODO
        async complete(id, userId, date, notes = '') {
            return ApiClient.post(`/todos/${id}/complete`, {
                user_id: userId,
                date: date,
                notes
            });
        },

        // 取消完成TODO
        async uncomplete(id, date, userId) {
            return ApiClient.post(`/todos/${id}/uncomplete`, {
                date: date,
                user_id: userId
            });
        }
    },

    // 重复模式相关API
    patterns: {
        // 获取所有重复模式
        async getAll() {
            return ApiClient.get('/patterns');
        },

        // 获取预设重复模式
        async getPresets() {
            return ApiClient.get('/patterns/presets');
        },

        // 根据ID获取重复模式
        async getById(id) {
            return ApiClient.get(`/patterns/${id}`);
        },

        // 创建重复模式
        async create(patternData) {
            return ApiClient.post('/patterns', patternData);
        },

        // 创建预设重复模式
        async createPreset(name) {
            return ApiClient.post(`/patterns/presets/${name}`);
        },

        // 检查日期是否匹配模式
        async checkDateMatch(id, targetDate, startDate) {
            return ApiClient.post(`/patterns/${id}/check`, {
                targetDate,
                startDate
            });
        },

        // 获取下一个匹配日期
        async getNextMatchDate(id, currentDate, startDate) {
            return ApiClient.post(`/patterns/${id}/next`, {
                currentDate,
                startDate
            });
        },

        // 获取时间范围内的匹配日期
        async getMatchDatesInRange(id, startDate, rangeStart, rangeEnd) {
            return ApiClient.post(`/patterns/${id}/range`, {
                startDate,
                rangeStart,
                rangeEnd
            });
        }
    },

    // Notes相关API
    notes: {
        // 获取用户的所有Notes
        async getByUserId(userId) {
            return ApiClient.get(`/notes/user/${userId}`);
        },

        // 根据ID获取Note
        async getById(id) {
            return ApiClient.get(`/notes/${id}`);
        },

        // 创建Note
        async create(noteData) {
            return ApiClient.post('/notes', noteData);
        },

        // 更新Note
        async update(id, noteData) {
            return ApiClient.put(`/notes/${id}`, noteData);
        },

        // 删除Note
        async delete(id) {
            return ApiClient.delete(`/notes/${id}`);
        },

        // 搜索Notes
        async search(searchTerm, userId = null) {
            const params = userId ? `?userId=${userId}` : '';
            return ApiClient.get(`/notes/search/${encodeURIComponent(searchTerm)}${params}`);
        },

        // 生成AI建议（传递真实天气数据）
        async generateAISuggestions(id) {
            // 获取用户位置信息
            console.log('🔍 开始获取用户位置和天气信息...');
            
            let userLocation = null;
            
            // 检查WeatherManager是否存在和初始化
            if (!window.WeatherManager) {
                console.log('❌ WeatherManager未初始化，无法获取位置信息');
            } else {
                console.log('✅ WeatherManager已初始化，状态:', {
                    locationReady: window.WeatherManager.locationReady,
                    hasUserLocation: !!window.WeatherManager.userLocation
                });
                
                if (window.WeatherManager.locationReady && window.WeatherManager.userLocation) {
                    userLocation = window.WeatherManager.userLocation;
                    console.log('📍 直接获取到用户位置:', userLocation);
                } else {
                    console.log('⏳ 用户位置还未准备好，尝试等待获取...');
                    
                    // 等待位置获取完成，最多等待5秒
                    let attempts = 0;
                    const MAX_ATTEMPTS = 10; // 5秒内检查10次
                    
                    while (attempts < MAX_ATTEMPTS && !userLocation) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        if (window.WeatherManager.locationReady && window.WeatherManager.userLocation) {
                            userLocation = window.WeatherManager.userLocation;
                            console.log('📍 等待后获取到用户位置:', userLocation);
                            break;
                        }
                        
                        attempts++;
                        console.log(`⏳ 位置获取尝试 ${attempts}/${MAX_ATTEMPTS}`);
                    }
                    
                    if (!userLocation) {
                        console.log('❌ 等待超时，无法获取用户位置');
                        console.log('🔍 最终WeatherManager状态:', {
                            locationReady: window.WeatherManager.locationReady,
                            userLocation: window.WeatherManager.userLocation
                        });
                    }
                }
            }
            
            // 获取天气数据
            console.log('🌤️ 开始获取天气数据...');
            let weatherData = null;
            
            if (window.WeatherManager && window.WeatherManager.weatherData) {
                weatherData = window.WeatherManager.weatherData;
                console.log('🌤️ 获取到天气数据:', weatherData);
            } else {
                console.log('❌ WeatherManager中无天气数据');
            }
            
            console.log('📍 最终发送给AI服务的位置:', userLocation);
            console.log('🌤️ 最终发送给AI服务的天气数据:', weatherData);
            
            return ApiClient.post(`/notes/${id}/ai-suggestions`, {
                userLocation: userLocation,
                weatherData: weatherData
            });
        }
    },

    // 认证相关API
    auth: {
        // 注册
        async register(username, password) {
            // 认证API不需要在headers中添加当前用户信息
            return fetch(`${ApiClient.baseURL}/auth/register`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            }).then(response => response.json());
        },

        // 登录
        async login(username, password) {
            return fetch(`${ApiClient.baseURL}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            }).then(response => response.json());
        },

        // 验证登录状态
        async verify(username) {
            return fetch(`${ApiClient.baseURL}/auth/verify?username=${encodeURIComponent(username)}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());
        },

        // 获取用户资料（用于Profile页面）
        async getProfile(username) {
            return fetch(`${ApiClient.baseURL}/auth/profile/${encodeURIComponent(username)}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());
        }
    },

    // 健康检查
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseURL.replace('/api', '')}/health`);
            return await response.json();
        } catch (error) {
            console.error('健康检查失败:', error);
            return { success: false, message: '服务器连接失败' };
        }
    },

    // 测试连接
    async testConnection() {
        try {
            const health = await this.healthCheck();
            if (health.success) {
                console.log('✅ 后端服务连接成功');
                return true;
            } else {
                console.warn('⚠️ 后端服务响应异常:', health.message);
                return false;
            }
        } catch (error) {
            console.error('❌ 后端服务连接失败:', error.message);
            return false;
        }
    }
};

// 导出到全局
window.ApiClient = ApiClient;


// WebSocket客户端 - 实时通信管理
const WebSocketClient = {
    ws: null,
    isConnected: false,
    reconnectAttempts: 0,
    MAX_RECONNECT_ATTEMPTS: 5,
    RECONNECT_INTERVAL: 2000,
    HEARTBEAT_INTERVAL: null,
    REQUEST_TIMEOUT: 120000, // 120秒超时
    REGISTRATION_TIMEOUT: 5000, // 5秒注册超时
    messageHandlers: new Map(),
    lastDataStatus: {
        lastTodoUpdate: null,
        lastNoteUpdate: null,
        hasLinkedData: false
    },
    
    // 获取WebSocket URL
    getWebSocketURL() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        let wsHost;

        // 自动适配 cloudflare tunnel 的域名
        if (protocol === 'wss:' && hostname.endsWith('.trycloudflare.com')) {
            wsHost = `wss://${hostname}`;
        } else if (hostname === '192.168.3.5') {
            wsHost = 'ws://192.168.3.5:3001';
        } else if (hostname === 'localhost' || hostname === '127.0.0.1') {
            wsHost = 'ws://localhost:3001';
        } else {
            wsHost = `ws://${hostname}:3001`;
        }

        return `${wsHost}/ws`;
    },

    // 初始化WebSocket连接
    async init() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            console.log('⚠️ WebSocket已连接，无需重复初始化');
            return true;
        }

        return new Promise((resolve, reject) => {
            try {
                const wsUrl = this.getWebSocketURL();
                console.log('🔄 正在连接WebSocket:', wsUrl);
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('✅ WebSocket连接成功');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.startHeartbeat();
                    
                    // 连接建立后立即发送注册消息
                    this.sendRegistrationMessage();
                    
                    resolve(true);
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        console.error('❌ WebSocket消息解析失败:', error);
                    }
                };

                this.ws.onclose = (event) => {
                    console.log('🔌 WebSocket连接关闭:', event.code, event.reason);
                    this.isConnected = false;
                    this.stopHeartbeat();
                    
                    // 如果不是主动关闭，尝试重连
                    if (event.code !== 1000 && this.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
                        this.scheduleReconnect();
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('❌ WebSocket连接错误:', error);
                    this.isConnected = false;
                    reject(error);
                };

            } catch (error) {
                console.error('❌ WebSocket初始化失败:', error);
                reject(error);
            }
        });
    },

    // 发送消息
    async sendMessage(type, data = {}) {
        if (!this.isConnected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocket未连接');
        }

        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const userId = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;

        const message = {
            type,
            deviceId,
            userId,
            appUserId,
            data,
            timestamp: Date.now()
        };

        return new Promise((resolve, reject) => {
            try {
                // 注册响应处理器
                const responseType = `${type}_RESPONSE`;
                const errorType = `${type}_ERROR`;
                
                const timeout = setTimeout(() => {
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    console.warn(`⚠️ WebSocket请求超时: ${type}`, data);
                    reject(new Error('请求超时'));
                }, this.REQUEST_TIMEOUT);

                this.messageHandlers.set(responseType, (response) => {
                    clearTimeout(timeout);
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    resolve(response);
                });

                this.messageHandlers.set(errorType, (error) => {
                    clearTimeout(timeout);
                    this.messageHandlers.delete(responseType);
                    this.messageHandlers.delete(errorType);
                    reject(new Error(error.error || '请求失败'));
                });

                // 发送消息
                this.ws.send(JSON.stringify(message));
                console.log('📤 发送WebSocket消息:', type, data);
                
            } catch (error) {
                reject(error);
            }
        });
    },

    // 处理接收到的消息
    handleMessage(message) {
        const { type } = message;
        this._logMessageReceived(type, message);
        
        if (this._handleSpecialMessages(type, message)) return;
        if (this._handleRegisteredHandlers(type, message)) return;
        if (this._handleHeartbeatMessages(type, message)) return;
        if (this._handleSyncMessages(type, message)) return;
        if (this._handleBroadcastMessages(type, message)) return;
        if (this._handleLinkMessages(type, message)) return;
        if (this._handleResponseMessages(type, message)) return;
        
        console.log('⚠️ 未处理的消息类型:', type);
    },

    // 记录消息接收
    _logMessageReceived(type, message) {
        console.log('📥 收到WebSocket消息:', type, message);
        
        const currentAppUser = localStorage.getItem('wenting_current_app_user');
        console.log(`🔍 [WebSocket] 消息接收调试:`, {
            messageType: type,
            currentAppUser: currentAppUser,
            timestamp: new Date().toISOString(),
            messageData: message
        });
    },

    // 处理特殊消息
    _handleSpecialMessages(type, message) {
        if (type === 'USER_REGISTRATION_RESPONSE') {
            this._handleRegistrationResponse(message);
            return true;
        }
        return false;
    },

    // 处理注册响应
    _handleRegistrationResponse(message) {
        if (this.registrationTimeout) {
            clearTimeout(this.registrationTimeout);
            this.registrationTimeout = null;
        }
        console.log('✅ WebSocket注册确认收到:', message);
    },

    // 处理已注册的处理器
    _handleRegisteredHandlers(type, message) {
        if (this.messageHandlers.has(type)) {
            const handler = this.messageHandlers.get(type);
            handler(message);
            return true;
        }
        return false;
    },

    // 处理心跳消息
    _handleHeartbeatMessages(type, message) {
        if (type === 'PONG' || type === 'PING_RESPONSE') {
            console.log('💗 收到心跳响应');
            this.handleHeartbeatResponse(message);
            return true;
        }
        return false;
    },

    // 处理同步消息
    _handleSyncMessages(type, message) {
        if (type === 'TODO_SYNC_UPDATE' || type === 'NOTES_SYNC_UPDATE' || type === 'DATA_SYNC_UPDATE') {
            this._logSyncMessage(type, message);
            this.handleSyncMessage(message);
            return true;
        }
        return false;
    },


    // 记录Notes同步
    _logNotesSync(message) {
        console.log(`📝 [NOTES_SYNC] blackblade收到Notes同步消息:`, {
            fromUser: message.sync?.fromUser,
            operation: message.operation,
            userId: message.sync?.userId,
            currentAppUser: localStorage.getItem('wenting_current_app_user'),
            timestamp: new Date().toISOString()
        });
    },

    // 处理广播消息
    _handleBroadcastMessages(type, message) {
        if (type.endsWith('_BROADCAST')) {
            this.handleBroadcast(message);
            return true;
        }
        return false;
    },

    // 处理Link消息
    _handleLinkMessages(type, message) {
        if (type.startsWith('LINK_')) {
            this.handleLinkNotification(message);
            return true;
        }
        return false;
    },

    // 处理响应消息
    _handleResponseMessages(type, message) {
        if (type.endsWith('_RESPONSE')) {
            console.log(`📨 收到响应消息: ${type}`, message.success ? '✅' : '❌');
            return true;
        }
        return false;
    },

    // 🔥 新增：统一的同步消息处理方法
    handleSyncMessage(message) {
        const syncContext = this._parseSyncMessage(message);
        const isRelevantPage = this._isRelevantPageForSync(syncContext);
        
        this._logSyncMessage(syncContext, isRelevantPage);
        this._performDataSync(syncContext);
        this._showSyncNotification(syncContext, isRelevantPage);
        this._notifyManagersForSync(syncContext, message);
    },

    // 解析同步消息
    _parseSyncMessage(message) {
        const { type, operation, sync } = message;
        const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : 'unknown';
        
        return {
            type,
            operation,
            sync,
            currentModule,
            dataType: this._getDataTypeFromSyncType(type)
        };
    },

    // 获取数据类型
    _getDataTypeFromSyncType(syncType) {
        if (syncType === 'TODO_SYNC_UPDATE') return 'todos';
        if (syncType === 'NOTES_SYNC_UPDATE') return 'notes';
        return 'all';
    },

    // 检查是否为相关页面
    _isRelevantPageForSync(syncContext) {
        const { type, currentModule } = syncContext;
        return (type === 'TODO_SYNC_UPDATE' && currentModule === 'todo') ||
               (type === 'NOTES_SYNC_UPDATE' && currentModule === 'notes');
    },

    // 记录同步消息
    _logSyncMessage(syncContext, isRelevantPage) {
        const { type, operation, currentModule, sync } = syncContext;
        
        console.log(`🔄 [SYNC] 处理同步消息:`, {
            type,
            operation,
            currentModule,
            fromUser: sync?.fromUser,
            userId: sync?.userId
        });

        if (!isRelevantPage) {
            console.log(`⏸️ [SYNC] 当前页面(${currentModule})与同步类型(${type})不匹配，只进行后台数据同步`);
        }
    },

    // 执行数据同步
    _performDataSync(syncContext) {
        this.reloadApplicationData(syncContext.dataType, true);
    },

    // 显示同步通知
    _showSyncNotification(syncContext, isRelevantPage) {
        const { operation, type, sync } = syncContext;
        
        if (sync && sync.fromUser) {
            const operationText = this._getOperationText(operation);
            const itemType = type.includes('TODO') ? '待办事项' : '笔记';
            const syncType = isRelevantPage ? '已同步' : '后台同步';
            
            this.showSyncNotification(
                `${sync.fromUser} ${operationText}了${itemType} (${syncType})`, 
                isRelevantPage ? 'success' : 'info'
            );
        }
    },

    // 获取操作文本
    _getOperationText(operation) {
        const operationTexts = {
            'COMPLETE': '完成',
            'UNCOMPLETE': '取消完成',
            'CREATE': '创建',
            'UPDATE': '更新',
            'DELETE': '删除'
        };
        return operationTexts[operation] || operation;
    },

    // 通知管理器处理同步
    _notifyManagersForSync(syncContext, message) {
        const { type } = syncContext;
        
        if (type === 'TODO_SYNC_UPDATE' && window.TodoManager) {
            window.TodoManager.handleWebSocketBroadcast('TODO_SYNC_UPDATE', message);
        } else if (type === 'NOTES_SYNC_UPDATE' && window.NotesManager) {
            console.log('🔄 [WebSocket] 调用NotesManager处理同步消息');
            window.NotesManager.handleWebSocketBroadcast('NOTES_SYNC_UPDATE', message);
        }
    },

    // 处理广播消息（其他设备的操作）
    handleBroadcast(message) {
        const { type, data } = message;
        console.log('📡 处理广播消息:', type);

        // 根据消息类型更新界面
        switch (type) {
            case 'TODO_CREATE_BROADCAST':
            case 'TODO_UPDATE_BROADCAST':
            case 'TODO_DELETE_BROADCAST':
            case 'TODO_COMPLETE_BROADCAST':
            case 'TODO_UNCOMPLETE_BROADCAST':
                // 通知TODO管理器更新界面
                if (window.TodoManager) {
                    window.TodoManager.handleWebSocketBroadcast(type, data);
                }
                break;
                
            case 'NOTES_CREATE_BROADCAST':
            case 'NOTES_UPDATE_BROADCAST':
            case 'NOTES_DELETE_BROADCAST':
                // 通知Notes管理器更新界面
                if (window.NotesManager) {
                    window.NotesManager.handleWebSocketBroadcast(type, data);
                }
                break;
                
        }
    },

    // 处理Link相关通知消息
    handleLinkNotification(message) {
        const { type, data } = message;
        console.log('🔗 [WebSocket] 处理Link通知:', type, data);

        const handler = this._getLinkNotificationHandler(type);
        if (handler) {
            handler(data, type);
        } else {
            console.log('⚠️ [WebSocket] 未处理的Link通知类型:', type);
        }
    },

    // 获取Link通知处理器
    _getLinkNotificationHandler(type) {
        const handlers = {
            'LINK_REQUEST_RECEIVED': this._handleLinkRequestReceived.bind(this),
            'LINK_INVITATION_ACCEPTED': this._handleLinkStatusChange.bind(this),
            'LINK_INVITATION_REJECTED': this._handleLinkStatusChange.bind(this),
            'LINK_ACCEPTED': this._handleLinkStatusChange.bind(this),
            'LINK_CANCELLED': this._handleLinkStatusChange.bind(this),
            'LINK_ESTABLISHED': this._handleLinkEstablished.bind(this),
            'DATA_SYNC_UPDATE': this._handleDataSyncUpdate.bind(this)
        };
        
        return handlers[type];
    },

    // 处理Link请求接收
    _handleLinkRequestReceived(data) {
        console.log('📨 [WebSocket] 收到关联邀请:', data);
        this._callAppMethod('showLinkInvitationDialog', data);
    },

    // 处理Link状态变更
    _handleLinkStatusChange(data, type) {
        console.log(`🔗 [WebSocket] Link状态变更:`, type || 'unknown', data);
        this._callAppMethod('handleLinkStatusChange', type, data);
    },

    // 处理Link建立成功
    _handleLinkEstablished(data) {
        console.log(`🔗 [WebSocket] Link建立成功:`, data);
        console.log('🔄 [WebSocket] 触发应用数据刷新...');
        this._callAppMethod('refreshApplicationAfterLink');
    },

    // 处理数据同步更新
    _handleDataSyncUpdate(data) {
        console.log('🔄 [WebSocket] 数据同步更新:', data);
        this._callAppMethod('handleDataSyncUpdate', data);
    },

    // 安全调用App方法
    _callAppMethod(methodName, ...args) {
        if (window.App && typeof window.App[methodName] === 'function') {
            window.App[methodName](...args);
        } else {
            console.error(`❌ App.${methodName} 方法不存在`);
        }
    },

    // 处理数据同步更新消息
    handleDataSyncUpdate(message) {
        const { data } = message;
        console.log('🔄 [WebSocket] 处理数据同步更新:', data);
        
        if (window.App && window.App.handleDataSyncUpdate) {
            window.App.handleDataSyncUpdate(data);
        } else {
            console.error('❌ App.handleDataSyncUpdate 方法不存在');
        }
    },

    // 心跳检测
    startHeartbeat() {
        this.HEARTBEAT_INTERVAL = setInterval(() => {
            if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                // 获取当前用户信息
                const deviceId = window.DeviceManager ? window.DeviceManager.deviceId : null;
                const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;
                
                this.ws.send(JSON.stringify({
                    type: 'PING',
                    timestamp: Date.now(),
                    deviceId: deviceId,
                    userId: currentUser ? currentUser.id : null,
                    appUserId: appUserId
                }));
            }
        }, 30000); // 30秒发送一次心跳
    },

    stopHeartbeat() {
        if (this.HEARTBEAT_INTERVAL) {
            clearInterval(this.HEARTBEAT_INTERVAL);
            this.HEARTBEAT_INTERVAL = null;
        }
    },

    // 计划重连
    scheduleReconnect() {
        this.reconnectAttempts++;
        const delay = this.RECONNECT_INTERVAL * this.reconnectAttempts;
        
        console.log(`🔄 计划在 ${delay}ms 后重连 (尝试 ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS})`);
        
        setTimeout(() => {
            console.log(`🔄 开始第 ${this.reconnectAttempts} 次重连尝试`);
            this.init().catch(error => {
                console.error('❌ 重连失败:', error);
                if (this.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
                    this.scheduleReconnect();
                } else {
                    console.error('❌ 达到最大重连次数，放弃重连');
                    // 降级到HTTP模式
                    this.fallbackToHTTP();
                }
            });
        }, delay);
    },

    // 降级到HTTP模式
    fallbackToHTTP() {
        console.log('📡 WebSocket不可用，降级到HTTP模式');
        // 通知各管理器切换到HTTP模式
        if (window.TodoManager) {
            window.TodoManager.fallbackToHTTP();
        }
        if (window.NotesManager) {
            window.NotesManager.fallbackToHTTP();
        }
    },

    // 关闭连接
    close() {
        this.stopHeartbeat();
        this.messageHandlers.clear();
        
        if (this.ws) {
            this.ws.close(1000, '正常关闭');
            this.ws = null;
        }
        
        this.isConnected = false;
        console.log('👋 WebSocket连接已关闭');
    },

    // TODO相关API方法
    todos: {
        async getTodayTodos(userId) {
            return await WebSocketClient.sendMessage('TODO_GET_TODAY', { userId });
        },

        async getTodosForDate(userId, date) {
            return await WebSocketClient.sendMessage('TODO_GET_BY_DATE', { userId, date });
        },

        async create(todoData) {
            return await WebSocketClient.sendMessage('TODO_CREATE', todoData);
        },

        async update(todoId, updateData) {
            return await WebSocketClient.sendMessage('TODO_UPDATE', { todoId, updateData });
        },

        async delete(todoId, deletionType, deletionDate) {
            return await WebSocketClient.sendMessage('TODO_DELETE', { 
                todoId, deletionType, deletionDate 
            });
        },

        async complete(todoId, userId, date) {
            return await WebSocketClient.sendMessage('TODO_COMPLETE', { 
                todoId, userId, date 
            });
        },

        async uncomplete(todoId, date, userId) {
            return await WebSocketClient.sendMessage('TODO_UNCOMPLETE', { 
                todoId, date, userId 
            });
        }
    },

    // Notes相关API方法
    notes: {
        async getByUserId(userId) {
            return await WebSocketClient.sendMessage('NOTES_GET_BY_USER', { userId });
        },

        async create(noteData) {
            return await WebSocketClient.sendMessage('NOTES_CREATE', noteData);
        },

        async update(noteId, updateData) {
            return await WebSocketClient.sendMessage('NOTES_UPDATE', { noteId, updateData });
        },

        async delete(noteId) {
            return await WebSocketClient.sendMessage('NOTES_DELETE', { noteId });
        },

        async generateAISuggestions(noteId, userLocation, weatherData) {
            return await WebSocketClient.sendMessage('NOTES_AI_SUGGESTIONS', { 
                noteId, userLocation, weatherData 
            });
        }
    },

    // Link功能相关API方法
    links: {
        async checkLinkStatus(appUser) {
            return await WebSocketClient.sendMessage('LINK_CHECK_STATUS', { appUser });
        },

        async sendInvitation(toUser, supervisedUserId, message) {
            return await WebSocketClient.sendMessage('LINK_SEND_INVITATION', { 
                toUser, supervisedUserId, message 
            });
        },

        async acceptInvitation(requestId) {
            return await WebSocketClient.sendMessage('LINK_ACCEPT_INVITATION', { requestId });
        },

        async rejectInvitation(requestId) {
            return await WebSocketClient.sendMessage('LINK_REJECT_INVITATION', { requestId });
        },

        async cancelLink(linkId) {
            return await WebSocketClient.sendMessage('LINK_CANCEL', { linkId });
        }
    },

    // 发送注册消息
    sendRegistrationMessage() {
        const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
        const userId = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;

        console.log('🔍 WebSocket注册信息调试:', { deviceId, userId, appUserId });
        console.log('🔍 localStorage状态:', {
            'wenting_current_app_user': localStorage.getItem('wenting_current_app_user'),
            'wenting_current_user': localStorage.getItem('wenting_current_user')
        });

        if (!deviceId) {
            console.error('❌ 缺少deviceId，无法注册WebSocket');
            console.log('💡 请检查 window.DeviceManager.getCurrentDeviceId()');
            // 🔥 新增：尝试生成临时deviceId
            const tempDeviceId = 'temp_' + Math.random().toString(36).substr(2, 9);
            console.log('🔄 生成临时deviceId:', tempDeviceId);
            return;
        }
        
        if (!appUserId) {
            console.error('❌ 缺少appUserId，无法注册WebSocket');
            console.log('💡 当前localStorage状态:', {
                'wenting_current_app_user': localStorage.getItem('wenting_current_app_user'),
                'wenting_current_user': localStorage.getItem('wenting_current_user')
            });
            return;
        }

        const registrationMessage = {
            type: 'USER_REGISTRATION',
            deviceId,
            userId,
            appUserId,
            timestamp: Date.now()
        };

        try {
            this.ws.send(JSON.stringify(registrationMessage));
            console.log('📝 用户注册消息已发送:', registrationMessage);
            
            // 🔥 新增：设置注册确认超时
            if (this.registrationTimeout) {
                clearTimeout(this.registrationTimeout);
            }
            this.registrationTimeout = setTimeout(() => {
                console.warn('⚠️ WebSocket注册确认超时，尝试重新注册');
                this.sendRegistrationMessage();
            }, this.REGISTRATION_TIMEOUT);
            
        } catch (error) {
            console.error('❌ 发送注册消息失败:', error);
            // 重试机制
            setTimeout(() => {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    console.log('🔄 重试发送WebSocket注册消息...');
                    this.sendRegistrationMessage();
                }
            }, 1000);
        }
    },

    // 处理心跳响应并检查数据变化
    handleHeartbeatResponse(message) {
        try {
            // 如果消息包含数据状态信息
            if (message.dataStatus) {
                const newDataStatus = message.dataStatus;
                let reloadTypes = [];
                
                // 检查TODO数据是否有变化
                if (newDataStatus.lastTodoUpdate !== this.lastDataStatus.lastTodoUpdate) {
                    console.log('📅 检测到TODO数据变化，准备重新加载');
                    reloadTypes.push('todos');
                }
                
                // 检查Notes数据是否有变化
                if (newDataStatus.lastNoteUpdate !== this.lastDataStatus.lastNoteUpdate) {
                    console.log('📝 检测到Notes数据变化，准备重新加载');
                    reloadTypes.push('notes');
                }
                
                // 检查关联状态是否有变化
                if (newDataStatus.hasLinkedData !== this.lastDataStatus.hasLinkedData) {
                    console.log('🔗 检测到Link状态变化，准备重新加载所有数据');
                    reloadTypes = ['all']; // Link状态变化可能影响所有数据
                }
                
                // 更新缓存的数据状态
                this.lastDataStatus = {
                    lastTodoUpdate: newDataStatus.lastTodoUpdate,
                    lastNoteUpdate: newDataStatus.lastNoteUpdate,
                    hasLinkedData: newDataStatus.hasLinkedData
                };
                
                // 如果检测到数据变化，根据变化类型精准重新加载
                if (reloadTypes.length > 0) {
                    console.log('🔄 数据变化检测：触发数据重新加载', reloadTypes);
                    for (const dataType of reloadTypes) {
                        this.reloadApplicationData(dataType);
                    }
                }
            }
        } catch (error) {
            console.error('❌ 处理心跳响应失败:', error);
        }
    },
    
    // 重新加载应用数据
    reloadApplicationData(dataType = 'all', forceReload = false) {
        try {
            console.log('🔄 [RELOAD] 重新加载应用数据:', { dataType, forceReload });
            
            if (this._shouldReloadTodos(dataType)) {
                this._reloadTodoData(forceReload);
            }
            
            if (this._shouldReloadNotes(dataType)) {
                this._reloadNotesData(forceReload);
            }
            
            console.log('✅ [RELOAD] 应用数据重新加载完成');
        } catch (error) {
            console.error('❌ [RELOAD] 重新加载应用数据失败:', error);
        }
    },

    // 检查是否需要重新加载TODO数据
    _shouldReloadTodos(dataType) {
        return dataType === 'all' || dataType === 'todos';
    },

    // 检查是否需要重新加载Notes数据
    _shouldReloadNotes(dataType) {
        return dataType === 'all' || dataType === 'notes';
    },

    // 重新加载TODO数据
    _reloadTodoData(forceReload) {
        if (!window.TodoManager) {
            console.log('⚠️ [RELOAD] TodoManager不可用');
            return;
        }

        console.log('🧹 [RELOAD] 清除TODO缓存');
        window.TodoManager.clearAllRelatedCache();
        
        const reloadContext = this._getTodoReloadContext(forceReload);
        console.log('📅 [RELOAD] 重新加载TODO数据:', reloadContext);
        
        if (reloadContext.currentUser) {
            this._executeTodoReload(reloadContext);
        } else {
            console.log('⚠️ [RELOAD] 没有当前用户，跳过TODO数据加载');
        }
    },

    // 获取TODO重新加载上下文
    _getTodoReloadContext(forceReload) {
        const currentDate = window.DateManager ? window.DateManager.selectedDate : new Date();
        const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : 'unknown';
        
        return {
            currentDate: currentDate.toISOString().split('T')[0],
            currentUser,
            currentModule,
            forceReload
        };
    },

    // 执行TODO重新加载
    _executeTodoReload(reloadContext) {
        window.TodoManager.loadTodosForDate(
            new Date(reloadContext.currentDate), 
            reloadContext.currentUser, 
            false
        ).then(() => {
            console.log('✅ [RELOAD] TODO数据重新加载完成');
            this._renderTodoIfNeeded(reloadContext);
        }).catch(error => {
            console.error('❌ [RELOAD] TODO数据重新加载失败:', error);
        });
    },

    // 如需要则渲染TODO界面
    _renderTodoIfNeeded(reloadContext) {
        if (reloadContext.currentModule === 'todo') {
            console.log('🎨 [RELOAD] 重新渲染TODO界面');
            window.TodoManager.renderTodoPanel(reloadContext.currentUser);
        }
    },

    // 重新加载Notes数据
    _reloadNotesData(forceReload) {
        if (!this._isNotesManagerAvailable()) {
            return;
        }

        console.log('🔄 [RELOAD] 重新加载Notes数据');
        
        const notesContext = this._getNotesReloadContext(forceReload);
        console.log('📝 [RELOAD] Notes重新加载信息:', notesContext);
        
        const shouldAutoRender = notesContext.currentModule === 'notes';
        window.NotesManager.loadNotesFromAPI(shouldAutoRender, notesContext.currentUser);
        
        if (!shouldAutoRender) {
            console.log('⏸️ [RELOAD] 当前不在Notes页面，只进行后台数据同步');
        }
    },

    // 检查NotesManager是否可用
    _isNotesManagerAvailable() {
        if (window.NotesManager && typeof window.NotesManager.loadNotesFromAPI === 'function') {
            return true;
        } else if (window.NotesManager) {
            console.log('⚠️ [RELOAD] NotesManager存在但loadNotesFromAPI方法不可用');
        }
        return false;
    },

    // 获取Notes重新加载上下文
    _getNotesReloadContext(forceReload) {
        const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : 'unknown';
        const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
        
        return {
            currentModule,
            currentUser,
            forceReload
        };
    },
    
    // 显示同步通知
    showSyncNotification(message, type = 'info') {
        try {
            // 尝试使用TodoManager的通知方法
            if (window.TodoManager && typeof window.TodoManager.showSyncStatusToast === 'function') {
                window.TodoManager.showSyncStatusToast(message, type);
                return;
            }
            
            // 如果没有专门的通知方法，使用简单的控制台输出
            console.log(`🔔 同步通知: ${message}`);
            
            // 可以在这里添加其他通知方式，比如显示临时消息等
        } catch (error) {
            console.error('❌ 显示同步通知失败:', error);
        }
    },

    // 获取连接状态
    getConnectionStatus() {
        return {
            isConnected: this.isConnected,
            reconnectAttempts: this.reconnectAttempts,
            wsState: this.ws ? this.ws.readyState : null,
            lastDataStatus: this.lastDataStatus
        };
    }
};

// 页面卸载时关闭连接
window.addEventListener('beforeunload', () => {
    WebSocketClient.close();
});

// 导出到全局
window.WebSocketClient = WebSocketClient;


// 全局用户状态管理器
const GlobalUserState = {
    currentUserId: null,
    currentModule: 'todo', // 'todo' 或 'notes'
    listeners: [],

    // 初始化
    init() {
        console.log('🌐 初始化全局用户状态管理器');
        
        // 只恢复模块状态，用户状态由TodoManager的setDefaultUser决定
        const savedModule = localStorage.getItem('wenting_current_module');
        
        if (savedModule) {
            this.currentModule = savedModule;
        }
        
        // 不从localStorage恢复用户ID，让TodoManager决定默认用户
        console.log('📍 初始化状态:', {
            currentUserId: this.currentUserId,
            currentModule: this.currentModule
        });
        console.log('🔄 用户ID将由TodoManager的setDefaultUser方法设置');
    },

    // 设置当前用户
    setCurrentUser(userId) {
        console.log('👤 切换当前用户:', this.currentUserId, '->', userId);
        
        if (this.currentUserId !== userId) {
            this.currentUserId = userId;
            
            // 保存到localStorage
            localStorage.setItem('wenting_current_user_id', userId.toString());
            
            // 通知所有监听器
            this.notifyListeners('userChanged', { userId: userId });
        }
        
        // 无论是否相同，都更新UI（确保样式正确）
        console.log('🎨 强制更新用户选择器UI...');
        this.updateUserSelectorUI();
        
        // 触发用户选择事件，传递完整的用户对象
        if (window.UserManager && window.UserManager.users) {
            const selectedUser = window.UserManager.users.find(user => user.id === userId);
            console.log('🔍 查找用户对象，用户ID:', userId, '找到的用户:', selectedUser);
            
            if (selectedUser) {
                console.log('📢 准备触发userSelected事件');
                const userSelectedEvent = new CustomEvent('userSelected', {
                    detail: selectedUser
                });
                document.dispatchEvent(userSelectedEvent);
                console.log('✅ userSelected事件已触发，用户:', selectedUser.username);
            } else {
                console.warn('⚠️ 未找到用户ID为', userId, '的用户对象');
            }
        } else {
            console.warn('⚠️ UserManager或用户列表未就绪');
        }
    },

    // 设置当前模块
    setCurrentModule(module) {
        console.log('📋 切换当前模块:', module);
        
        if (this.currentModule !== module) {
            this.currentModule = module;
            
            // 保存到localStorage
            localStorage.setItem('wenting_current_module', module);
            
            // 通知所有监听器
            this.notifyListeners('moduleChanged', { module: module });
        }
    },

    // 获取当前用户ID
    getCurrentUser() {
        // 如果当前没有用户ID，尝试从localStorage恢复
        if (this.currentUserId === null) {
            const savedUserId = localStorage.getItem('wenting_current_user_id');
            if (savedUserId && !isNaN(parseInt(savedUserId))) {
                this.currentUserId = parseInt(savedUserId);
                console.log('💾 从localStorage恢复用户ID:', this.currentUserId);
            }
        }
        return this.currentUserId;
    },

    // 获取当前App用户ID
    getAppUserId() {
        return localStorage.getItem('wenting_current_app_user');
    },

    // 获取当前模块
    getCurrentModule() {
        return this.currentModule;
    },

    // 添加监听器
    addListener(callback) {
        this.listeners.push(callback);
    },

    // 移除监听器
    removeListener(callback) {
        const index = this.listeners.indexOf(callback);
        if (index > -1) {
            this.listeners.splice(index, 1);
        }
    },

    // 通知所有监听器
    notifyListeners(type, data) {
        console.log('📢 通知监听器:', type, data);
        this.listeners.forEach(callback => {
            try {
                callback(type, data);
            } catch (error) {
                console.error('❌ 监听器回调错误:', error);
            }
        });
    },

    // 更新用户选择器UI
    updateUserSelectorUI() {
        console.log('🎨 更新用户选择器UI，当前用户:', this.currentUserId);
        
        // 直接更新样式，不重新渲染整个HTML（避免丢失状态）
        console.log('📝 直接更新用户标签样式');
        const userTabs = document.querySelectorAll('.sidebar-tab');
        console.log('🔍 找到', userTabs.length, '个用户标签');
        
        userTabs.forEach(tab => {
            const tabUserId = parseInt(tab.dataset.tab);
            console.log('🏷️ 处理标签，用户ID:', tabUserId, '当前用户:', this.currentUserId);
            
            if (tabUserId === this.currentUserId) {
                console.log('✅ 设置为选中状态:', tabUserId);
                tab.classList.add('active');
                
                // 更新CSS变量用于颜色条
                if (window.UserManager) {
                    const user = UserManager.getUser(tabUserId);
                    if (user) {
                        tab.style.setProperty('--user-color', user.avatar_color || '#1d9bf0');
                        console.log('🎨 应用选中样式，颜色条:', user.avatar_color);
                    }
                }
            } else {
                console.log('❌ 设置为未选中状态:', tabUserId);
                tab.classList.remove('active');
                
                // 保持颜色条颜色不变
                if (window.UserManager) {
                    const user = UserManager.getUser(tabUserId);
                    if (user) {
                        tab.style.setProperty('--user-color', user.avatar_color || '#1d9bf0');
                    }
                }
            }
        });
    },

    // 绑定用户选择器事件
    bindUserSelectorEvents() {
        console.log('🔗 开始绑定用户选择器事件...');
        
        // 使用事件委托，避免重复绑定问题
        const sidebar = document.querySelector('.left-sidebar');
        if (sidebar) {
            // 移除已存在的事件监听器
            sidebar.removeEventListener('click', this._sidebarClickHandler);
            
            // 绑定事件委托
            this._sidebarClickHandler = (e) => {
                const tab = e.target.closest('.sidebar-tab');
                if (tab) {
                    e.preventDefault();
                    e.stopPropagation();
                    const userId = parseInt(tab.dataset.tab);
                    if (userId && !isNaN(userId)) {
                        console.log('🖱️ 用户按钮点击，切换到用户:', userId);
                        this.setCurrentUser(userId);
                    }
                }
            };
            
            sidebar.addEventListener('click', this._sidebarClickHandler);
            console.log('🔗 用户选择器事件委托绑定完成');
        }
    }
};

// 导出到全局
window.GlobalUserState = GlobalUserState;


// 日期管理模块
const DateManager = {
    selectedDate: new Date(),
    calendarDate: new Date(),
    // 添加优化标记
    isChangingDate: false,
    currentDateElements: null,
    
    // 进度条控制
    showLoadingProgress() {
        const progressEl = document.getElementById('loadingProgress');
        if (progressEl) {
            progressEl.style.display = 'block';
        }
    },
    
    hideLoadingProgress() {
        const progressEl = document.getElementById('loadingProgress');
        if (progressEl) {
            progressEl.style.display = 'none';
        }
    },

    init() {
        this.updateCurrentDate();
        this.updateSelectedDate();
        this.bindEvents();
        // 预缓存DOM元素
        this.currentDateElements = Utils.$$('.current-date');
    },

    // 更新当前日期显示
    updateCurrentDate() {
        const now = new Date();
        const formatted = Utils.formatDate(now);
        
        // 更新weather栏的日期显示
        const currentDateEl = Utils.$('#currentDate');
        const weekdayEl = Utils.$('.weather-date-weekday');
        
        if (currentDateEl) {
            currentDateEl.textContent = formatted.full;
        }
        if (weekdayEl) {
            weekdayEl.textContent = formatted.weekday;
        }
    },

    // 更新选择的日期显示（优化版）
    updateSelectedDate() {
        const formatted = Utils.formatDate(this.selectedDate);
        
        // 使用缓存的DOM元素，避免重复查询
        if (!this.currentDateElements) {
            this.currentDateElements = Utils.$$('.current-date');
        }
        
        if (this.currentDateElements && this.currentDateElements.length > 0) {
            this.currentDateElements.forEach(el => {
                if (el && typeof el.textContent !== 'undefined') {
                    el.textContent = formatted.full;
                }
            });
        }
        
        // 如果不是通过changeDate触发的，才更新TODO显示
        // 避免双重渲染
        if (!this.isChangingDate) {
            this.filterTodosByDate();
        }
    },

    // 根据日期过滤todo项目
    filterTodosByDate() {
        // 通知TodoManager重新渲染当前用户的TODO面板
        // 但是要确保用户数据已经加载完成，避免过早渲染
        if (typeof TodoManager !== 'undefined' && 
            TodoManager.currentUser && 
            typeof UserManager !== 'undefined' && 
            UserManager.users && 
            UserManager.users.length > 0) {
            
            console.log('📅 DateManager触发TODO面板重新渲染，用户:', TodoManager.currentUser);
            TodoManager.renderTodoPanel(TodoManager.currentUser);
        } else {
            console.log('📅 DateManager跳过TODO面板渲染，条件不满足:');
            console.log('  - TodoManager存在:', typeof TodoManager !== 'undefined');
            console.log('  - currentUser存在:', !!TodoManager?.currentUser);
            console.log('  - UserManager存在:', typeof UserManager !== 'undefined');
            console.log('  - 用户数据已加载:', UserManager?.users?.length > 0);
        }
    },

    // 日期切换（优化版）
    changeDate(direction) {
        // 设置标记，避免双重渲染
        this.isChangingDate = true;
        
        this.selectedDate.setDate(this.selectedDate.getDate() + direction);
        
        // 立即更新日期显示（不触发TODO渲染）
        this.updateSelectedDate();
        
        // 检查TodoManager的缓存
        const dateStr = this.selectedDate.toISOString().split('T')[0];
        const currentUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
        const cacheKey = `${currentUser}_${dateStr}`;
        
        let hasCache = false;
        if (window.TodoManager && currentUser && window.TodoManager.todoCache.has(cacheKey)) {
            // 使用TodoManager的缓存数据快速渲染
            const cachedData = window.TodoManager.todoCache.get(cacheKey);
            window.TodoManager.todos[currentUser] = [...cachedData]; // 创建副本
            window.TodoManager.renderTodoPanel(currentUser);
            console.log('📅 DateManager使用缓存快速渲染，用户:', currentUser);
            hasCache = true;
        }
        
        // 如果没有缓存，显示加载进度条
        if (!hasCache) {
            this.showLoadingProgress();
        }
        
        // 异步加载最新数据（不阻塞UI）
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            // 传递正确的用户ID，确保加载正确用户的数据
            const targetUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
            // 如果已用缓存渲染，则静默刷新；否则需要渲染
            const silent = hasCache;
            window.TodoManager.loadTodosForDate(this.selectedDate, targetUser, silent).then(() => {
                // 数据加载完成后隐藏进度条
                this.hideLoadingProgress();
            }).catch(() => {
                // 即使出错也要隐藏进度条
                this.hideLoadingProgress();
            });
        }
        
        // 重置标记
        this.isChangingDate = false;
    },

    // 返回今天
    goToToday() {
        console.log('goToToday被调用');
        this.selectedDate = new Date();
        console.log('重置为今天:', this.selectedDate);
        this.updateSelectedDate();
        
        // 检查缓存决定是否显示进度条
        const dateStr = this.selectedDate.toISOString().split('T')[0];
        const currentUser = window.GlobalUserState?.getCurrentUser() || window.TodoManager?.currentUser;
        const cacheKey = `${currentUser}_${dateStr}`;
        
        let hasCache = window.TodoManager && currentUser && window.TodoManager.todoCache.has(cacheKey);
        
        // 如果没有缓存，显示加载进度条
        if (!hasCache) {
            this.showLoadingProgress();
        }
        
        // 通知TodoManager重新加载数据
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            window.TodoManager.loadTodosForDate(this.selectedDate).then(() => {
                this.hideLoadingProgress();
            }).catch(() => {
                this.hideLoadingProgress();
            });
        }
    },

    // 切换日历显示
    toggleDatePicker() {
        console.log('toggleDatePicker 被调用');
        const picker = Utils.$('#datePicker');
        console.log('找到日历元素:', picker);
        const isVisible = picker && picker.classList.contains('show');
        console.log('日历当前可见状态:', isVisible);
        
        if (isVisible) {
            console.log('隐藏日历');
            picker.classList.remove('show');
        } else {
            console.log('显示日历');
            this.calendarDate = new Date(this.selectedDate);
            this.updateCalendar();
            if (picker) {
                picker.classList.add('show');
            }
        }
    },

    // 更改日历月份
    changeMonth(direction) {
        this.calendarDate.setMonth(this.calendarDate.getMonth() + direction);
        this.updateCalendar();
    },

    // 更新日历显示
    updateCalendar() {
        const months = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
        const year = this.calendarDate.getFullYear();
        const month = this.calendarDate.getMonth();
        
        // 更新月份标题
        const monthEl = Utils.$('#calendarMonth');
        if (monthEl) {
            monthEl.textContent = `${year}年${months[month]}`;
        }
        
        // 生成日历日期
        const firstDay = new Date(year, month, 1);
        const startDate = new Date(firstDay);
        startDate.setDate(startDate.getDate() - firstDay.getDay());
        
        const calendarDays = Utils.$('#calendarDays');
        if (calendarDays) {
            calendarDays.innerHTML = '';
            
            for (let i = 0; i < 42; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                const dayButton = document.createElement('button');
                dayButton.className = 'calendar-day';
                dayButton.textContent = date.getDate();
                
                // 检查是否是当前月份
                if (date.getMonth() !== month) {
                    dayButton.classList.add('other-month');
                }
                
                // 检查是否是选中的日期
                if (date.toDateString() === this.selectedDate.toDateString()) {
                    dayButton.classList.add('selected');
                }
                
                dayButton.onclick = () => this.selectDate(date);
                calendarDays.appendChild(dayButton);
            }
        }
    },

    // 选择日期
    selectDate(date) {
        this.selectedDate = new Date(date);
        this.updateSelectedDate();
        this.toggleDatePicker();
        
        // 通知TodoManager重新加载数据
        if (window.TodoManager && typeof window.TodoManager.loadTodosForDate === 'function') {
            window.TodoManager.selectedDate = this.selectedDate;
            window.TodoManager.loadTodosForDate(this.selectedDate);
        }
    },

    // 绑定事件
    bindEvents() {
        // 点击外部关闭日历
        document.addEventListener('click', (event) => {
            const picker = Utils.$('#datePicker');
            const pickerBtn = event.target.closest('.date-picker-btn');
            
            if (picker && !picker.contains(event.target) && !pickerBtn) {
                picker.classList.remove('show');
            }
        });

        // 使用事件委托，避免重复绑定
        this.bindEventsWithDelegation();
    },

    // 使用事件委托绑定事件
    bindEventsWithDelegation() {
        // 使用事件委托绑定今天按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('today-btn')) {
                e.preventDefault();
                e.stopPropagation();
                console.log('今天按钮被点击');
                this.goToToday();
            }
        });

        // 使用事件委托绑定日期导航按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('date-nav-btn')) {
                e.preventDefault();
                e.stopPropagation();
                console.log('日期导航按钮被点击:', e.target.textContent);
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeDate(direction);
            }
        });

        // 使用事件委托绑定日历切换按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('date-picker-btn')) {
                console.log('日历按钮被点击！');
                e.preventDefault();
                e.stopPropagation();
                this.toggleDatePicker();
            }
        });

        // 使用事件委托绑定月份导航按钮
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('calendar-nav')) {
                e.preventDefault();
                e.stopPropagation();
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeMonth(direction);
            }
        });
    },

    // 绑定日期导航事件
    bindDateNavigation() {
        // 绑定日期导航按钮
        const dateNavBtns = Utils.$$('.date-nav-btn');
        console.log('找到日期导航按钮:', dateNavBtns.length);
        dateNavBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                console.log('日期导航按钮被点击:', e.target.textContent);
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeDate(direction);
            });
        });

        // 绑定日历切换按钮
        const pickerBtns = Utils.$$('.date-picker-btn');
        console.log('找到日历切换按钮:', pickerBtns.length);
        pickerBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                this.toggleDatePicker();
            });
        });

        // 绑定月份导航
        const calendarNavBtns = Utils.$$('.calendar-nav');
        console.log('找到月份导航按钮:', calendarNavBtns.length);
        calendarNavBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const direction = e.target.textContent === '‹' ? -1 : 1;
                this.changeMonth(direction);
            });
        });
    }
};


// 将DateManager暴露到全局
window.DateManager = DateManager;


// TODO管理模块 - 完全重写版本
const TodoManager = {
    currentUser: 1,
    todos: {},
    selectedDate: new Date(),
    isOnline: false,
    // 添加缓存机制
    todoCache: new Map(),
    lastLoadedDate: null,
    // 重试配置
    RETRY_DELAY_BASE: 1000, // 基础重试延迟1秒
    RETRY_DELAY_MULTIPLIER: 2000, // 整体重试延迟2秒

    // 初始化
    async init() {
        console.log('🔄 初始化TODO管理器...');
        
        // 检查后端连接 - 必须联网才能使用
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            this.showOfflineError();
            return;
        }
        
        // 等待用户管理器初始化完成
        await this.waitForUserManager();
        
        // 加载TODO数据
        await this.loadTodosFromAPI();
        
        // 设置默认用户
        this.setDefaultUser();
        
        // 监听全局用户状态变化，但不设置模块
        if (window.GlobalUserState) {
            GlobalUserState.addListener(this.handleGlobalStateChange.bind(this));
        }
        
        // 不在这里渲染界面，等待应用界面显示后再渲染
        // 渲染将在app.js的setTimeout中进行
        
        this.bindEvents();
        
        console.log('✅ TODO管理器初始化完成');
    },

    // 等待用户管理器初始化完成
    async waitForUserManager() {
        // 设置最大等待时间为5秒，避免新用户无限等待
        const MAX_WAIT_TIME = 5000; // 5秒
        const startTime = Date.now();
        
        if (UserManager.users.length === 0) {
            console.log('⏳ 等待用户数据加载，新用户最多等待5秒...');
            await new Promise(resolve => {
                const checkUsers = () => {
                    const elapsedTime = Date.now() - startTime;
                    
                    if (UserManager.users.length > 0) {
                        console.log('✅ 用户数据已加载');
                        resolve();
                    } else if (elapsedTime >= MAX_WAIT_TIME) {
                        console.log('⏰ 等待超时，可能是新用户没有被管理用户，继续初始化...');
                        resolve();
                    } else {
                        setTimeout(checkUsers, 100);
                    }
                };
                checkUsers();
            });
        }
    },

    // 从API加载TODO数据
    async loadTodosFromAPI() {
        try {
            console.log('📥 从服务器加载TODO数据...');
            
            // 尝试使用WebSocket，失败则降级到HTTP
            let useWebSocket = true;
            try {
                // 确保WebSocket已连接
                if (!WebSocketClient.isConnected) {
                    await WebSocketClient.init();
                }
            } catch (error) {
                console.warn('⚠️ WebSocket连接失败，使用HTTP模式:', error.message);
                useWebSocket = false;
            }

            // 为每个用户加载TODO数据
            for (const user of UserManager.users) {
                try {
                    let response;
                    if (useWebSocket) {
                        response = await WebSocketClient.todos.getTodayTodos(user.id);
                        this.todos[user.id] = response.data.todos.map(todo => this.convertApiTodoToLocal(todo));
                    } else {
                        response = await ApiClient.todos.getTodayTodos(user.id);
                        if (response.success) {
                            this.todos[user.id] = response.data.map(todo => this.convertApiTodoToLocal(todo));
                        } else {
                            throw new Error(response.message);
                        }
                    }
                } catch (error) {
                    console.warn(`加载用户${user.id}的TODO失败:`, error.message);
                    this.todos[user.id] = [];
                }
            }
            
            console.log('✅ 从服务器加载TODO数据成功');
        } catch (error) {
            console.error('从服务器加载TODO数据失败:', error);
            throw error;
        }
    },

    // 设置默认用户
    setDefaultUser() {
        console.log('🔄 开始设置默认用户...');
        console.log('🔍 用户数据调试:');
        console.log('  - UserManager.users.length:', UserManager.users.length);
        console.log('  - UserManager.users:', UserManager.users);
        
        if (UserManager.users.length > 0) {
            // 检查是否有保存的用户选择
            let savedUserId = null;
            if (window.GlobalUserState) {
                savedUserId = GlobalUserState.getCurrentUser();
                console.log('💾 从全局状态获取保存的用户ID:', savedUserId);
            }
            
            // 按ID排序，选择ID最小的用户（最早添加的用户）
            const sortedUsers = [...UserManager.users].sort((a, b) => a.id - b.id);
            
            // 验证保存的用户ID是否仍然存在
            let defaultUser;
            if (savedUserId && sortedUsers.find(u => u.id == savedUserId)) {
                defaultUser = parseInt(savedUserId);
                console.log('🎯 使用保存的用户ID:', defaultUser);
            } else {
                defaultUser = sortedUsers[0].id;
                console.log('🎯 使用默认第一个用户:', defaultUser, '(用户名:', sortedUsers[0].username, ')');
            }
            
            console.log('📋 所有用户按ID排序:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));
            this.currentUser = defaultUser;
            
            // 直接同步全局状态，不触发事件（事件将在app.js中触发）
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = defaultUser;
                localStorage.setItem('wenting_current_user_id', defaultUser.toString());
                console.log('🔄 直接同步全局用户状态（不触发事件）');
                console.log('🔍 设置后的状态:');
                console.log('  - TodoManager.currentUser:', this.currentUser);
                console.log('  - GlobalUserState.currentUserId:', GlobalUserState.currentUserId);
            }
        } else {
            console.log('📝 没有用户，新注册用户情况，设置为空状态但继续初始化');
            this.currentUser = null;
            
            // 即使没有用户，也要设置全局状态，确保应用可以继续运行
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = null;
                console.log('🔄 设置全局状态为空用户状态');
            }
        }
    },

    // 处理全局状态变化
    handleGlobalStateChange(type, data) {
        console.log('📢 TODO管理器收到全局状态变化:', type, data);
        
        if (type === 'userChanged') {
            const newUserId = data.userId;
            console.log('🔄 处理用户切换事件:');
            console.log('  - 当前用户:', this.currentUser);
            console.log('  - 新用户:', newUserId);
            
            // 先更新currentUser，确保后续操作使用正确的用户ID
            const oldUser = this.currentUser;
            this.currentUser = newUserId;
            
            if (oldUser !== newUserId) {
                console.log(`🔄 用户从 ${oldUser} 切换到 ${newUserId}`);
                // 只有当前模块是todo时才渲染
                if (GlobalUserState.getCurrentModule() === 'todo') {
                    console.log('✅ 当前是TODO模块，渲染TODO内容');
                    
                    // 检查缓存决定是否显示进度条
                    const dateStr = (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
                    const cacheKey = `${newUserId}_${dateStr}`;
                    let hasCache = this.todoCache.has(cacheKey);
                    
                    // 如果没有缓存，显示加载进度条
                    if (!hasCache && window.DateManager) {
                        window.DateManager.showLoadingProgress();
                    }
                    
                    this.loadTodosForDate(DateManager.selectedDate || new Date(), newUserId).then(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }).catch(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    });
                } else {
                    console.log('⏸️ 当前不是TODO模块，跳过渲染');
                }
            } else {
                console.log('🔄 用户ID相同，但仍需重新渲染TODO面板（可能是初始化调用）');
                // 即使用户ID相同，也要重新渲染（比如初始化时）
                if (GlobalUserState.getCurrentModule() === 'todo') {
                    console.log('✅ 当前是TODO模块，渲染TODO内容');
                    
                    // 检查缓存决定是否显示进度条  
                    const dateStr = (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
                    const cacheKey = `${newUserId}_${dateStr}`;
                    let hasCache = this.todoCache.has(cacheKey);
                    
                    // 如果没有缓存，显示加载进度条
                    if (!hasCache && window.DateManager) {
                        window.DateManager.showLoadingProgress();
                    }
                    
                    this.loadTodosForDate(DateManager.selectedDate || new Date(), newUserId).then(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    }).catch(() => {
                        if (window.DateManager) window.DateManager.hideLoadingProgress();
                    });
                } else {
                    console.log('⏸️ 当前不是TODO模块，跳过渲染');
                }
            }
        }
    },

    // 显示离线错误
    showOfflineError() {
        const contentArea = document.getElementById('contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="offline-error">
                    <div class="error-icon">🌐</div>
                    <h2>需要网络连接</h2>
                    <p>此应用需要连接到服务器才能正常使用。</p>
                    <p>请检查您的网络连接和服务器状态。</p>
                    <button onclick="location.reload()" class="retry-btn">重试</button>
                </div>
            `;
        }
    },

    // 显示空用户状态
    showEmptyUserState() {
        const contentArea = document.getElementById('contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="empty-user-state">
                    <div class="empty-icon">👥</div>
                    <h2>欢迎使用雯婷</h2>
                    <p>还没有用户，请先添加一个用户开始使用。</p>
                    <button onclick="UserManager.addUser()" class="add-first-user-btn">添加第一个用户</button>
                </div>
            `;
        }
    },

    // 将API TODO格式转换为本地格式
    convertApiTodoToLocal(apiTodo) {
        console.log('📥 从服务器接收的TODO数据:', apiTodo);
        console.log('📋 重复周期数据调试:');
        console.log('  cycle_type:', apiTodo.cycle_type);
        console.log('  cycle_duration:', apiTodo.cycle_duration);
        console.log('  cycle_unit:', apiTodo.cycle_unit);
        
        const cycleText = this.getCycleText(apiTodo.cycle_type, apiTodo.cycle_duration, apiTodo.cycle_unit);
        console.log('  计算出的cycle文本:', cycleText);
        
        return {
            id: apiTodo.id,
            text: apiTodo.title,
            note: apiTodo.description || '',
            time: apiTodo.reminder_time === 'all_day' ? '当天' : apiTodo.reminder_time,
            period: this.getRepeatTypeText(apiTodo.repeat_type, apiTodo.repeat_interval),
            periodType: apiTodo.repeat_type,
            customInterval: apiTodo.repeat_interval > 1 ? apiTodo.repeat_interval : null,
            cycle: cycleText,
            cycleType: apiTodo.cycle_type || 'long_term',
            cycleDuration: apiTodo.cycle_duration || null,
            cycleUnit: apiTodo.cycle_unit || 'days',
            completed: apiTodo.is_completed_today || false,
            priority: apiTodo.priority || 'medium',
            createdDate: apiTodo.start_date || new Date().toISOString().split('T')[0]
        };
    },

    // 将本地TODO格式转换为API格式
    convertLocalTodoToApi(localTodo, userId) {
        return {
            user_id: userId,
            title: localTodo.text,
            description: localTodo.note || '',
            reminder_time: localTodo.time === '当天' ? 'all_day' : localTodo.time,
            priority: localTodo.priority || 'medium',
            repeat_type: localTodo.periodType || 'none',
            repeat_interval: localTodo.customInterval || 1,
            cycle_type: localTodo.cycleType || 'long_term',
            cycle_duration: localTodo.cycleDuration || null,
            cycle_unit: localTodo.cycleUnit || 'days',
            start_date: new Date().toISOString().split('T')[0]
        };
    },

    // 获取重复类型的显示文本
    getRepeatTypeText(repeatType, repeatInterval = 1) {
        switch (repeatType) {
            case 'none':
                return '一次性';
            case 'daily':
                return '每天';
            case 'every_other_day':
                return '隔天';
            case 'weekly':
                return '每周';
            case 'monthly':
                return '每月';
            case 'yearly':
                return '每年';
            case 'custom':
                return `每${repeatInterval}天`;
            default:
                return '一次性';
        }
    },

    // 获取重复周期的显示文本
    getCycleText(cycleType, cycleDuration, cycleUnit) {
        if (cycleType === 'long_term') {
            return '长期';
        } else if (cycleType === 'custom' && cycleDuration) {
            const unitText = {
                'days': '天',
                'weeks': '周',
                'months': '月'
            };
            return `${cycleDuration}${unitText[cycleUnit] || '天'}`;
        }
        return '长期';
    },


    // 渲染TODO面板
    renderTodoPanel(userId) {
        console.log('🎨 开始渲染TODO面板，用户ID:', userId);
        console.log('🔍 渲染调试信息:');
        
        const contentArea = document.getElementById('contentArea');
        console.log('  - contentArea存在:', !!contentArea);
        if (!contentArea) {
            console.error('❌ 找不到contentArea元素');
            return;
        }

        // 获取当前选中的日期
        const currentDate = DateManager.selectedDate || new Date();
        console.log('  - 当前日期:', currentDate);
        
        // 获取用户TODO并按时间排序
        const userTodos = this.todos[userId] || [];
        const user = UserManager.getUser(userId);
        console.log('  - 用户信息:', user);
        console.log('  - 用户TODO数量:', userTodos.length);
        console.log('  - 用户TODO详情:', userTodos);
        
        // 获取当前日期的格式化显示
        const currentDateFormatted = this.formatDate(currentDate);
        console.log('  - 格式化日期:', currentDateFormatted);
        
        const panelHtml = `
            <div class="content-panel" id="${userId}-todo-panel">
                <div class="date-controls">
                    <div class="date-center">
                        <div class="today-btn">今天</div>
                        <div class="date-nav-btn">‹</div>
                        <div class="current-date">${currentDateFormatted}</div>
                        <div class="date-nav-btn">›</div>
                    </div>
                    <div class="date-picker-btn">📅</div>
                    <div class="date-picker" id="datePicker">
                        <div class="calendar-header">
                            <button class="calendar-nav">‹</button>
                            <span id="calendarMonth">2025年8月</span>
                            <button class="calendar-nav">›</button>
                        </div>
                        <div class="calendar-grid">
                            <div class="calendar-weekday">日</div>
                            <div class="calendar-weekday">一</div>
                            <div class="calendar-weekday">二</div>
                            <div class="calendar-weekday">三</div>
                            <div class="calendar-weekday">四</div>
                            <div class="calendar-weekday">五</div>
                            <div class="calendar-weekday">六</div>
                        </div>
                        <div class="calendar-grid" id="calendarDays"></div>
                    </div>
                </div>
                <div class="todo-list-container">
                    ${userTodos.map(todo => this.renderTodoItem(todo, userId)).join('')}
                    <button class="new-todo-btn" onclick="TodoManager.showAddTodoForm(${userId})">+ 添加新TODO</button>
                </div>
            </div>
        `;

        console.log('📝 设置contentArea的innerHTML...');
        console.log('📏 panelHtml长度:', panelHtml.length);
        contentArea.innerHTML = panelHtml;
        console.log('✅ TODO面板HTML已设置到contentArea');
    },

    // 渲染单个TODO项
    renderTodoItem(todo, userId) {
        const checkedClass = todo.completed ? 'checked' : '';
        const completedClass = todo.completed ? 'completed' : '';
        const timeSpecificClass = todo.time !== '当天' ? 'specific' : '';
        
        // 根据优先级设置边框颜色
        let priorityClass = '';
        switch (todo.priority) {
            case 'high':
                priorityClass = 'priority-high';
                break;
            case 'medium':
                priorityClass = 'priority-medium';
                break;
            case 'low':
            default:
                priorityClass = 'priority-low';
                break;
        }
        
        // 检查是否有关联用户（同步状态）
        const syncStatus = this.getSyncStatus(userId);
        const syncIndicator = syncStatus.isLinked ? `
            <div class="sync-indicator ${syncStatus.status}" title="${syncStatus.tooltip}">
                <span class="sync-icon">${syncStatus.icon}</span>
            </div>
        ` : '';
        
        return `
            <div class="todo-item todo-card ${priorityClass} ${completedClass}">
                <div class="todo-checkbox ${checkedClass}" onclick="TodoManager.toggleTodo(this)" 
                     data-member="${userId}" data-id="${todo.id}"></div>
                <div class="todo-content" onclick="TodoManager.showEditTodoForm(${todo.id}, ${userId})">
                    <div class="todo-text ${completedClass}">
                        ${todo.text}
                        ${todo.note ? `<div class="todo-note">${todo.note}</div>` : ''}
                    </div>
                    <div class="todo-right">
                        <div class="todo-time ${timeSpecificClass}">${todo.time}</div>
                        <div class="todo-period">${todo.period}</div>
                        <div class="todo-cycle">${todo.cycle}</div>
                        ${syncIndicator}
                    </div>
                </div>
            </div>
        `;
    },

    // 获取同步状态
    getSyncStatus(userId) {
        // 检查用户是否有关联关系
        const user = UserManager.users.find(u => u.id === userId);
        if (!user) {
            return { isLinked: false };
        }
        
        // 检查是否已关联
        if (user.is_linked && user.supervised_app_user) {
            return {
                isLinked: true,
                status: 'synced',
                icon: '🔗',
                tooltip: `已与 ${user.supervised_app_user} 同步`
            };
        }
        
        // 检查是否有待处理的关联请求
        if (this.hasPendingLinkRequest && this.hasPendingLinkRequest(userId)) {
            return {
                isLinked: true,
                status: 'pending',
                icon: '⏳',
                tooltip: '关联请求处理中'
            };
        }
        
        return { isLinked: false };
    },

    // 检查是否有待处理的关联请求
    hasPendingLinkRequest() {
        // 这个方法可以通过全局状态或API调用来实现
        // 暂时返回false，后续可以集成
        return false;
    },

    // 显示同步状态提示
    showSyncStatusToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `sync-toast ${type}`;
        toast.innerHTML = `
            <span class="sync-toast-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
            <span class="sync-toast-message">${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // 显示动画
        setTimeout(() => toast.classList.add('show'), 100);
        
        // 3秒后移除
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    },

    // 切换TODO状态
    async toggleTodo(checkbox) {
        const toggleContext = this._prepareToggleContext(checkbox);
        if (!toggleContext) return;

        try {
            await this._syncToggleToServer(toggleContext);
            this._updateLocalTodoState(toggleContext);
            this._updateTodoUI(toggleContext);
            this._showSyncStatus(toggleContext);
        } catch (error) {
            this._handleToggleError(error, toggleContext);
        }
    },

    // 准备切换上下文
    _prepareToggleContext(checkbox) {
        const todoId = parseInt(checkbox.dataset.id);
        const userId = parseInt(checkbox.dataset.member);
        
        if (!todoId || !userId) return null;

        const todo = this.todos[userId]?.find(t => t.id === todoId);
        if (!todo) return null;

        const currentDate = DateManager.selectedDate || new Date();
        const dateStr = currentDate.toISOString().split('T')[0];

        return {
            todoId,
            userId,
            todo,
            wasCompleted: todo.completed,
            dateStr,
            checkbox
        };
    },

    // 同步切换到服务器
    async _syncToggleToServer(context) {
        const { todoId, userId, wasCompleted, dateStr } = context;
        
        if (WebSocketClient.isConnected) {
            await this._syncViaWebSocket(todoId, userId, dateStr, wasCompleted);
        } else {
            await this._syncViaHTTP(todoId, userId, dateStr, wasCompleted);
        }
    },

    // 通过WebSocket同步
    async _syncViaWebSocket(todoId, userId, dateStr, wasCompleted) {
        if (wasCompleted) {
            await WebSocketClient.todos.uncomplete(todoId, dateStr, userId);
        } else {
            await WebSocketClient.todos.complete(todoId, userId, dateStr);
        }
    },

    // 通过HTTP同步
    async _syncViaHTTP(todoId, userId, dateStr, wasCompleted) {
        if (wasCompleted) {
            await ApiClient.todos.uncomplete(todoId, dateStr, userId);
        } else {
            await ApiClient.todos.complete(todoId, userId, dateStr);
        }
    },

    // 更新本地TODO状态
    _updateLocalTodoState(context) {
        const { todo, userId, dateStr } = context;
        
        todo.completed = !todo.completed;
        
        const cacheKey = `${userId}_${dateStr}`;
        this.todoCache.delete(cacheKey);
        console.log('🧹 TODO状态切换：清除缓存', cacheKey);
    },

    // 更新TODO界面
    _updateTodoUI(context) {
        const { checkbox, todo } = context;
        const todoItem = checkbox.closest('.todo-item');
        const todoContent = checkbox.nextElementSibling;
        const todoText = todoContent?.querySelector('.todo-text');
        
        if (todo.completed) {
            this._markTodoCompleted(checkbox, todoText, todoItem);
        } else {
            this._markTodoIncomplete(checkbox, todoText, todoItem);
        }
    },

    // 标记TODO为已完成
    _markTodoCompleted(checkbox, todoText, todoItem) {
        checkbox.classList.add('checked');
        if (todoText) todoText.classList.add('completed');
        if (todoItem) todoItem.classList.add('completed');
    },

    // 标记TODO为未完成
    _markTodoIncomplete(checkbox, todoText, todoItem) {
        checkbox.classList.remove('checked');
        if (todoText) todoText.classList.remove('completed');
        if (todoItem) todoItem.classList.remove('completed');
    },

    // 显示同步状态
    _showSyncStatus(context) {
        const { userId, todo } = context;
        const syncStatus = this.getSyncStatus(userId);
        
        if (syncStatus.isLinked) {
            const action = todo.completed ? '完成' : '取消完成';
            this.showSyncStatusToast(`${action}状态已同步`, 'success');
        }
    },

    // 处理切换错误
    _handleToggleError(error, context) {
        console.error('切换TODO状态失败:', error);
        context.todo.completed = context.wasCompleted;
        this.showMessage('操作失败: ' + error.message, 'error');
    },

    // 显示添加TODO表单
    showAddTodoForm(userId) {
        const user = UserManager.getUser(userId);
        if (!user) return;
        
        const formHtml = `
            <div class="modal-overlay" id="addTodoModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>为 ${user.display_name || user.username} 添加新TODO</h3>
                        <button class="modal-close" onclick="TodoManager.closeAddTodoForm()">×</button>
                    </div>
                    <form class="todo-form" onsubmit="TodoManager.handleAddTodo(event, ${userId})">
                        <div class="form-group">
                            <label for="todo_title">标题 *</label>
                            <input type="text" id="todo_title" name="title" required maxlength="200" placeholder="例如：吃鱼肝油">
                        </div>
                        <div class="form-group">
                            <label for="todo_start_date">开始日期</label>
                            <input type="date" id="todo_start_date" name="start_date" value="${(DateManager.selectedDate || new Date()).toISOString().split('T')[0]}">
                        </div>
                        <div class="form-group">
                            <label for="todo_description">备注</label>
                            <textarea id="todo_description" name="description" maxlength="1000" placeholder="详细说明（可选）"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="todo_time">提醒时间</label>
                            <select id="todo_time" name="reminder_time">
                                <option value="all_day">当天</option>
                                <option value="06:00">06:00</option>
                                <option value="07:00">07:00</option>
                                <option value="08:00">08:00</option>
                                <option value="09:00">09:00</option>
                                <option value="10:00">10:00</option>
                                <option value="11:00">11:00</option>
                                <option value="12:00">12:00</option>
                                <option value="13:00">13:00</option>
                                <option value="14:00">14:00</option>
                                <option value="15:00">15:00</option>
                                <option value="16:00">16:00</option>
                                <option value="17:00">17:00</option>
                                <option value="18:00">18:00</option>
                                <option value="19:00">19:00</option>
                                <option value="20:00">20:00</option>
                                <option value="21:00">21:00</option>
                                <option value="22:00">22:00</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo_priority">优先级</label>
                            <select id="todo_priority" name="priority">
                                <option value="low">低</option>
                                <option value="medium" selected>中</option>
                                <option value="high">高</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo_repeat">重复频率</label>
                            <select id="todo_repeat" name="repeat_type" onchange="TodoManager.handleRepeatChange(this)">
                                <option value="none">不重复</option>
                                <option value="daily" selected>每天</option>
                                <option value="every_other_day">隔天</option>
                                <option value="weekly">每周</option>
                                <option value="monthly">每月</option>
                                <option value="yearly">每年</option>
                                <option value="custom">自定义</option>
                            </select>
                        </div>
                        <div class="form-group" id="custom_interval_group" style="display: none;">
                            <label for="custom_interval">自定义间隔</label>
                            <div class="form-row">
                                <input type="number" id="custom_interval" name="custom_interval" min="1" max="365" value="2" style="width: 80px;">
                                <span style="margin-left: 8px;">天一次</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="todo_cycle">重复周期</label>
                            <select id="todo_cycle" name="cycle_type" onchange="TodoManager.handleCycleChange(this)">
                                <option value="long_term" selected>长期</option>
                                <option value="custom">自定义周期</option>
                            </select>
                        </div>
                        <div class="form-group" id="custom_cycle_group" style="display: none;">
                            <label for="cycle_duration">周期时长</label>
                            <div class="form-row" style="display: table !important; width: 100% !important; table-layout: fixed !important; border-collapse: separate !important; border-spacing: 8px 0 !important;">
                                <input type="number" id="cycle_duration" name="cycle_duration" min="1" max="365" value="1" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; text-align: center !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important;">
                                <select id="cycle_unit" name="cycle_unit" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important; cursor: pointer !important;">
                                    <option value="days">天</option>
                                    <option value="weeks">周</option>
                                    <option value="months">月</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-actions">
                            <button type="button" onclick="TodoManager.closeAddTodoForm()">取消</button>
                            <button type="submit">添加TODO</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // 关闭添加TODO表单
    closeAddTodoForm() {
        const modal = document.getElementById('addTodoModal');
        if (modal) {
            modal.remove();
        }
    },

    // 处理添加TODO表单提交（主入口）
    async handleAddTodo(event, userId) {
        event.preventDefault();
        
        try {
            // 解析表单数据
            const todoData = this._parseAddTodoForm(event.target, userId);
            
            // 创建TODO
            await this._createTodoOnServer(todoData);
            
            // 处理创建成功后的操作
            await this._handleAddTodoSuccess(userId);
            
        } catch (error) {
            this._handleAddTodoError(error);
        }
    },

    // 解析添加TODO表单数据
    _parseAddTodoForm(form, userId) {
        const formData = new FormData(form);
        const repeatType = formData.get('repeat_type') || 'none';
        const customInterval = parseInt(formData.get('custom_interval')) || 1;
        const cycleType = formData.get('cycle_type') || 'long_term';
        const cycleDuration = parseInt(formData.get('cycle_duration')) || null;
        const cycleUnit = formData.get('cycle_unit') || 'days';
        
        console.log('📋 表单数据调试:');
        console.log('  cycleType:', cycleType);
        console.log('  cycleDuration:', cycleDuration);
        console.log('  cycleUnit:', cycleUnit);
        
        // 使用当前选中的日期作为开始日期
        const selectedStartDate = formData.get('start_date') || 
            (DateManager.selectedDate || new Date()).toISOString().split('T')[0];
        
        const todoData = {
            user_id: userId,
            title: formData.get('title'),
            description: formData.get('description') || '',
            reminder_time: formData.get('reminder_time') || 'all_day',
            priority: formData.get('priority') || 'medium',
            repeat_type: repeatType,
            repeat_interval: repeatType === 'custom' ? customInterval : 1,
            cycle_type: cycleType,
            cycle_duration: cycleType === 'custom' ? cycleDuration : null,
            cycle_unit: cycleType === 'custom' ? cycleUnit : 'days',
            start_date: selectedStartDate
        };
        
        console.log('📤 发送到服务器的TODO数据:', todoData);
        return todoData;
    },

    // 在服务器上创建TODO
    async _createTodoOnServer(todoData) {
        if (WebSocketClient.isConnected) {
            return await this._createTodoViaWebSocket(todoData);
        } else {
            return await this._createTodoViaHTTP(todoData);
        }
    },

    // 通过WebSocket创建TODO
    async _createTodoViaWebSocket(todoData) {
        const response = await WebSocketClient.todos.create(todoData);
        if (response.data && response.data.todo) {
            this.convertApiTodoToLocal(response.data.todo);
            console.log('✅ 通过WebSocket创建TODO成功');
            return response;
        } else {
            throw new Error('WebSocket响应格式错误');
        }
    },

    // 通过HTTP创建TODO
    async _createTodoViaHTTP(todoData) {
        const response = await ApiClient.todos.create(todoData);
        if (response.success) {
            this.convertApiTodoToLocal(response.data);
            console.log('✅ 通过HTTP创建TODO成功');
            return response;
        } else {
            throw new Error(response.message || '创建TODO失败');
        }
    },

    // 处理TODO创建成功后的操作
    async _handleAddTodoSuccess(userId) {
        // 关闭表单
        this.closeAddTodoForm();
        
        // 清除缓存并重新加载数据
        this.clearAllRelatedCache(userId);
        const currentDate = DateManager.selectedDate || new Date();
        await this.loadTodosForDate(currentDate, userId);
        
        // 显示成功消息
        this.showMessage('TODO添加成功！', 'success');
    },

    // 处理TODO创建错误
    _handleAddTodoError(error) {
        console.error('添加TODO失败:', error);
        this.showMessage('添加TODO失败: ' + error.message, 'error');
    },

    // 处理重复频率变化
    handleRepeatChange(select) {
        const customGroup = document.getElementById('custom_interval_group');
        if (customGroup) {
            customGroup.style.display = select.value === 'custom' ? 'block' : 'none';
        }
    },

    // 处理重复周期变化
    handleCycleChange(select) {
        const customCycleGroup = document.getElementById('custom_cycle_group');
        if (customCycleGroup) {
            customCycleGroup.style.display = select.value === 'custom' ? 'block' : 'none';
        }
    },

    // 显示编辑TODO表单
    showEditTodoForm(todoId, userId) {
        const todo = this.todos[userId]?.find(t => t.id === todoId);
        if (!todo) return;
        
        const user = UserManager.getUser(userId);
        if (!user) return;
        
        const formHtml = this._generateEditFormHTML(todo, user, todoId, userId);
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // 生成编辑表单HTML
    _generateEditFormHTML(todo, user, todoId, userId) {
        return `
            <div class="modal-overlay" id="editTodoModal">
                <div class="modal-content">
                    ${this._generateEditFormHeader(user)}
                    <form class="todo-form" onsubmit="TodoManager.handleEditTodo(event, '${todoId}', ${userId})">
                        ${this._generateBasicFields(todo)}
                        ${this._generateTimeAndPriorityFields(todo)}
                        ${this._generateRepeatFields(todo)}
                        ${this._generateCycleFields(todo)}
                        ${this._generateFormActions(todoId, userId)}
                    </form>
                </div>
            </div>
        `;
    },

    // 生成表单头部
    _generateEditFormHeader(user) {
        return `
            <div class="modal-header">
                <h3>编辑 ${user.display_name || user.username} 的TODO</h3>
                <button class="modal-close" onclick="TodoManager.closeEditTodoForm()">×</button>
            </div>
        `;
    },

    // 生成基础字段
    _generateBasicFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_title">标题 *</label>
                <input type="text" id="edit_todo_title" name="title" required maxlength="200" value="${todo.text}" placeholder="例如：吃鱼肝油">
            </div>
            <div class="form-group">
                <label for="edit_todo_start_date">开始日期</label>
                <input type="date" id="edit_todo_start_date" name="start_date" value="${todo.createdDate}">
            </div>
            <div class="form-group">
                <label for="edit_todo_description">备注</label>
                <textarea id="edit_todo_description" name="description" maxlength="1000" placeholder="详细说明（可选）">${todo.note || ''}</textarea>
            </div>
        `;
    },

    // 生成时间和优先级字段
    _generateTimeAndPriorityFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_time">提醒时间</label>
                <select id="edit_todo_time" name="reminder_time">
                    ${this._generateTimeOptions(todo.time)}
                </select>
            </div>
            <div class="form-group">
                <label for="edit_todo_priority">优先级</label>
                <select id="edit_todo_priority" name="priority">
                    ${this._generatePriorityOptions(todo.priority)}
                </select>
            </div>
        `;
    },

    // 生成时间选项
    _generateTimeOptions(selectedTime) {
        const timeOptions = [
            { value: 'all_day', label: '当天', compareValue: '当天' },
            ...Array.from({ length: 17 }, (_, i) => {
                const hour = String(i + 6).padStart(2, '0');
                return { value: `${hour}:00`, label: `${hour}:00`, compareValue: `${hour}:00` };
            })
        ];

        return timeOptions.map(option => 
            `<option value="${option.value}" ${selectedTime === option.compareValue ? 'selected' : ''}>${option.label}</option>`
        ).join('');
    },

    // 生成优先级选项
    _generatePriorityOptions(selectedPriority) {
        const priorities = [
            { value: 'low', label: '低' },
            { value: 'medium', label: '中' },
            { value: 'high', label: '高' }
        ];

        return priorities.map(priority => {
            const isSelected = priority.value === selectedPriority || 
                             (priority.value === 'medium' && (!selectedPriority || selectedPriority === 'medium'));
            return `<option value="${priority.value}" ${isSelected ? 'selected' : ''}>${priority.label}</option>`;
        }).join('');
    },

    // 生成重复字段
    _generateRepeatFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_repeat">重复频率</label>
                <select id="edit_todo_repeat" name="repeat_type" onchange="TodoManager.handleEditRepeatChange(this, '${todo.customInterval || 1}')">
                    ${this._generateRepeatOptions(todo.periodType)}
                </select>
            </div>
            <div class="form-group" id="edit_custom_interval_group" style="display: ${todo.periodType === 'custom' ? 'block' : 'none'};">
                <label for="edit_custom_interval">自定义间隔</label>
                <div class="form-row">
                    <input type="number" id="edit_custom_interval" name="custom_interval" min="1" max="365" value="${todo.customInterval || 1}" style="width: 80px;">
                    <span style="margin-left: 8px;">天一次</span>
                </div>
            </div>
        `;
    },

    // 生成重复选项
    _generateRepeatOptions(selectedType) {
        const repeatTypes = [
            { value: 'none', label: '不重复' },
            { value: 'daily', label: '每天' },
            { value: 'every_other_day', label: '隔天' },
            { value: 'weekly', label: '每周' },
            { value: 'monthly', label: '每月' },
            { value: 'yearly', label: '每年' },
            { value: 'custom', label: '自定义' }
        ];

        return repeatTypes.map(type => {
            const isSelected = type.value === selectedType || 
                             (type.value === 'none' && (!selectedType || selectedType === 'none'));
            return `<option value="${type.value}" ${isSelected ? 'selected' : ''}>${type.label}</option>`;
        }).join('');
    },

    // 生成周期字段
    _generateCycleFields(todo) {
        return `
            <div class="form-group">
                <label for="edit_todo_cycle">重复周期</label>
                <select id="edit_todo_cycle" name="cycle_type" onchange="TodoManager.handleEditCycleChange(this, '${todo.cycleDuration || 1}', '${todo.cycleUnit || 'days'}')">
                    ${this._generateCycleOptions(todo.cycleType)}
                </select>
            </div>
            <div class="form-group" id="edit_custom_cycle_group" style="display: ${todo.cycleType === 'custom' ? 'block' : 'none'};">
                <label for="edit_cycle_duration">周期时长</label>
                <div class="form-row" style="display: table !important; width: 100% !important; table-layout: fixed !important; border-collapse: separate !important; border-spacing: 8px 0 !important;">
                    <input type="number" id="edit_cycle_duration" name="cycle_duration" min="1" max="365" value="${todo.cycleDuration || 1}" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; text-align: center !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important;">
                    <select id="edit_cycle_unit" name="cycle_unit" style="display: table-cell !important; width: 60px !important; min-width: 60px !important; max-width: 60px !important; padding: 8px 6px !important; font-size: 14px !important; box-sizing: border-box !important; vertical-align: middle !important; border: 1px solid #e1e8ed !important; border-radius: 6px !important; background: white !important; cursor: pointer !important;">
                        ${this._generateCycleUnitOptions(todo.cycleUnit)}
                    </select>
                </div>
            </div>
        `;
    },

    // 生成周期选项
    _generateCycleOptions(selectedType) {
        const cycleTypes = [
            { value: 'long_term', label: '长期' },
            { value: 'custom', label: '自定义周期' }
        ];

        return cycleTypes.map(type => {
            const isSelected = type.value === selectedType || 
                             (type.value === 'long_term' && (!selectedType || selectedType === 'long_term'));
            return `<option value="${type.value}" ${isSelected ? 'selected' : ''}>${type.label}</option>`;
        }).join('');
    },

    // 生成周期单位选项
    _generateCycleUnitOptions(selectedUnit) {
        const units = [
            { value: 'days', label: '天' },
            { value: 'weeks', label: '周' },
            { value: 'months', label: '月' }
        ];

        return units.map(unit => 
            `<option value="${unit.value}" ${selectedUnit === unit.value ? 'selected' : ''}>${unit.label}</option>`
        ).join('');
    },

    // 生成表单操作按钮
    _generateFormActions(todoId, userId) {
        return `
            <div class="form-actions">
                <button type="button" class="delete-btn" onclick="TodoManager.deleteTodo('${todoId}', ${userId})">删除</button>
                <button type="button" onclick="TodoManager.closeEditTodoForm()">取消</button>
                <button type="submit">保存</button>
            </div>
        `;
    },

    // 关闭编辑TODO表单
    closeEditTodoForm() {
        const modal = document.getElementById('editTodoModal');
        if (modal) {
            modal.remove();
        }
    },

    // 处理编辑TODO表单提交
    // eslint-disable-next-line no-unused-vars
    async handleEditTodo(event, todoId, _userId) {
        event.preventDefault();
        
        const updateData = this._extractEditFormData(event.target);
        
        try {
            await this._performTodoUpdate(todoId, updateData);
            await this._handleUpdateSuccess();
        } catch (error) {
            this._handleUpdateError(error);
        }
    },

    // 提取编辑表单数据
    _extractEditFormData(form) {
        const formData = new FormData(form);
        const repeatType = formData.get('repeat_type') || 'none';
        const cycleType = formData.get('cycle_type') || 'long_term';
        
        return {
            title: formData.get('title'),
            description: formData.get('description') || '',
            reminder_time: formData.get('reminder_time') || 'all_day',
            priority: formData.get('priority') || 'medium',
            repeat_type: repeatType,
            repeat_interval: this._getRepeatInterval(formData, repeatType),
            cycle_type: cycleType,
            cycle_duration: this._getCycleDuration(formData, cycleType),
            cycle_unit: this._getCycleUnit(formData, cycleType),
            start_date: formData.get('start_date')
        };
    },

    // 获取重复间隔
    _getRepeatInterval(formData, repeatType) {
        if (repeatType === 'custom') {
            return parseInt(formData.get('custom_interval')) || 1;
        }
        return 1;
    },

    // 获取周期持续时间
    _getCycleDuration(formData, cycleType) {
        if (cycleType === 'custom') {
            return parseInt(formData.get('cycle_duration')) || null;
        }
        return null;
    },

    // 获取周期单位
    _getCycleUnit(formData, cycleType) {
        if (cycleType === 'custom') {
            return formData.get('cycle_unit') || 'days';
        }
        return 'days';
    },

    // 执行TODO更新
    async _performTodoUpdate(todoId, updateData) {
        const response = await ApiClient.todos.update(todoId, updateData);
        if (!response.success) {
            throw new Error(response.message || '更新TODO失败');
        }
        console.log('✅ 在服务器更新TODO成功');
    },

    // 处理更新成功
    async _handleUpdateSuccess() {
        this.closeEditTodoForm();
        this._refreshTodoData();
        this.showMessage('TODO更新成功！', 'success');
    },

    // 刷新TODO数据
    async _refreshTodoData() {
        this.clearAllRelatedCache(this.currentUser);
        const currentDate = DateManager.selectedDate || new Date();
        await this.loadTodosForDate(currentDate, this.currentUser);
    },

    // 处理更新错误
    _handleUpdateError(error) {
        console.error('更新TODO失败:', error);
        this.showMessage('更新TODO失败: ' + error.message, 'error');
    },

    // 处理编辑重复频率变化
    handleEditRepeatChange(select, defaultInterval) {
        const customGroup = document.getElementById('edit_custom_interval_group');
        if (customGroup) {
            customGroup.style.display = select.value === 'custom' ? 'block' : 'none';
            if (select.value === 'custom') {
                const intervalInput = document.getElementById('edit_custom_interval');
                if (intervalInput && !intervalInput.value) {
                    intervalInput.value = defaultInterval;
                }
            }
        }
    },

    // 处理编辑重复周期变化
    handleEditCycleChange(select, defaultDuration, defaultUnit) {
        const customCycleGroup = document.getElementById('edit_custom_cycle_group');
        if (customCycleGroup) {
            customCycleGroup.style.display = select.value === 'custom' ? 'block' : 'none';
            if (select.value === 'custom') {
                const durationInput = document.getElementById('edit_cycle_duration');
                const unitSelect = document.getElementById('edit_cycle_unit');
                if (durationInput && !durationInput.value) {
                    durationInput.value = defaultDuration;
                }
                if (unitSelect && !unitSelect.value) {
                    unitSelect.value = defaultUnit;
                }
            }
        }
    },

    // 删除TODO - 智能删除对话框
    async deleteTodo(todoId, userId) {
        const todo = this.todos[userId]?.find(t => t.id == todoId);
        if (!todo) return;

        // 如果是重复任务，显示删除选项对话框
        if (todo.periodType && todo.periodType !== 'none') {
            this.showDeleteOptionsDialog(todoId, userId, todo);
        } else {
            // 一次性任务，直接确认删除
            
            const confirmed = await DialogUtils.showDeleteConfirm('这个TODO');
            if (confirmed) {
                await this.performDelete(todoId, userId, 'all');
            }
        }
    },

    // 显示删除选项对话框
    showDeleteOptionsDialog(todoId, userId, todo) {
        const currentDate = DateManager.selectedDate || new Date();
        const currentDateStr = this.formatDate(currentDate);
        
        const dialogHtml = `
            <div class="modal-overlay" id="deleteOptionsModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>删除重复任务</h3>
                        <button class="modal-close" onclick="TodoManager.closeDeleteOptionsDialog()">×</button>
                    </div>
                    <div class="delete-options-content">
                        <p>这是一个重复任务："${todo.text}"</p>
                        <p>你想要删除：</p>
                        <div class="delete-options">
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="single" checked>
                                <span>只删除 ${currentDateStr} 的这个任务</span>
                            </label>
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="from_date">
                                <span>删除 ${currentDateStr} 及以后的所有任务</span>
                            </label>
                            <label class="delete-option">
                                <input type="radio" name="deleteOption" value="all">
                                <span>删除所有日期的这个任务</span>
                            </label>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" onclick="TodoManager.closeDeleteOptionsDialog()">取消</button>
                        <button type="button" class="delete-btn" onclick="TodoManager.confirmDelete(${todoId}, ${userId})">删除</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', dialogHtml);
    },

    // 关闭删除选项对话框
    closeDeleteOptionsDialog() {
        const modal = document.getElementById('deleteOptionsModal');
        if (modal) {
            modal.remove();
        }
    },

    // 确认删除
    async confirmDelete(todoId, userId) {
        const selectedOption = document.querySelector('input[name="deleteOption"]:checked');
        if (!selectedOption) return;

        const deletionType = selectedOption.value;
        const currentDate = DateManager.selectedDate || new Date();
        const deletionDate = currentDate.toISOString().split('T')[0];

        this.closeDeleteOptionsDialog();
        await this.performDelete(todoId, userId, deletionType, deletionDate);
    },

    // 执行删除操作
    async performDelete(todoId, userId, deletionType, deletionDate = null) {
        try {
            // 在服务器删除TODO
            const response = await ApiClient.todos.delete(todoId, deletionType, deletionDate);
            if (response.success) {
                console.log('✅ 在服务器删除TODO成功');
                
                // 清除该用户的所有缓存，因为删除可能影响多个日期（特别是长期重复任务）
                this.clearAllRelatedCache(this.currentUser);
                
                // 重新加载当前日期的TODO数据
                const currentDate = DateManager.selectedDate || new Date();
                await this.loadTodosForDate(currentDate, this.currentUser);
                
                // 关闭编辑表单（如果打开的话）
                this.closeEditTodoForm();
                
                // 显示成功消息
                this.showMessage(response.message || 'TODO删除成功！', 'success');
            } else {
                throw new Error(response.message || '删除TODO失败');
            }
            
        } catch (error) {
            console.error('删除TODO失败:', error);
            this.showMessage('删除TODO失败: ' + error.message, 'error');
        }
    },

    // 注意：日期导航现在由DateManager统一处理

    // 加载指定日期的TODO（优化版，支持缓存）
    async loadTodosForDate(date, userId = null, silent = false, retryCount = 0) {
        const dateStr = date.toISOString().split('T')[0];
        const targetUserId = userId || this.currentUser;
        
        this._logLoadingStart(dateStr, targetUserId, retryCount, silent);
        
        try {
            // 检查缓存
            if (await this._tryLoadFromCache(targetUserId, dateStr, silent)) {
                return;
            }
            
            // 从服务器加载数据
            await this._loadFromServer(targetUserId, userId, dateStr, silent, retryCount);
            
            // 清理缓存和渲染
            this._cleanupCacheAndRender(targetUserId, dateStr, silent);
            
        } catch (error) {
            await this._handleLoadingError(error, date, userId, silent, retryCount, targetUserId, dateStr);
        }
    },

    // 记录加载开始日志
    _logLoadingStart(dateStr, targetUserId, retryCount, silent) {
        if (!silent) {
            console.log('🔄 开始加载指定日期的TODO数据...');
            console.log('📅 目标日期:', dateStr, '用户ID:', targetUserId, '重试次数:', retryCount);
        }
    },

    // 尝试从缓存加载
    async _tryLoadFromCache(targetUserId, dateStr, silent) {
        const cacheKey = `${targetUserId}_${dateStr}`;
        if (!this.todoCache.has(cacheKey)) {
            if (!silent) console.log('🔍 缓存未命中，从服务器加载数据，用户:', targetUserId);
            return false;
        }

        if (!silent) console.log('📦 使用缓存数据，用户:', targetUserId);
        const cachedData = this.todoCache.get(cacheKey);
        this.todos[targetUserId] = [...cachedData];
        
        this._renderIfNeeded(targetUserId, silent);
        this.lastLoadedDate = dateStr;
        return true;
    },

    // 从服务器加载数据
    async _loadFromServer(targetUserId, userId, dateStr, silent, retryCount) {
        const usersToLoad = this._getUsersToLoad(userId, targetUserId);
        
        for (const user of usersToLoad) {
            await this._loadUserTodos(user, dateStr, silent, retryCount);
        }
    },

    // 获取需要加载的用户列表
    _getUsersToLoad(userId, targetUserId) {
        return userId ? 
            [UserManager.getUser(userId)].filter(Boolean) : 
            [UserManager.getUser(targetUserId)].filter(Boolean);
    },

    // 加载单个用户的TODO数据
    async _loadUserTodos(user, dateStr, silent, retryCount) {
        try {
            const todos = await this._fetchUserTodos(user, dateStr, silent);
            this.todos[user.id] = todos;
            
            // 存入缓存
            const userCacheKey = `${user.id}_${dateStr}`;
            this.todoCache.set(userCacheKey, [...todos]);
            
            if (!silent) {
                console.log(`✅ 已加载用户${user.id}在${dateStr}的TODO数据，数量:`, todos.length);
            }
        } catch (error) {
            await this._handleUserLoadError(user, dateStr, error, retryCount, silent);
        }
    },

    // 获取用户TODO数据
    async _fetchUserTodos(user, dateStr, silent) {
        if (WebSocketClient.isConnected) {
            if (!silent) console.log(`🔌 使用WebSocket加载用户${user.id}的TODO数据...`);
            const response = await WebSocketClient.todos.getTodosForDate(user.id, dateStr);
            return response.data.todos.map(todo => this.convertApiTodoToLocal(todo));
        } else {
            if (!silent) console.log(`🌐 使用HTTP加载用户${user.id}的TODO数据...`);
            const response = await ApiClient.todos.getTodosForDate(user.id, dateStr);
            return response.success ? response.data.map(todo => this.convertApiTodoToLocal(todo)) : [];
        }
    },

    // 处理用户加载错误
    // eslint-disable-next-line no-unused-vars
    async _handleUserLoadError(user, dateStr, error, retryCount, _silent) {
        console.warn(`加载用户${user.id}在${dateStr}的TODO失败:`, error.message);
        
        if (this._shouldRetryUserLoad(error, retryCount)) {
            console.log(`🔄 超时重试 ${retryCount + 1}/${this.MAX_RETRIES} 用户${user.id}...`);
            await this._delayRetry(retryCount);
            throw error; // 重新抛出错误以触发整体重试
        }
        
        this.todos[user.id] = [];
    },

    // 判断是否应该重试用户加载
    _shouldRetryUserLoad(error, retryCount) {
        return error.message.includes('请求超时') && retryCount < (this.MAX_RETRIES || 3);
    },

    // 延迟重试
    async _delayRetry(retryCount) {
        const delay = (retryCount + 1) * (this.RETRY_DELAY_BASE || 1000);
        await new Promise(resolve => setTimeout(resolve, delay));
    },

    // 清理缓存并渲染
    _cleanupCacheAndRender(targetUserId, dateStr, silent) {
        this._cleanupCache();
        this._renderIfNeeded(targetUserId, silent);
        this.lastLoadedDate = dateStr;
    },

    // 清理缓存
    _cleanupCache() {
        if (this.todoCache.size > 50) {
            const sortedKeys = Array.from(this.todoCache.keys()).sort();
            const keysToDelete = sortedKeys.slice(0, sortedKeys.length - 50);
            keysToDelete.forEach(key => this.todoCache.delete(key));
        }
    },

    // 如果需要则渲染
    _renderIfNeeded(targetUserId, silent) {
        if (!targetUserId) {
            console.warn('⚠️ 无法确定要渲染哪个用户的TODO面板');
            return;
        }

        const shouldRender = window.GlobalUserState ? 
            GlobalUserState.getCurrentModule() === 'todo' : true;
            
        if (shouldRender) {
            this.renderTodoPanel(targetUserId);
            if (!silent) console.log('✅ TODO面板渲染完成');
        } else if (!silent) {
            console.log('⏸️ 当前不在TODO模块，仅后台同步数据');
        }
    },

    // 处理加载错误
    async _handleLoadingError(error, date, userId, silent, retryCount, targetUserId, dateStr) {
        console.error(`加载用户${targetUserId}在${dateStr}的TODO失败:`, error);
        
        const MAX_RETRIES = this.MAX_RETRIES || 3;
        
        if (this._shouldRetryLoad(error, retryCount, MAX_RETRIES)) {
            await this._retryLoad(date, userId, silent, retryCount, MAX_RETRIES);
            return;
        }
        
        // 最终失败处理
        this._handleFinalLoadError(error, retryCount, MAX_RETRIES, silent);
    },

    // 判断是否应该重试加载
    _shouldRetryLoad(error, retryCount, maxRetries) {
        return error.message.includes('请求超时') && retryCount < maxRetries;
    },

    // 重试加载
    async _retryLoad(date, userId, silent, retryCount, maxRetries) {
        console.log(`🔄 整体超时重试 ${retryCount + 1}/${maxRetries}...`);
        if (!silent) {
            this.showMessage(`请求超时，正在重试 (${retryCount + 1}/${maxRetries})...`, 'warning');
        }
        
        const delay = (retryCount + 1) * (this.RETRY_DELAY_MULTIPLIER || 2000);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.loadTodosForDate(date, userId, silent, retryCount + 1);
    },

    // 处理最终加载错误
    _handleFinalLoadError(error, retryCount, maxRetries, silent) {
        const errorMsg = retryCount >= maxRetries ? 
            `加载TODO失败: ${error.message} (已重试${maxRetries}次)` : 
            `加载TODO失败: ${error.message}`;
        
        if (!silent) this.showMessage(errorMsg, 'error');
    },

    // 格式化日期显示
    formatDate(date) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        
        const month = months[date.getMonth()];
        const day = date.getDate();
        const weekday = weekdays[date.getDay()];
        
        return `${month} ${day} ${weekday}`;
    },

    // 显示消息
    showMessage(message, type = 'info', duration = 3000) {
        // 如果是重试消息，使用特殊样式
        const isRetry = type === 'warning' && message.includes('重试');
        
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            z-index: 10000;
            color: white;
            font-weight: 500;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        `;
        
        switch (type) {
            case 'success':
                messageEl.style.backgroundColor = '#4CAF50';
                break;
            case 'error':
                messageEl.style.backgroundColor = '#f44336';
                break;
            case 'warning':
                messageEl.style.backgroundColor = '#ff9800';
                break;
            default:
                messageEl.style.backgroundColor = '#2196F3';
        }
        
        // 如果是重试消息，添加加载动画
        if (isRetry) {
            messageEl.innerHTML = `
                <span class="retry-spinner">⏳</span>
                ${message}
            `;
            duration = 10000; // 重试消息显示更久
        }
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, duration);
    },

    // 处理WebSocket广播消息（来自其他设备的操作）
    handleWebSocketBroadcast(type, data) {
        console.log('🔄 处理TODO广播消息:', type, data);
        
        switch (type) {
            case 'TODO_CREATE_BROADCAST':
            case 'TODO_UPDATE_BROADCAST':
            case 'TODO_DELETE_BROADCAST':
                // 清除所有用户的缓存，因为广播可能来自其他设备，影响所有用户
                console.log('🧹 广播消息：清除所有缓存');
                this.clearAllRelatedCache();
                // 重新加载当前日期的TODO数据
                this.loadTodosForDate(DateManager.selectedDate || new Date(), this.currentUser);
                break;
                
            case 'TODO_COMPLETE_BROADCAST':
            case 'TODO_UNCOMPLETE_BROADCAST':
                // 完成状态变化也要清除缓存，确保数据同步
                console.log('🧹 完成状态广播：清除相关用户缓存');
                if (data.userId) {
                    this.clearAllRelatedCache(data.userId);
                } else {
                    this.clearAllRelatedCache();
                }
                // 重新加载当前日期的数据
                this.loadTodosForDate(DateManager.selectedDate || new Date(), this.currentUser);
                break;
                
            case 'TODO_SYNC_UPDATE': {
                // 🔥 关键修复：处理关联用户的实时同步更新
                console.log('🔗 [TODO] 收到Link同步更新:', data);
                
                // 立即清除所有缓存
                console.log('🧹 [TODO] 清除所有缓存以确保数据同步');
                this.clearAllRelatedCache();
                
                // 获取当前日期和用户
                const currentDate = window.DateManager ? window.DateManager.selectedDate : new Date();
                const currentUser = this.currentUser;
                const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : null;
                
                console.log('📅 [TODO] 同步更新信息:', {
                    currentDate: currentDate.toISOString().split('T')[0],
                    currentUser,
                    currentModule,
                    operation: data.operation,
                    fromUser: data.sync?.fromUser
                });
                
                if (currentUser) {
                    // 强制重新加载数据
                    this.loadTodosForDate(currentDate, currentUser, false).then(() => {
                        console.log('✅ [TODO] 同步数据重新加载完成');
                        
                        // 如果当前在TODO模块，确保界面更新
                        if (currentModule === 'todo') {
                            console.log('🎨 [TODO] 重新渲染界面以显示同步数据');
                            this.renderTodoPanel(currentUser);
                        }
                        
                        // 显示同步通知
                        if (data.sync && data.sync.fromUser) {
                            const operationText = {
                                'COMPLETE': '完成',
                                'UNCOMPLETE': '取消完成',
                                'CREATE': '创建',
                                'UPDATE': '更新',
                                'DELETE': '删除'
                            }[data.operation] || data.operation;
                            
                            this.showSyncStatusToast(`${data.sync.fromUser} ${operationText}了待办事项`, 'success');
                        }
                    }).catch(error => {
                        console.error('❌ [TODO] 同步数据重新加载失败:', error);
                    });
                }
                break;
            }
        }
    },

    // 降级到HTTP模式
    fallbackToHTTP() {
        console.log('📡 TODO模块降级到HTTP模式');
        // 目前的实现已经自动处理降级，无需额外操作
    },

    // 清除所有相关缓存 - 彻底清理方法
    clearAllRelatedCache(userId = null) {
        console.log('🧹 开始清除所有相关缓存...', userId ? `用户${userId}` : '所有用户');
        
        if (userId) {
            // 清除指定用户的所有缓存
            const keysToDelete = [];
            for (const key of this.todoCache.keys()) {
                if (key.startsWith(`${userId}_`)) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => {
                this.todoCache.delete(key);
                console.log('🗑️ 删除缓存:', key);
            });
            console.log(`✅ 已清除用户${userId}的${keysToDelete.length}个缓存项`);
        } else {
            // 清除所有缓存
            const cacheCount = this.todoCache.size;
            this.todoCache.clear();
            console.log(`✅ 已清除所有${cacheCount}个缓存项`);
        }
    },

    // 清除指定用户指定日期范围的缓存
    clearCacheForDateRange(userId, startDate = null, endDate = null) {
        console.log('🧹 清除日期范围缓存...', {userId, startDate, endDate});
        
        const keysToDelete = [];
        for (const key of this.todoCache.keys()) {
            if (!key.startsWith(`${userId}_`)) continue;
            
            const dateStr = key.split('_')[1];
            if (!startDate && !endDate) {
                // 如果没有指定日期范围，清除该用户所有缓存
                keysToDelete.push(key);
            } else if (startDate && endDate) {
                // 检查日期是否在范围内
                if (dateStr >= startDate && dateStr <= endDate) {
                    keysToDelete.push(key);
                }
            } else if (startDate) {
                // 只有开始日期，清除该日期及以后的缓存
                if (dateStr >= startDate) {
                    keysToDelete.push(key);
                }
            }
        }
        
        keysToDelete.forEach(key => {
            this.todoCache.delete(key);
            console.log('🗑️ 删除范围缓存:', key);
        });
        
        console.log(`✅ 已清除用户${userId}的${keysToDelete.length}个日期范围缓存项`);
    },

    // 绑定事件
    bindEvents() {
        // 用户标签点击事件现在由GlobalUserState统一处理
        // 不需要在这里重复绑定事件
    }
};

// 导出到全局
window.TodoManager = TodoManager;


// Notes管理器 - 健康笔记功能
const NotesManager = {
    notes: {},
    currentUser: 1,
    isOnline: false,
    // 🔥 新增：添加缓存机制，参考TodoManager
    notesCache: new Map(),
    lastLoadedUser: null,

    // 初始化
    async init() {
        console.log('🔄 初始化Notes管理器...');
        
        // 检查后端连接
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.warn('⚠️ 后端服务不可用，Notes功能将无法正常工作');
            this.showOfflineError();
            return;
        }

        // 等待用户管理器初始化完成
        await this.waitForUserManager();
        
        // 加载Notes数据
        await this.loadNotesFromAPI();
        
        // 设置默认用户
        this.setDefaultUser();
        
        // 监听全局用户状态变化，但不设置模块
        await this.registerGlobalStateListener();
        
        // WebSocket消息处理由websocketClient.js统一管理，无需单独注册
        
        // 渲染界面
        this.renderNotesPanel(this.currentUser);
        this.bindEvents();
        
        console.log('✅ Notes管理器初始化完成');
    },

    // 等待用户管理器初始化完成
    async waitForUserManager() {
        // 设置最大等待时间为5秒，避免新用户无限等待
        const MAX_WAIT_TIME = 5000; // 5秒
        const startTime = Date.now();
        
        if (UserManager.users.length === 0) {
            console.log('⏳ Notes: 等待用户数据加载，新用户最多等待5秒...');
            await new Promise(resolve => {
                const checkUsers = () => {
                    const elapsedTime = Date.now() - startTime;
                    
                    if (UserManager.users.length > 0) {
                        console.log('✅ Notes: 用户数据已加载');
                        resolve();
                    } else if (elapsedTime >= MAX_WAIT_TIME) {
                        console.log('⏰ Notes: 等待超时，可能是新用户没有被管理用户，继续初始化...');
                        resolve();
                    } else {
                        setTimeout(checkUsers, 100);
                    }
                };
                checkUsers();
            });
        }
    },

    // 🔥 新增：等待并注册全局状态监听器
    async registerGlobalStateListener() {
        console.log('📝 [Notes] 开始注册全局状态监听器...');
        
        // 等待GlobalUserState准备好
        let attempts = 0;
        const maxAttempts = 50; // 最多等待5秒
        
        while (!window.GlobalUserState && attempts < maxAttempts) {
            console.log(`⏳ [Notes] 等待GlobalUserState准备... (${attempts + 1}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (window.GlobalUserState) {
            console.log('📝 [Notes] 注册全局状态监听器...');
            GlobalUserState.addListener(this.handleGlobalStateChange.bind(this));
            console.log('✅ [Notes] 全局状态监听器注册完成');
            console.log('🔍 [Notes] 当前监听器数量:', GlobalUserState.listeners.length);
        } else {
            console.error('❌ [Notes] GlobalUserState未找到，无法注册监听器');
        }
    },

    // 🔥 修复：重写数据加载机制，参考TodoManager模式
    async loadNotesFromAPI(autoRender = false, targetUserId = null) {
        try {
            console.log('🔄 [Notes] 开始加载Notes数据...', autoRender ? '(自动渲染)' : '', 'targetUserId:', targetUserId);
            
            if (targetUserId) {
                await this._loadSingleUserNotes(targetUserId);
            } else {
                await this._loadAllUsersNotes();
            }
            
            this._handleAutoRender(autoRender, targetUserId);
            
        } catch (error) {
            this._handleNotesLoadError(error, autoRender, targetUserId);
        }
    },

    // 加载单个用户的笔记
    async _loadSingleUserNotes(userId) {
        const cacheKey = `notes_${userId}`;
        
        if (this._isNotesDataCached(cacheKey)) {
            this._loadNotesFromCache(userId, cacheKey);
        } else {
            await this._loadNotesFromAPI(userId, cacheKey);
        }
    },

    // 检查笔记数据是否已缓存
    _isNotesDataCached(cacheKey) {
        return this.notesCache.has(cacheKey) && 
               Date.now() - this.notesCache.get(cacheKey).timestamp < 30000;
    },

    // 从缓存加载笔记数据
    _loadNotesFromCache(userId, cacheKey) {
        console.log(`📦 [Notes] 使用缓存数据，用户: ${userId}`);
        this.notes[userId] = this.notesCache.get(cacheKey).data;
    },

    // 从API加载笔记数据
    async _loadNotesFromAPI(userId, cacheKey) {
        console.log(`📥 [Notes] 从API加载用户 ${userId} 的Notes...`);
        const response = await ApiClient.notes.getByUserId(userId);
        
        if (response.success) {
            this.notes[userId] = response.data || [];
            this._updateNotesCache(cacheKey, userId);
            console.log(`✅ [Notes] 用户 ${userId} 的Notes加载完成: ${this.notes[userId].length} 条`);
        } else {
            console.warn(`⚠️ [Notes] 加载用户 ${userId} 的Notes失败:`, response.message);
            this.notes[userId] = [];
        }
    },

    // 更新笔记缓存
    _updateNotesCache(cacheKey, userId) {
        this.notesCache.set(cacheKey, {
            data: this.notes[userId],
            timestamp: Date.now()
        });
    },

    // 加载所有用户的笔记
    async _loadAllUsersNotes() {
        for (const user of UserManager.users) {
            console.log(`📥 [Notes] 初始化加载用户 ${user.username} 的Notes...`);
            await this._loadUserNotesData(user);
        }
    },

    // 加载用户笔记数据
    async _loadUserNotesData(user) {
        const response = await ApiClient.notes.getByUserId(user.id);
        
        if (response.success) {
            this.notes[user.id] = response.data || [];
            this._updateUserNotesCache(user);
            console.log(`✅ [Notes] 用户 ${user.username} 的Notes加载完成: ${this.notes[user.id].length} 条`);
        } else {
            console.warn(`⚠️ [Notes] 加载用户 ${user.username} 的Notes失败:`, response.message);
            this.notes[user.id] = [];
        }
    },

    // 更新用户笔记缓存
    _updateUserNotesCache(user) {
        const cacheKey = `notes_${user.id}`;
        this.notesCache.set(cacheKey, {
            data: this.notes[user.id],
            timestamp: Date.now()
        });
    },

    // 处理自动渲染
    _handleAutoRender(autoRender, targetUserId) {
        if (autoRender) {
            const renderUserId = targetUserId || this.currentUser;
            if (renderUserId) {
                console.log('🎨 [Notes] 数据加载完成，渲染指定用户界面:', renderUserId);
                console.log('🔍 [Notes] 用户数据:', this.notes[renderUserId] ? this.notes[renderUserId].length : 'undefined');
                this.renderNotesPanel(renderUserId);
            }
        }
    },

    // 处理笔记加载错误
    _handleNotesLoadError(error, autoRender, targetUserId) {
        console.error('❌ [Notes] 加载Notes数据失败:', error);
        this.showMessage('加载笔记数据失败: ' + error.message, 'error');
        
        this._initializeEmptyNotesData(targetUserId);
        this._renderOnError(autoRender, targetUserId);
    },

    // 初始化空的笔记数据
    _initializeEmptyNotesData(targetUserId) {
        if (targetUserId) {
            this.notes[targetUserId] = [];
        } else {
            UserManager.users.forEach(user => {
                this.notes[user.id] = [];
            });
        }
    },

    // 错误时渲染界面
    _renderOnError(autoRender, targetUserId) {
        if (autoRender) {
            const renderUserId = targetUserId || this.currentUser;
            if (renderUserId) {
                console.log('🎨 [Notes] 数据加载失败，仍然渲染界面避免空白，用户:', renderUserId);
                this.renderNotesPanel(renderUserId);
            }
        }
    },

    // 🔥 修复：设置默认用户（参考TodoManager模式）
    setDefaultUser() {
        console.log('🔄 [Notes] 开始设置默认用户...');
        console.log('🔍 [Notes] 用户数据调试:');
        console.log('  - UserManager.users.length:', UserManager.users.length);
        console.log('  - UserManager.users:', UserManager.users);
        
        if (UserManager.users.length > 0) {
            // 检查是否有保存的用户选择
            let savedUserId = null;
            if (window.GlobalUserState) {
                savedUserId = GlobalUserState.getCurrentUser();
                console.log('💾 [Notes] 从全局状态获取保存的用户ID:', savedUserId);
            }
            
            // 🔥 修复：按ID排序，选择ID最小的用户（最早添加的用户）
            const sortedUsers = [...UserManager.users].sort((a, b) => a.id - b.id);
            
            // 验证保存的用户ID是否仍然存在
            let defaultUser;
            if (savedUserId && sortedUsers.find(u => u.id == savedUserId)) {
                defaultUser = parseInt(savedUserId);
                console.log('🎯 [Notes] 使用保存的用户ID:', defaultUser);
            } else {
                defaultUser = sortedUsers[0].id;
                console.log('🎯 [Notes] 使用默认第一个用户:', defaultUser, '(用户名:', sortedUsers[0].username, ')');
            }
            
            console.log('📋 [Notes] 所有用户按ID排序:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));
            this.currentUser = defaultUser;
            
            // 直接同步全局状态，不触发事件
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = defaultUser;
                localStorage.setItem('wenting_current_user_id', defaultUser.toString());
                console.log('🔄 [Notes] 直接同步全局用户状态（不触发事件）');
                console.log('🔍 [Notes] 设置后的状态:');
                console.log('  - NotesManager.currentUser:', this.currentUser);
                console.log('  - GlobalUserState.currentUserId:', GlobalUserState.currentUserId);
            }
        } else {
            console.log('📝 [Notes] 没有用户，设置为空状态');
            this.currentUser = null;
            
            if (window.GlobalUserState) {
                GlobalUserState.currentUserId = null;
                console.log('🔄 [Notes] 设置全局状态为空用户状态');
            }
        }
    },

    // 🔥 修复：处理全局状态变化（参考TodoManager模式）
    handleGlobalStateChange(type, data) {
        console.log('📢 [Notes] 收到全局状态变化:', type, data);
        
        if (type === 'userChanged') {
            const newUserId = data.userId;
            console.log('🔄 [Notes] 处理用户切换事件:');
            console.log('  - 当前用户:', this.currentUser);
            console.log('  - 新用户:', newUserId);
            
            // 先更新currentUser，确保后续操作使用正确的用户ID
            const oldUser = this.currentUser;
            this.currentUser = newUserId;
            
            if (oldUser !== newUserId) {
                console.log(`🔄 [Notes] 用户从 ${oldUser} 切换到 ${newUserId}`);
                // 只有当前模块是notes时才渲染
                if (GlobalUserState.getCurrentModule() === 'notes') {
                    console.log('✅ [Notes] 当前是Notes模块，直接渲染Notes内容');
                    
                    // 🔥 关键修复：直接调用渲染方法，让渲染方法内部处理数据加载
                    this.renderNotesPanel(newUserId);
                } else {
                    console.log('⏸️ [Notes] 当前不是Notes模块，跳过渲染');
                }
            } else {
                console.log('🔄 [Notes] 用户ID相同，但仍需重新渲染Notes面板（可能是初始化调用）');
                if (GlobalUserState.getCurrentModule() === 'notes') {
                    console.log('✅ [Notes] 当前是Notes模块，直接渲染Notes内容');
                    this.renderNotesPanel(newUserId);
                } else {
                    console.log('⏸️ [Notes] 当前不是Notes模块，跳过渲染');
                }
            }
        }
    },
    
    // 🔥 新增：加载单个用户的Notes数据（参考TodoManager模式）
    async loadNotesForUser(userId, autoRender = false) {
        try {
            console.log(`📥 [Notes] 开始加载用户${userId}的Notes...`);
            
            // 🔥 关键修复：清除旧数据和缓存，避免数据串用
            console.log(`🧹 [Notes] 清除用户${userId}的旧数据和缓存...`);
            
            // 强制清除数据
            if (this.notes[userId]) {
                delete this.notes[userId];
                console.log(`✅ [Notes] 已清除用户${userId}的旧数据`);
            }
            
            // 清除缓存
            const cacheKey = `notes_${userId}`;
            if (this.notesCache.has(cacheKey)) {
                this.notesCache.delete(cacheKey);
                console.log(`✅ [Notes] 已清除用户${userId}的缓存`);
            }
            
            // 🔥 关键修复：先初始化为空数组，然后加载
            this.notes[userId] = [];
            console.log(`🔄 [Notes] 用户${userId}初始化为空数组`);
            
            // 重新加载数据
            await this.loadNotesFromAPI(autoRender, userId);
            
            console.log(`✅ [Notes] 用户${userId}的Notes加载完成，最终数据:`, this.notes[userId]);
            
        } catch (error) {
            console.error(`❌ [Notes] 加载用户${userId}的Notes失败:`, error);
            // 确保失败时也有空数组
            this.notes[userId] = [];
            if (autoRender) {
                this.renderNotesPanel(userId);
            }
        }
    },



    // 🔥 关键修复：处理WebSocket广播消息（完全按照TodoManager的模式）
    handleWebSocketBroadcast(type, data) {
        console.log('🔄 处理Notes广播消息:', type, data);
        
        switch (type) {
            case 'NOTES_CREATE_BROADCAST':
            case 'NOTES_UPDATE_BROADCAST':
            case 'NOTES_DELETE_BROADCAST': {
                // 🔥 修复：仅清除当前用户的缓存，而不是所有用户
                console.log('🧹 [Notes] 广播消息：清除当前用户缓存');
                this.clearAllNotesCache(this.currentUser);
                // 🔥 关键修复：仅当当前模块为notes时自动渲染
                const shouldAutoRender = window.GlobalUserState && GlobalUserState.getCurrentModule() === 'notes';
                if (shouldAutoRender) {
                    console.log('🔄 [Notes] 当前是Notes模块，重新加载数据');
                    this.loadNotesForUser(this.currentUser, true);
                } else {
                    console.log('⏸️ [Notes] 当前不是Notes模块，跳过渲染');
                }
                break;
            }
                
            case 'NOTES_SYNC_UPDATE': {
                // 🔥 关键修复：处理关联用户的实时同步更新
                console.log('🔗 [Notes] 收到Link同步更新:', data);
                console.log('🔗 [Notes] 当前NotesManager状态:', {
                    currentUser: this.currentUser,
                    currentModule: window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : null,
                    notesCount: Object.keys(this.notes).length
                });
                
                // 🔥 关键修复：检查是否是自己的操作，避免重复处理
                const currentAppUser = localStorage.getItem('wenting_current_app_user');
                const isOwnOperation = data.sync && data.sync.fromUser === currentAppUser;
                
                console.log('🔍 [Notes] 同步消息来源检查:', {
                    fromUser: data.sync?.fromUser,
                    currentAppUser: currentAppUser,
                    isOwnOperation: isOwnOperation
                });
                
                if (isOwnOperation) {
                    console.log('⏸️ [Notes] 这是自己的操作，跳过同步重载（避免界面闪烁）');
                    
                    // 只显示成功提示，不重新加载数据
                    if (data.sync && data.sync.fromUser) {
                        const operationText = {
                            'CREATE': '创建',
                            'UPDATE': '更新',
                            'DELETE': '删除'
                        }[data.operation] || data.operation;
                        
                        this.showSyncStatusToast(`${operationText}操作已同步到关联用户`, 'info');
                    }
                    return;
                }
                
                // 🔥 新增：立即显示同步提示
                this.showSyncStatusToast('正在同步Notes数据...', 'info');
                
                // 🔥 修复：仅清除当前用户的缓存
                console.log('🧹 [Notes] 清除当前用户缓存以确保数据同步');
                this.clearAllNotesCache(this.currentUser);
                
                // 获取当前用户和模块
                const currentUser = this.currentUser;
                const currentModule = window.GlobalUserState ? window.GlobalUserState.getCurrentModule() : null;
                
                console.log('📝 [Notes] 处理其他用户的同步更新:', {
                    currentUser,
                    currentModule,
                    operation: data.operation,
                    fromUser: data.sync?.fromUser
                });
                
                if (currentUser) {
                    // 🔥 关键修复：始终进行数据同步，但根据模块决定是否渲染UI
                    const shouldAutoRender = currentModule === 'notes';
                    console.log('🔄 [Notes] 开始重新加载数据，自动渲染:', shouldAutoRender);
                    
                    // 🔥 修复：始终重新加载数据确保缓存更新
                    this.loadNotesForUser(currentUser, shouldAutoRender).then(() => {
                        console.log('✅ [Notes] 同步数据重新加载完成');
                        
                        // 显示成功提示
                        if (data.sync && data.sync.fromUser) {
                            const operationText = {
                                'CREATE': '创建',
                                'UPDATE': '更新',
                                'DELETE': '删除'
                            }[data.operation] || data.operation;
                            
                            const syncType = shouldAutoRender ? '已同步' : '后台同步';
                            this.showSyncStatusToast(`${data.sync.fromUser} ${operationText}了健康笔记 (${syncType})`, 'success');
                        }
                    }).catch(error => {
                        console.error('❌ [Notes] 同步数据重新加载失败:', error);
                        this.showSyncStatusToast('同步失败，请刷新页面', 'error');
                    });
                }
                break;
            }
        }
    },



    // 降级到HTTP模式
    fallbackToHTTP() {
        console.log('📡 Notes模块降级到HTTP模式');
        // 目前的实现已经自动处理降级，无需额外操作
    },

    // 🔥 修复：清除Notes缓存（增加Map缓存清理）
    clearAllNotesCache(userId = null) {
        console.log('🧹 [Notes] 开始清除Notes缓存...', userId ? `用户${userId}` : '所有用户');
        
        if (userId) {
            // 清除指定用户的Notes数据
            if (this.notes[userId]) {
                delete this.notes[userId];
                console.log(`✅ [Notes] 已清除用户${userId}的Notes数据`);
            }
            // 清除Map缓存
            const cacheKey = `notes_${userId}`;
            if (this.notesCache.has(cacheKey)) {
                this.notesCache.delete(cacheKey);
                console.log(`✅ [Notes] 已清除用户${userId}的Map缓存`);
            }
        } else {
            // 清除所有Notes数据
            const userCount = Object.keys(this.notes).length;
            this.notes = {};
            this.notesCache.clear(); // 清除Map缓存
            console.log(`✅ [Notes] 已清除所有${userCount}个用户的Notes缓存`);
        }
    },

    // 🔥 修复：渲染Notes面板 - 确保数据正确加载和显示
    async renderNotesPanel(userId) {
        const contentArea = Utils.$('#contentArea');
        if (!contentArea) return;

        console.log(`🎨 [Notes] 开始渲染用户 ${userId} 的Notes面板`);
        console.log(`🔍 [Notes] 当前用户数据检查:`, {
            userId: userId,
            hasData: !!this.notes[userId],
            dataLength: this.notes[userId] ? this.notes[userId].length : 'undefined',
            allUsersData: Object.keys(this.notes).map(id => `${id}:${this.notes[id]?.length || 0}`).join(', ')
        });

        // 🔥 关键修复：如果用户数据不存在或为空，先尝试加载
        if (!this.notes[userId] || this.notes[userId].length === 0) {
            console.log(`📥 [Notes] 用户${userId}数据为空，尝试从API加载...`);
            
            // 显示加载状态
            contentArea.innerHTML = `
                <div class="content-panel" id="${userId}-notes-panel">
                    <div class="notes-content">
                        <div class="notes-loading">
                            <div class="loading-spinner"></div>
                            <p>正在加载笔记...</p>
                        </div>
                    </div>
                </div>
            `;
            
            try {
                // 强制从API重新加载数据
                await this.loadNotesForUser(userId, false);
                console.log(`✅ [Notes] 用户${userId}数据加载完成，重新渲染`);
            } catch (error) {
                console.error(`❌ [Notes] 加载用户${userId}数据失败:`, error);
                // 继续渲染空状态
            }
        }

        // 获取最新的用户数据
        const userNotes = this.notes[userId] || [];
        console.log(`🎨 [Notes] 最终渲染用户 ${userId} 的Notes面板，共 ${userNotes.length} 条笔记`);
        console.log(`🔍 [Notes] 用户${userId}的最终数据:`, userNotes);

        const panelHtml = `
            <div class="content-panel" id="${userId}-notes-panel">
                <div class="notes-content">
                    <div class="notes-container">
                        ${userNotes.length > 0 
                            ? userNotes.map(note => this.renderNoteCard(note, userId)).join('')
                            : this.renderEmptyState()
                        }
                    </div>
                </div>
                <button class="new-note-btn" onclick="NotesManager.showAddNoteForm(${userId})">+ 添加新笔记</button>
            </div>
        `;

        contentArea.innerHTML = panelHtml;
        console.log(`✅ [Notes] 用户${userId}的Notes面板渲染完成`);
    },

    // 渲染笔记卡片
    // eslint-disable-next-line no-unused-vars
    renderNoteCard(note, _userId) {
        const shortDescription = note.description.length > 50 
            ? note.description.substring(0, 50) + '...' 
            : note.description;

        // 获取同步状态
        const syncStatus = this.getSyncStatus(note.user_id);
        const syncIndicator = syncStatus.isLinked ? `
            <div class="sync-indicator ${syncStatus.status}" title="${syncStatus.tooltip}">
                <span class="sync-icon">${syncStatus.icon}</span>
            </div>
        ` : '';

        return `
            <div class="note-card clickable" data-note-id="${note.id}" onclick="NotesManager.showNoteDetails(${note.id})">
                <div class="note-header">
                    <div class="note-title-container">
                        <h3 class="note-title">${Utils.escapeHtml(note.title)}</h3>
                        ${syncIndicator}
                    </div>
                    <div class="note-actions" onclick="event.stopPropagation()">
                        <button class="note-action-btn delete" onclick="NotesManager.deleteNote(${note.id})" title="删除">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                ${shortDescription ? `<p class="note-description">${Utils.escapeHtml(shortDescription)}</p>` : ''}
                ${note.precautions ? `<div class="note-precautions">
                    <strong>注意事项:</strong> ${Utils.escapeHtml(note.precautions.length > 80 ? note.precautions.substring(0, 80) + '...' : note.precautions)}
                </div>` : ''}
            </div>
        `;
    },

    // 获取同步状态
    getSyncStatus(userId) {
        // 检查用户是否有关联关系
        const user = UserManager.users.find(u => u.id === userId);
        if (!user) {
            return { isLinked: false };
        }
        
        // 检查是否已关联
        if (user.is_linked && user.supervised_app_user) {
            return {
                isLinked: true,
                status: 'synced',
                icon: '🔗',
                tooltip: `已与 ${user.supervised_app_user} 同步`
            };
        }
        
        return { isLinked: false };
    },

    // 显示同步状态提示
    showSyncStatusToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `sync-toast ${type}`;
        toast.innerHTML = `
            <span class="sync-toast-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
            <span class="sync-toast-message">${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // 显示动画
        setTimeout(() => toast.classList.add('show'), 100);
        
        // 3秒后移除
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    },

    // 渲染空状态
    renderEmptyState() {
        return `
            <div class="notes-empty-state">
                <div class="empty-icon">📝</div>
                <h3>还没有健康笔记</h3>
                <p>开始记录您的健康状况和注意事项</p>
            </div>
        `;
    },

    // 显示添加笔记表单
    showAddNoteForm(userId) {
        const formHtml = `
            <div class="modal-overlay" id="addNoteModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>添加健康笔记</h3>
                        <button class="modal-close" onclick="NotesManager.closeNoteForm()">×</button>
                    </div>
                    <form class="note-form" onsubmit="NotesManager.handleAddNote(event, ${userId})">
                        <div class="form-group">
                            <label for="note-title">健康状况标题 *</label>
                            <input type="text" id="note-title" name="title" required maxlength="100" 
                                   placeholder="如：关节炎、血压高、轻度抑郁等">
                        </div>
                        <div class="form-group">
                            <label for="note-description">详细描述</label>
                            <textarea id="note-description" name="description" rows="4" 
                                      placeholder="详细描述您的健康状况..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="note-precautions">注意事项/医嘱</label>
                            <textarea id="note-precautions" name="precautions" rows="3" 
                                      placeholder="医生建议、注意事项等..."></textarea>
                        </div>
                        <div class="form-actions">
                            <button type="button" onclick="NotesManager.closeNoteForm()">取消</button>
                            <button type="submit">保存笔记</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
    },

    // 处理添加笔记
    async handleAddNote(event, userId) {
        event.preventDefault();
        
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        
        try {
            // 防止重复提交
            submitButton.disabled = true;
            submitButton.textContent = '保存中...';
            
            const formData = new FormData(form);
            const noteData = {
                user_id: parseInt(userId),
                title: formData.get('title').trim(),
                description: formData.get('description').trim(),
                precautions: formData.get('precautions').trim()
            };
            
            console.log('🔄 创建新笔记:', noteData);
            const response = await ApiClient.notes.create(noteData);
            
            if (response.success) {
                console.log('✅ [Notes] 后端创建成功:', response.data);
                
                // 🔥 关键修复：直接将新笔记添加到本地数据，然后渲染
                if (!this.notes[userId]) {
                    this.notes[userId] = [];
                }
                this.notes[userId].unshift(response.data); // 添加到数组开头
                
                // 更新缓存
                const cacheKey = `notes_${userId}`;
                this.notesCache.set(cacheKey, {
                    data: this.notes[userId],
                    timestamp: Date.now()
                });
                
                // 立即渲染新界面
                this.renderNotesPanel(userId);
                
                // 关闭表单
                this.closeNoteForm();
                
                this.showMessage('笔记添加成功！', 'success');
                console.log('✅ [Notes] 创建操作完成，界面已更新');
            } else {
                throw new Error(response.message || '创建笔记失败');
            }
            
        } catch (error) {
            console.error('❌ 添加笔记失败:', error);
            this.showMessage('添加笔记失败: ' + error.message, 'error');
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = '保存笔记';
        }
    },


    // 显示编辑笔记内容表单（只编辑描述和注意事项）
    async showEditNoteContentForm(noteId) {
        try {
            // 获取笔记详情
            const response = await ApiClient.notes.getById(noteId);
            if (!response.success) {
                throw new Error(response.message);
            }
            
            const note = response.data;
            const formHtml = `
                <div class="modal-overlay" id="editNoteContentModal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>编辑笔记内容</h3>
                            <button class="modal-close" onclick="NotesManager.closeNoteContentForm()">×</button>
                        </div>
                        <form class="note-form" onsubmit="NotesManager.handleEditNoteContent(event, ${noteId})">
                            <div class="form-group">
                                <label for="edit-content-description">详细描述</label>
                                <textarea id="edit-content-description" name="description" rows="4" 
                                          placeholder="详细描述您的健康状况...">${Utils.escapeHtml(note.description || '')}</textarea>
                            </div>
                            <div class="form-group">
                                <label for="edit-content-precautions">注意事项/医嘱</label>
                                <textarea id="edit-content-precautions" name="precautions" rows="3" 
                                          placeholder="医生建议、注意事项等...">${Utils.escapeHtml(note.precautions || '')}</textarea>
                            </div>
                            <div class="form-actions">
                                <button type="button" onclick="NotesManager.closeNoteContentForm()">取消</button>
                                <button type="submit">保存修改</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', formHtml);
        } catch (error) {
            console.error('显示编辑内容表单失败:', error);
            this.showMessage('加载笔记数据失败: ' + error.message, 'error');
        }
    },

    // 处理编辑笔记内容
    async handleEditNoteContent(event, noteId) {
        event.preventDefault();
        
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        
        try {
            // 防止重复提交
            submitButton.disabled = true;
            submitButton.textContent = '保存中...';
            
            const formData = new FormData(form);
            const noteData = {
                description: formData.get('description').trim(),
                precautions: formData.get('precautions').trim()
                // 注意：这里不包括 ai_suggestions，保持不变
            };
            
            console.log('🔄 更新笔记内容:', noteId, noteData);
            const response = await ApiClient.notes.update(noteId, noteData);
            
            if (response.success) {
                console.log('✅ [Notes] 内容更新成功:', response.data);
                
                // 🔥 修复：更新本地数据并立即渲染
                const updatedNote = response.data;
                if (this.notes[this.currentUser]) {
                    const noteIndex = this.notes[this.currentUser].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[this.currentUser][noteIndex] = updatedNote;
                    }
                }
                
                // 更新缓存
                const cacheKey = `notes_${this.currentUser}`;
                this.notesCache.set(cacheKey, {
                    data: this.notes[this.currentUser],
                    timestamp: Date.now()
                });
                
                // 立即渲染新界面
                this.renderNotesPanel(this.currentUser);
                
                // 关闭编辑表单
                this.closeNoteContentForm();
                
                // 更新详情页面内容
                this.updateNoteDetailsContent(noteId, response.data);
                
                this.showMessage('笔记内容更新成功！', 'success');
                console.log('✅ [Notes] 内容更新操作完成，界面已更新');
            } else {
                throw new Error(response.message || '更新笔记内容失败');
            }
            
        } catch (error) {
            console.error('❌ 更新笔记内容失败:', error);
            this.showMessage('更新笔记内容失败: ' + error.message, 'error');
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = '保存修改';
        }
    },

    // 关闭笔记内容编辑表单
    closeNoteContentForm() {
        const modal = document.getElementById('editNoteContentModal');
        if (modal) {
            modal.remove();
        }
    },

    // 更新详情页面内容（不刷新整个详情页，只更新内容部分）
    updateNoteDetailsContent(noteId, updatedNote) {
        // 更新详细描述
        const descriptionElement = document.querySelector('.detail-section:nth-child(1) p');
        if (descriptionElement) {
            descriptionElement.textContent = updatedNote.description || 'N/A';
        }
        
        // 更新注意事项
        const precautionsElement = document.querySelector('.detail-section:nth-child(2) p');
        if (precautionsElement) {
            precautionsElement.textContent = updatedNote.precautions || 'N/A';
        }
        
        console.log('✅ 详情页面内容已更新');
    },

    // 关闭笔记表单
    closeNoteForm() {
        const modal = document.getElementById('addNoteModal') || document.getElementById('editNoteModal');
        if (modal) {
            modal.remove();
        }
    },

    // 显示笔记详情
    async showNoteDetails(noteId) {
        try {
            const response = await ApiClient.notes.getById(noteId);
            if (!response.success) {
                throw new Error(response.message);
            }
            
            const note = response.data;
            const detailsHtml = `
                <div class="modal-overlay" id="noteDetailsModal">
                    <div class="modal-content large">
                        <div class="modal-header">
                            <h3>${Utils.escapeHtml(note.title)}</h3>
                            <button class="modal-close" onclick="NotesManager.closeNoteDetails()">×</button>
                        </div>
                        <div class="note-details">
                            <div class="detail-section">
                                <h4>详细描述</h4>
                                <p>${note.description ? Utils.escapeHtml(note.description) : 'N/A'}</p>
                            </div>
                            <div class="detail-section">
                                <h4>注意事项/医嘱</h4>
                                <p>${note.precautions ? Utils.escapeHtml(note.precautions) : 'N/A'}</p>
                            </div>
                            <div class="detail-section">
                                <h4>AI建议</h4>
                                ${note.ai_suggestions ? `
                                    <div class="ai-suggestions-content">${this.formatAISuggestions(note.ai_suggestions)}</div>
                                ` : `
                                    <p class="no-suggestions">暂无AI建议</p>
                                    <button class="generate-ai-btn" onclick="NotesManager.generateAISuggestions(${noteId})">
                                        获取AI建议
                                    </button>
                                `}
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="NotesManager.showEditNoteContentForm(${noteId})" class="edit-content-btn">编辑</button>
                            ${note.ai_suggestions ? `<button onclick="NotesManager.regenerateAISuggestions(${noteId})" class="regenerate-ai-btn">再次生成AI建议</button>` : ''}
                            <button onclick="NotesManager.shareNoteAsImage(${noteId})" class="share-note-btn">分享</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', detailsHtml);
        } catch (error) {
            console.error('显示笔记详情失败:', error);
            this.showMessage('加载笔记详情失败: ' + error.message, 'error');
        }
    },

    // 关闭笔记详情
    closeNoteDetails() {
        const modal = document.getElementById('noteDetailsModal');
        if (modal) {
            modal.remove();
        }
    },

    // 设置AI生成加载状态
    setAIGenerationLoadingState(isLoading) {
        const modal = document.querySelector('.modal-overlay');
        if (!modal) return;

        // 获取所有需要禁用的按钮
        const editButton = modal.querySelector('.edit-content-btn');
        const regenerateButton = modal.querySelector('.regenerate-ai-btn');
        const generateButton = modal.querySelector('.generate-ai-btn');
        const shareButton = modal.querySelector('.share-note-btn');

        const buttons = [editButton, regenerateButton, generateButton, shareButton].filter(btn => btn);

        if (isLoading) {
            // 启用加载状态
            buttons.forEach(button => {
                if (button) {
                    button.disabled = true;
                    button.style.opacity = '0.6';
                    button.style.cursor = 'not-allowed';
                }
            });

            // 添加加载遮罩
            if (!modal.querySelector('.ai-loading-overlay')) {
                const loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'ai-loading-overlay';
                loadingOverlay.innerHTML = `
                    <div class="ai-loading-spinner">
                        <div class="spinner"></div>
                        <p>AI正在生成健康建议...</p>
                        <small>请勿关闭窗口</small>
                    </div>
                `;
                modal.appendChild(loadingOverlay);
            }
        } else {
            // 禁用加载状态
            buttons.forEach(button => {
                if (button) {
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                }
            });

            // 移除加载遮罩
            const loadingOverlay = modal.querySelector('.ai-loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.remove();
            }
        }
    },

    // 再次生成AI建议
    async regenerateAISuggestions(noteId) {
        try {
            // 设置加载状态
            this.setAIGenerationLoadingState(true);
            
            const regenerateButton = document.querySelector('.regenerate-ai-btn');
            if (regenerateButton) {
                regenerateButton.textContent = '生成AI建议中...';
            }
            
            console.log('🔄 再次生成AI建议，笔记ID:', noteId);
            
            // 调用后端API生成AI建议，传递真实天气数据给Gemini
            console.log('🚀 再次调用API，传递真实天气数据给Gemini');
            const response = await ApiClient.notes.generateAISuggestions(noteId);
            
            if (response.success) {
                console.log('✅ AI建议再次生成成功:', response.data);
                
                // 更新界面显示AI建议
                const aiSuggestionsSection = document.querySelector('.detail-section:last-child .ai-suggestions-content');
                if (aiSuggestionsSection) {
                    // 直接更新AI建议内容
                    aiSuggestionsSection.innerHTML = this.formatAISuggestions(response.data.ai_suggestions);
                }
                
                // 更新本地数据
                Object.keys(this.notes).forEach(userId => {
                    const noteIndex = this.notes[userId].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[userId][noteIndex].ai_suggestions = response.data.ai_suggestions;
                    }
                });
                
                this.showMessage('AI建议再次生成成功！', 'success');
            } else {
                throw new Error(response.message || '再次生成AI建议失败');
            }
            
        } catch (error) {
            console.error('❌ 再次生成AI建议失败:', error);
            this.showMessage('再次生成AI建议失败: ' + error.message, 'error');
        } finally {
            // 恢复所有按钮状态
            this.setAIGenerationLoadingState(false);
            
            const regenerateButton = document.querySelector('.regenerate-ai-btn');
            if (regenerateButton) {
                regenerateButton.textContent = '再次生成AI建议';
            }
        }
    },

    // 生成AI建议
    async generateAISuggestions(noteId) {
        try {
            // 设置加载状态
            this.setAIGenerationLoadingState(true);
            
            const button = document.querySelector('.generate-ai-btn');
            if (button) {
                button.textContent = '生成中...';
            }
            
            console.log('🤖 开始生成AI建议，笔记ID:', noteId);
            
            // 调用后端API生成AI建议，传递真实天气数据给Gemini
            console.log('🚀 调用API，传递真实天气数据给Gemini');
            const response = await ApiClient.notes.generateAISuggestions(noteId);
            
            if (response.success) {
                console.log('✅ AI建议生成成功:', response.data);
                
                // 更新界面显示AI建议
                const aiSuggestionsSection = document.querySelector('.detail-section:last-child');
                if (aiSuggestionsSection) {
                    // 查找AI建议容器
                    const noSuggestionsElement = aiSuggestionsSection.querySelector('.no-suggestions');
                    const generateButton = aiSuggestionsSection.querySelector('.generate-ai-btn');
                    
                    if (noSuggestionsElement && generateButton) {
                        // 替换"暂无AI建议"和按钮为实际建议内容
                        const aiContentHtml = `<div class="ai-suggestions-content">${this.formatAISuggestions(response.data.ai_suggestions)}</div>`;
                        noSuggestionsElement.outerHTML = aiContentHtml;
                        generateButton.remove();
                        
                        // 在模态框底部添加"再次生成AI建议"按钮
                        const modalActions = document.querySelector('.modal-actions');
                        if (modalActions && !modalActions.querySelector('.regenerate-ai-btn')) {
                            // 在分享按钮之前插入"再次生成AI建议"按钮
                            const shareButton = modalActions.querySelector('.share-note-btn');
                            const regenerateButton = document.createElement('button');
                            regenerateButton.className = 'regenerate-ai-btn';
                            regenerateButton.setAttribute('onclick', `NotesManager.regenerateAISuggestions(${noteId})`);
                            regenerateButton.textContent = '再次生成AI建议';
                            
                            if (shareButton) {
                                modalActions.insertBefore(regenerateButton, shareButton);
                            } else {
                                modalActions.appendChild(regenerateButton);
                            }
                        }
                    }
                }
                
                // 更新本地数据
                Object.keys(this.notes).forEach(userId => {
                    const noteIndex = this.notes[userId].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[userId][noteIndex].ai_suggestions = response.data.ai_suggestions;
                    }
                });
                
                this.showMessage('AI建议生成成功！', 'success');
            } else {
                throw new Error(response.message || '生成AI建议失败');
            }
            
        } catch (error) {
            console.error('❌ 生成AI建议失败:', error);
            this.showMessage('生成AI建议失败: ' + error.message, 'error');
        } finally {
            // 恢复所有按钮状态
            this.setAIGenerationLoadingState(false);
            
            const button = document.querySelector('.generate-ai-btn');
            if (button) {
                button.textContent = '获取AI建议';
            }
        }
    },

    // 删除笔记
    async deleteNote(noteId) {
        
        const confirmed = await DialogUtils.showDeleteConfirm('这条健康笔记');
        if (!confirmed) {
            return;
        }
        
        try {
            console.log('🗑️ [Notes] 开始删除笔记:', noteId);
            console.log('🔍 [Notes] 删除调试信息:');
            console.log('  - 当前用户ID:', this.currentUser);
            console.log('  - 当前App用户:', localStorage.getItem('wenting_current_app_user'));
            console.log('  - 要删除的笔记ID:', noteId);
            
            // 查找这个笔记在当前用户数据中的详情
            if (this.notes[this.currentUser]) {
                const noteToDelete = this.notes[this.currentUser].find(note => note.id === noteId);
                if (noteToDelete) {
                    console.log('  - 笔记详情:', {
                        id: noteToDelete.id,
                        title: noteToDelete.title,
                        description: noteToDelete.description?.substring(0, 50) + '...'
                    });
                } else {
                    console.warn('⚠️ [Notes] 警告：要删除的笔记不在当前用户数据中!');
                }
            }
            
            const response = await ApiClient.notes.delete(noteId);
            
            if (response.success) {
                console.log('✅ [Notes] 后端删除成功，开始更新本地数据');
                
                // 🔥 修复：直接从本地数据中删除，然后渲染
                if (this.notes[this.currentUser]) {
                    const noteIndex = this.notes[this.currentUser].findIndex(note => note.id === noteId);
                    if (noteIndex !== -1) {
                        this.notes[this.currentUser].splice(noteIndex, 1);
                        console.log(`✅ [Notes] 已从本地数据中删除笔记 ID: ${noteId}`);
                    }
                }
                
                // 更新缓存
                const cacheKey = `notes_${this.currentUser}`;
                this.notesCache.set(cacheKey, {
                    data: this.notes[this.currentUser] || [],
                    timestamp: Date.now()
                });
                
                // 🔥 修复：检查删除后是否需要切换用户显示
                const currentUserNotes = this.notes[this.currentUser] || [];
                console.log(`🔍 [Notes] 删除后当前用户${this.currentUser}剩余笔记数: ${currentUserNotes.length}`);
                
                if (currentUserNotes.length === 0) {
                    // 当前用户没有笔记了，检查是否有其他用户有数据
                    const usersWithNotes = Object.keys(this.notes).filter(userId => 
                        this.notes[userId] && this.notes[userId].length > 0
                    );
                    console.log(`🔍 [Notes] 有笔记的用户列表:`, usersWithNotes);
                    
                    if (usersWithNotes.length > 0) {
                        // 切换到第一个有数据的用户
                        const targetUserId = parseInt(usersWithNotes[0]);
                        console.log(`🔄 [Notes] 当前用户无笔记，自动切换到用户${targetUserId}`);
                        this.loadNotesForUser(targetUserId, true);
                    } else {
                        // 所有用户都没有笔记
                        console.log(`📝 [Notes] 所有用户都没有笔记，显示空状态`);
                        this.renderNotesPanel(this.currentUser);
                    }
                } else {
                    // 当前用户还有笔记，正常渲染
                    this.renderNotesPanel(this.currentUser);
                }
                
                this.showMessage('笔记删除成功', 'success');
                console.log('✅ [Notes] 删除操作完成，界面已更新');
            } else {
                throw new Error(response.message);
            }
        } catch (error) {
            console.error('❌ [Notes] 删除笔记失败:', error);
            this.showMessage('删除笔记失败: ' + error.message, 'error');
        }
    },



    // 显示离线错误
    showOfflineError() {
        const contentArea = Utils.$('#contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="offline-error">
                    <div class="error-icon">🔌</div>
                    <h2>服务器连接失败</h2>
                    <p>无法连接到后端服务器，请检查：</p>
                    <p>1. 后端服务是否正常运行</p>
                    <p>2. 网络连接是否正常</p>
                    <button class="retry-btn" onclick="location.reload()">重试</button>
                </div>
            `;
        }
    },

    // 显示消息
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        
        document.body.appendChild(messageEl);
        
        // 3秒后自动移除
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 3000);
    },

    // 格式化AI建议内容
    formatAISuggestions(suggestions) {
        if (!suggestions) return '';
        
        // 将markdown格式转换为HTML
        let formatted = suggestions
            // 处理加粗文本 **text** -> <strong>text</strong>
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            // 处理换行
            .replace(/\n/g, '<br>')
            // 处理空行
            .replace(/<br><br>/g, '<br><br>');
        
        // 特别处理今日建议部分
        if (formatted.includes('🌅 今日建议')) {
            // 找到今日建议的开始和结束位置
            const todayStart = formatted.indexOf('<strong>🌅 今日建议</strong>');
            const nextSectionStart = formatted.indexOf('<strong>👩‍⚕️', todayStart);
            
            if (todayStart !== -1) {
                const todayEnd = nextSectionStart !== -1 ? nextSectionStart : formatted.length;
                const todayContent = formatted.substring(todayStart, todayEnd);
                const restContent = formatted.substring(todayEnd);
                const beforeContent = formatted.substring(0, todayStart);
                
                // 为今日建议添加特殊样式
                const highlightedToday = `<div class="today-suggestion-highlight">${todayContent}</div>`;
                formatted = beforeContent + highlightedToday + restContent;
            }
        }
        
        return `<div style="white-space: normal; line-height: 1.6;">${formatted}</div>`;
    },

    // 分享笔记为图片
    async shareNoteAsImage(noteId) {
        try {
            console.log('📸 开始分享笔记为图片，ID:', noteId);
            this.setShareLoadingState(true);
            const modal = document.getElementById('noteDetailsModal');
            if (!modal) throw new Error('找不到笔记详情页面');
            this.setAIGenerationLoadingState(true);
            this.showShareLoadingOverlay(modal);
            await this.ensureHtml2Canvas();
            await new Promise(res => setTimeout(res, 250));
            const response = await ApiClient.notes.getById(noteId);
            const note = response.success ? response.data : null;

            // 构建专用分享DOM
            const shareDiv = document.createElement('div');
            shareDiv.id = 'note-share-capture';
            shareDiv.style.cssText = `
                width: 600px; margin: 0 auto; background: #fafaf7; color: #222; font-family: 'Noto Sans SC', 'Segoe UI', Arial, sans-serif; border-radius: 12px; border: 1px solid #e1e1e1; box-shadow: 0 2px 8px #eee; padding: 36px 36px 70px 36px; position: relative; line-height: 1.7; letter-spacing: 0.01em;`
            ;
            // 电子墨水风格内容
            shareDiv.innerHTML = `
                <div style="font-size: 2.1rem; font-weight: 700; text-align: center; margin-bottom: 18px; letter-spacing: 0.04em;">${Utils.escapeHtml(note.title)}</div>
                <div style="border-bottom:1.5px solid #e1e1e1; margin-bottom:18px;"></div>
                <div style="margin-bottom: 18px;"><span style="font-weight:600;">详细描述</span><div style="margin-top:6px; color:#222;">${note.description ? Utils.escapeHtml(note.description) : 'N/A'}</div></div>
                <div style="margin-bottom: 18px;"><span style="font-weight:600;">注意事项/医嘱</span><div style="margin-top:6px; color:#222;">${note.precautions ? Utils.escapeHtml(note.precautions) : 'N/A'}</div></div>
                <div style="margin-bottom: 18px;"><span style="font-weight:600;">AI建议</span><div style="margin-top:6px; color:#222;">${note.ai_suggestions ? this.formatAISuggestions(note.ai_suggestions).replace(/<br>/g, '<br/>') : '暂无AI建议'}</div></div>
                <div style="position:absolute;left:0;right:0;bottom:18px;text-align:center;color:#888;font-size:15px;letter-spacing:0.04em;">
                    <span style="font-weight:700;">WENTING</span><br/>
                    Household Health Supervisor
                </div>
            `;
            document.body.appendChild(shareDiv);
            // 截图
            const canvas = await html2canvas(shareDiv, {
                backgroundColor: '#fafaf7',
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                width: 600
            });
            // 清理
            document.body.removeChild(shareDiv);
            this.hideShareLoadingOverlay();
            this.setAIGenerationLoadingState(false);
            this.setShareLoadingState(false);
            // 保存
            const filename = `雯婷健康档案-${note ? note.title : 'note'}-${new Date().toISOString().split('T')[0]}.png`;
            await this.saveImageByDevice(canvas, filename);
        } catch (error) {
            console.error('❌ 分享笔记图片失败:', error);
            this.showMessage('生成图片失败: ' + error.message, 'error');
        } finally {
            this.setShareLoadingState(false);
            this.setAIGenerationLoadingState(false);
            this.hideShareLoadingOverlay();
        }
    },

    // 设置分享加载状态
    setShareLoadingState(isLoading) {
        const shareButton = document.querySelector('.share-note-btn');
        if (!shareButton) return;

        if (isLoading) {
            shareButton.disabled = true;
            shareButton.textContent = '生成中...';
            shareButton.style.opacity = '0.6';
        } else {
            shareButton.disabled = false;
            shareButton.textContent = '分享';
            shareButton.style.opacity = '1';
        }
    },

    // 确保html2canvas库已加载
    async ensureHtml2Canvas() {
        if (typeof html2canvas !== 'undefined') {
            return Promise.resolve();
        }

        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
            script.onload = () => {
                console.log('✅ html2canvas库加载成功');
                resolve();
            };
            script.onerror = () => {
                console.error('❌ html2canvas库加载失败');
                reject(new Error('无法加载图片生成库，请检查网络连接'));
            };
            document.head.appendChild(script);
        });
    },

    // 检测设备类型
    detectDeviceType() {
        const userAgent = navigator.userAgent.toLowerCase();
        const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile/.test(userAgent);
        const isIOS = /ipad|iphone|ipod/.test(userAgent);
        const isAndroid = /android/.test(userAgent);
        
        return {
            isMobile,
            isIOS,
            isAndroid,
            isDesktop: !isMobile
        };
    },

    // 根据设备类型保存图片
    async saveImageByDevice(canvas, filename) {
        const device = this.detectDeviceType();
        const dataUrl = canvas.toDataURL('image/png', 1.0);
        
        try {
            if (device.isMobile) {
                // 移动设备：尝试保存到相册
                await this.saveToGallery(dataUrl, filename, device);
            } else {
                // 桌面设备：下载到桌面/下载文件夹
                this.downloadToDesktop(dataUrl, filename);
            }
        } catch (error) {
            console.error('❌ 保存图片失败:', error);
            // 降级处理：直接下载
            this.downloadToDesktop(dataUrl, filename);
        }
    },

    // 保存到移动设备相册
    async saveToGallery(dataUrl, filename, device) {
        try {
            // 尝试使用 Web Share API (现代浏览器支持)
            if (navigator.share && navigator.canShare) {
                const blob = this.dataUrlToBlob(dataUrl);
                const file = new File([blob], filename, { type: 'image/png' });
                
                if (navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: '雯婷健康档案',
                        text: '分享我的健康档案'
                    });
                    this.showSuccessMessage('✅ 健康档案已成功分享！', '图片已通过系统分享保存到设备');
                    return;
                }
            }

            // 降级方案1：创建下载链接（会保存到下载文件夹）
            if (device.isAndroid || device.isIOS) {
                this.downloadToDesktop(dataUrl, filename);
                
                if (device.isIOS) {
                    this.showSuccessMessage('📱 图片已保存成功！', 'iPhone用户：图片在下载文件夹中，长按选择"存储到相册"即可保存到相册');
                } else {
                    this.showSuccessMessage('📱 图片已保存到相册！', 'Android用户：图片已保存到下载文件夹，可在相册中查看');
                }
                return;
            }

            // 降级方案2：直接下载
            this.downloadToDesktop(dataUrl, filename);
            this.showSuccessMessage('📱 图片已下载成功！', '请手动将图片保存到相册');
            
        } catch (error) {
            console.error('❌ 保存到相册失败:', error);
            throw error;
        }
    },

    // 下载到桌面/下载文件夹
    downloadToDesktop(dataUrl, filename) {
        try {
            const link = document.createElement('a');
            link.download = filename;
            link.href = dataUrl;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('✅ 图片下载成功:', filename);
            
            const device = this.detectDeviceType();
            if (device.isDesktop) {
                this.showSuccessMessage('💻 健康档案已保存成功！', '图片已保存到电脑的下载文件夹中');
            } else {
                this.showSuccessMessage('📱 图片已下载完成！', '请在下载文件夹中查看');
            }
            
        } catch (error) {
            console.error('❌ 图片下载失败:', error);
            throw error;
        }
    },

    // 将 Data URL 转换为 Blob
    dataUrlToBlob(dataUrl) {
        const arr = dataUrl.split(',');
        const mime = arr[0].match(/:(.*?);/)[1];
        const bstr = atob(arr[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        
        return new Blob([u8arr], { type: mime });
    },

    // 显示分享加载遮罩
    showShareLoadingOverlay(modal) {
        // 如果已经存在遮罩，先移除
        this.hideShareLoadingOverlay();
        
        // 复用AI生成的加载遮罩样式
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'ai-loading-overlay share-loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="ai-loading-spinner">
                <div class="spinner"></div>
                <p>正在生成健康档案图片...</p>
                <small>请稍候，正在处理中</small>
            </div>
        `;
        modal.appendChild(loadingOverlay);
    },

    // 隐藏分享加载遮罩
    hideShareLoadingOverlay() {
        const loadingOverlay = document.querySelector('.share-loading-overlay');
        if (loadingOverlay) {
            loadingOverlay.remove();
        }
    },

    // 绑定事件
    bindEvents() {
        // 用户标签点击事件在TodoManager中已处理，这里不需要重复绑定
    }
};

// 导出到全局
window.NotesManager = NotesManager;


// 用户管理模块
const UserManager = {
    users: [],
    isOnline: false,

    async init() {
        // 确保 ApiClient 已加载
        if (typeof ApiClient === 'undefined') {
            console.error('❌ ApiClient 未定义，请检查脚本加载顺序');
            return;
        }
        
        // 检查后端连接 - 必须联网才能使用
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.error('❌ 无法连接到服务器，应用无法启动');
            return;
        }
        
        await this.loadUsersFromAPI();
        this.bindEvents();
        this.renderUserTabs();
    },

    // 从API加载用户数据
    async loadUsersFromAPI() {
        try {
            const response = await ApiClient.users.getAll();
            if (response.success) {
                this.users = response.data;
                console.log('✅ 从服务器加载用户数据成功，用户数量:', this.users.length);
                
                // 数据库为空，等待用户手动添加用户
                if (this.users.length === 0) {
                    console.log('📝 数据库中没有用户，等待用户手动添加');
                }
            }
        } catch (error) {
            console.error('从服务器加载用户数据失败:', error);
            throw error; // 不降级到本地数据，直接抛出错误
        }
    },

    // 创建默认用户（已废弃 - 用户需要手动添加）
    async createDefaultUsers() {
        console.log('⚠️ createDefaultUsers方法已废弃，请手动添加用户');
        // 不再自动创建任何默认用户
        return;
    },



    // 同步用户数据到服务器
    async syncUserToServer(user) {
        if (!this.isOnline) return false;
        
        try {
            let response;
            if (user.id && user.id > 0) {
                // 更新现有用户
                response = await ApiClient.users.update(user.id, user);
            } else {
                // 创建新用户
                response = await ApiClient.users.create(user);
            }
            
            if (response.success) {
                console.log('✅ 用户数据同步到服务器成功');
                return response.data;
            }
        } catch (error) {
            console.error('同步用户数据到服务器失败:', error);
        }
        return false;
    },

    // 添加新用户
    async addUser() {
        // 添加点击反馈动画
        const btn = event.target;
        btn.style.transform = 'scale(0.9)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        // 显示添加用户表单
        this.showAddUserForm();
    },

    // 显示添加用户表单
    showAddUserForm() {
        const formHtml = `
            <div class="modal-overlay" id="addUserModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>添加新用户</h3>
                        <button class="modal-close" data-action="close-add-user-form">×</button>
                    </div>
                    <form class="user-form" id="addUserForm">
                        <div class="form-group">
                            <label for="username">用户名 *</label>
                            <input type="text" id="username" name="username" required maxlength="50">
                        </div>
                        <div class="form-group">
                            <label for="display_name">显示名称 *</label>
                            <input type="text" id="display_name" name="display_name" required maxlength="100">
                        </div>
                        <div class="form-group">
                            <label for="email">邮箱</label>
                            <input type="email" id="email" name="email" maxlength="100">
                        </div>
                        <div class="form-group">
                            <label for="phone">手机号</label>
                            <input type="tel" id="phone" name="phone" pattern="1[3-9]\\d{9}" maxlength="11">
                        </div>
                        <div class="form-group">
                            <label for="gender">性别</label>
                            <select id="gender" name="gender">
                                <option value="">请选择</option>
                                <option value="male">男</option>
                                <option value="female">女</option>
                                <option value="other">其他</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="birthday">生日</label>
                            <input type="date" id="birthday" name="birthday">
                        </div>
                        <div class="form-group">
                            <label for="avatar_color">头像颜色</label>
                            <input type="color" id="avatar_color" name="avatar_color" value="#1d9bf0">
                        </div>
                        <div class="form-actions">
                            <button type="button" data-action="close-add-user-form">取消</button>
                            <button type="submit">添加用户</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', formHtml);
        
        // 绑定事件监听器
        const modal = document.getElementById('addUserModal');
        if (modal) {
            // 关闭按钮事件
            modal.addEventListener('click', (e) => {
                if (e.target.dataset.action === 'close-add-user-form' || e.target.classList.contains('modal-overlay')) {
                    this.closeAddUserForm();
                }
            });
            
            // 表单提交事件
            const form = modal.querySelector('#addUserForm');
            if (form) {
                form.addEventListener('submit', (e) => this.handleAddUser(e));
            }
        }
    },

    // 关闭添加用户表单
    closeAddUserForm() {
        const modal = document.getElementById('addUserModal');
        if (modal) {
            modal.remove();
        }
    },

    // 处理添加用户表单提交
    async handleAddUser(event) {
        event.preventDefault();
        
        const submitButton = this._handleFormSubmission(event);
        if (!submitButton) return;
        
        const userData = this._extractUserData(event.target);
        this._logUserData(userData);

        try {
            const newUser = await this._createUserOnServer(userData);
            await this._handleUserCreationSuccess(newUser);
        } catch (error) {
            this._handleUserCreationError(error);
        } finally {
            this._restoreSubmitButton(submitButton);
        }
    },

    // 处理表单提交状态
    _handleFormSubmission(event) {
        const submitButton = event.target.querySelector('button[type="submit"]');
        if (submitButton.disabled) {
            console.log('⚠️ 表单正在提交中，忽略重复提交');
            return null;
        }
        
        submitButton.disabled = true;
        submitButton.textContent = '提交中...';
        return submitButton;
    },

    // 提取用户数据
    _extractUserData(form) {
        const formData = new FormData(form);
        return {
            username: formData.get('username'),
            display_name: formData.get('display_name'),
            email: formData.get('email') || null,
            phone: formData.get('phone') || null,
            gender: formData.get('gender') || null,
            birthday: formData.get('birthday') || null,
            avatar_color: formData.get('avatar_color') || '#1d9bf0'
        };
    },

    // 记录用户数据
    _logUserData(userData) {
        console.log('📤 准备创建用户:', userData);
        console.log('📋 用户数据详情:');
        Object.keys(userData).forEach(key => {
            console.log(`  ${key}: "${userData[key]}" (类型: ${typeof userData[key]}, 长度: ${userData[key]?.length || 'N/A'})`);
        });
    },

    // 在服务器创建用户
    async _createUserOnServer(userData) {
        console.log('🔄 正在调用API创建用户...');
        const response = await ApiClient.users.create(userData);
        console.log('📥 API响应:', response);
        
        if (response && response.success) {
            console.log('✅ 在服务器创建用户成功:', response.data);
            return response.data;
        } else {
            console.error('❌ API返回失败响应:', response);
            throw new Error(response?.message || '创建用户失败');
        }
    },

    // 处理用户创建成功
    async _handleUserCreationSuccess(newUser) {
        this._addUserToLocalList(newUser);
        this._switchToNewUser(newUser);
        this._updateUserInterface();
        await this._loadNewUserTodos(newUser);
    },

    // 添加用户到本地列表
    _addUserToLocalList(newUser) {
        this.users.push(newUser);
        console.log('📝 已添加到本地用户列表，当前用户数:', this.users.length);
    },

    // 切换到新用户
    _switchToNewUser(newUser) {
        if (window.TodoManager) {
            window.TodoManager.currentUser = newUser.id;
            console.log('🎯 已切换TodoManager到新用户:', newUser.id, newUser.username);
        }
        
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentUser(newUser.id);
            console.log('🎯 已同步GlobalUserState到新用户:', newUser.id, newUser.username);
        }
    },

    // 更新用户界面
    _updateUserInterface() {
        this.renderUserTabs();
        console.log('🎨 已重新渲染用户标签');
        
        this.closeAddUserForm();
        this.showMessage('用户添加成功！', 'success');
    },

    // 为新用户加载TODO列表
    async _loadNewUserTodos(newUser) {
        if (window.TodoManager && typeof window.TodoManager.loadTodosFromAPI === 'function') {
            try {
                window.TodoManager.todos[newUser.id] = [];
                await window.TodoManager.loadTodosFromAPI();
                window.TodoManager.renderTodoPanel(newUser.id);
                console.log('✅ 已加载并显示新用户的TODO列表');
            } catch (todoError) {
                console.warn('重新加载TODO数据失败:', todoError);
                window.TodoManager.renderTodoPanel(newUser.id);
            }
        }
    },

    // 处理用户创建错误
    _handleUserCreationError(error) {
        console.error('❌ 添加用户失败:', error);
        console.error('错误详情:', {
            message: error.message,
            stack: error.stack,
            response: error.response
        });
        
        const errorMessage = this._getErrorMessage(error);
        this.showMessage(errorMessage, 'error');
    },

    // 获取错误消息
    _getErrorMessage(error) {
        if (error.message.includes('fetch') || error.message.includes('NetworkError')) {
            return '网络连接失败，请检查服务器状态';
        } else {
            return '添加用户失败: ' + error.message;
        }
    },

    // 恢复提交按钮状态
    _restoreSubmitButton(submitButton) {
        if (submitButton) {
            submitButton.disabled = false;
            submitButton.textContent = '添加用户';
        }
    },

    // 删除用户
    async removeUser(userId) {
        
        const confirmed = await DialogUtils.showConfirm(
            '确定要删除这个用户吗？这将删除该用户的所有TODO数据。',
            '确认删除用户',
            {
                confirmText: '删除',
                cancelText: '取消',
                type: 'danger'
            }
        );
        if (!confirmed) {
            return;
        }

        try {
            // 从服务器删除
            const response = await ApiClient.users.delete(userId);
            if (!response.success) {
                throw new Error(response.message || '删除用户失败');
            }
            console.log('✅ 从服务器删除用户成功');

            // 从本地删除
            const index = this.users.findIndex(user => user.id === userId);
            if (index > -1) {
                this.users.splice(index, 1);
                
                // 清理对应的TODO数据
                if (TodoManager.todos && TodoManager.todos[userId]) {
                    delete TodoManager.todos[userId];
                }
                
                // 如果删除的是当前用户，切换到第一个用户
                if (TodoManager.currentUser === userId && this.users.length > 0) {
                    TodoManager.switchUser(this.users[0].id);
                }
                
                this.renderUserTabs();
                this.showMessage('用户删除成功！', 'success');
            }
        } catch (error) {
            console.error('删除用户失败:', error);
            this.showMessage('删除用户失败: ' + error.message, 'error');
        }
    },

    // 渲染用户标签
    renderUserTabs() {
        const sidebar = Utils.$('.left-sidebar');
        if (!sidebar) return;

        // 按ID排序，确保用户按创建顺序显示（ID越小越靠前）
        const sortedUsers = [...this.users].sort((a, b) => a.id - b.id);
        console.log('📋 用户排序:', sortedUsers.map(u => `ID:${u.id}(${u.username})`).join(', '));

        // 获取当前选中的用户ID
        const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : (TodoManager.currentUser || null);
        console.log('🎯 renderUserTabs - 当前用户ID:', currentUserId);
        
        const tabsHtml = sortedUsers.map(user => {
            const isActive = parseInt(user.id) === parseInt(currentUserId);
            const userColor = user.avatar_color || '#1d9bf0';
            console.log(`🏷️ 用户${user.id}(${user.username}) - 是否选中:`, isActive);
            
            return `
                <div class="sidebar-tab ${isActive ? 'active' : ''}" 
                     data-tab="${user.id}"
                     style="--user-color: ${userColor};">
                    ${user.display_name || user.username}
                </div>
            `;
        }).join('');

        const addButtonHtml = `
            <div class="add-user-btn" data-action="add-user" title="添加新用户">
                +
            </div>
        `;

        sidebar.innerHTML = tabsHtml + addButtonHtml;
        
        // 重新绑定全局用户选择器事件
        if (window.GlobalUserState) {
            GlobalUserState.bindUserSelectorEvents();
        }
        
        // 触发用户标签渲染完成事件，通知其他页面
        const userTabsRenderedEvent = new CustomEvent('userTabsRendered', {
            detail: {
                users: sortedUsers,
                currentUserId: currentUserId
            }
        });
        document.dispatchEvent(userTabsRenderedEvent);
        console.log('📢 触发userTabsRendered事件，用户数:', sortedUsers.length, '当前用户:', currentUserId);
        
        // 如果有当前用户，也触发userSelected事件
        if (currentUserId) {
            const currentUser = sortedUsers.find(user => user.id === currentUserId);
            if (currentUser) {
                console.log('📢 同时触发userSelected事件，用户:', currentUser.username);
                const userSelectedEvent = new CustomEvent('userSelected', {
                    detail: currentUser
                });
                document.dispatchEvent(userSelectedEvent);
            }
        }
    },

    // 获取用户信息
    getUser(userId) {
        return this.users.find(user => user.id === userId);
    },

    // 更新用户信息
    async updateUser(userId, updates) {
        try {
            // 在服务器更新用户
            const response = await ApiClient.users.update(userId, updates);
            if (response.success) {
                const updatedUser = response.data;
                console.log('✅ 在服务器更新用户成功');
                
                // 更新本地用户数据
                const user = this.getUser(userId);
                if (user) {
                    Object.assign(user, updatedUser);
                    this.renderUserTabs();
                    return true;
                }
            } else {
                throw new Error(response.message || '更新用户失败');
            }
        } catch (error) {
            console.error('更新用户失败:', error);
            this.showMessage('更新用户失败: ' + error.message, 'error');
        }
        return false;
    },

    // 显示消息
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.textContent = message;
        messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        `;
        
        switch (type) {
            case 'success':
                messageEl.style.backgroundColor = '#4CAF50';
                break;
            case 'error':
                messageEl.style.backgroundColor = '#f44336';
                break;
            case 'warning':
                messageEl.style.backgroundColor = '#ff9800';
                break;
            default:
                messageEl.style.backgroundColor = '#2196F3';
        }
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 3000);
    },

    // 绑定事件
    bindEvents() {
        // 事件委托：处理动态生成的添加用户按钮
        document.addEventListener('click', (e) => {
            if (e.target.dataset.action === 'add-user' || e.target.closest('[data-action="add-user"]')) {
                e.preventDefault();
                this.addUser();
            }
        });
    }
};

// 导出到全局
window.UserManager = UserManager;




// Profile管理器
const ProfileManager = {
    currentAppUser: null,
    profileData: null,
    isOnline: false,

    async init() {
        console.log('👤 初始化Profile管理器...');
        
        // 确保 ApiClient 已加载
        if (typeof ApiClient === 'undefined') {
            console.error('❌ ApiClient 未定义，请检查脚本加载顺序');
            return;
        }
        
        // 检查后端连接
        this.isOnline = await ApiClient.testConnection();
        
        if (!this.isOnline) {
            console.error('❌ 无法连接到服务器');
            return;
        }
        
        // 获取当前登录用户
        this.currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
        
        if (!this.currentAppUser) {
            console.error('❌ 用户未登录');
            return;
        }
        
        console.log('✅ Profile管理器初始化完成，当前用户:', this.currentAppUser);
    },

    // 加载用户资料数据
    async loadProfileData() {
        try {
            console.log('📡 正在加载用户资料...');
            const response = await ApiClient.auth.getProfile(this.currentAppUser);
            
            if (response.success) {
                this.profileData = response.data;
                console.log('✅ 用户资料加载成功:', this.profileData);
                return this.profileData;
            } else {
                throw new Error(response.message || '加载用户资料失败');
            }
        } catch (error) {
            console.error('❌ 加载用户资料失败:', error);
            throw error;
        }
    },

    // 渲染Profile页面
    async renderProfilePanel() {
        console.log('🎨 开始渲染Profile页面');
        
        const contentArea = document.getElementById('contentArea');
        if (!contentArea) {
            console.error('❌ 找不到内容区域');
            return;
        }

        // 隐藏左侧边栏
        this.hideLeftSidebar();

        try {
            // 显示加载状态
            contentArea.innerHTML = `
                <div class="profile-content-panel">
                    <div class="profile-loading">
                        <div class="loading-spinner"></div>
                        <p>正在加载用户资料...</p>
                    </div>
                </div>
            `;

            // 加载用户数据
            await this.loadProfileData();

            // 渲染Profile内容
            const profileHtml = this.generateProfileHTML();
            contentArea.innerHTML = profileHtml;

            // 绑定事件
            this.bindProfileEvents();

            console.log('✅ Profile页面渲染完成');
        } catch (error) {
            console.error('❌ 渲染Profile页面失败:', error);
            
            // 显示错误状态
            contentArea.innerHTML = `
                <div class="profile-content-panel">
                    <div class="profile-error">
                        <div class="error-icon">❌</div>
                        <h3>加载失败</h3>
                        <p>${error.message}</p>
                        <button class="btn btn-primary" onclick="ProfileManager.renderProfilePanel()">重试</button>
                    </div>
                </div>
            `;
        }
    },

    // 隐藏左侧边栏
    hideLeftSidebar() {
        const leftSidebar = document.querySelector('.left-sidebar');
        const contentArea = document.querySelector('.content-area');
        
        if (leftSidebar) {
            leftSidebar.style.display = 'none';
        }
        
        if (contentArea) {
            contentArea.style.width = '100%';
            contentArea.style.marginLeft = '0';
        }
        
        console.log('🎨 已隐藏左侧边栏');
    },

    // 显示左侧边栏（当离开Profile页面时调用）
    showLeftSidebar() {
        const leftSidebar = document.querySelector('.left-sidebar');
        const contentArea = document.querySelector('.content-area');
        
        if (leftSidebar) {
            leftSidebar.style.display = '';
        }
        
        if (contentArea) {
            contentArea.style.width = '';
            contentArea.style.marginLeft = '';
        }
        
        console.log('🎨 已显示左侧边栏');
    },

    // 生成Profile页面HTML
    generateProfileHTML() {
        if (!this.profileData) {
            return '<div class="profile-error">用户数据未加载</div>';
        }

        const { username, created_at, stats } = this.profileData;
        const createdDate = new Date(created_at);
        const formattedDate = createdDate.toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        const formattedTime = createdDate.toLocaleTimeString('zh-CN', {
            hour: '2-digit',
            minute: '2-digit'
        });

        // 计算注册天数
        const daysSinceRegistration = Math.floor((new Date() - createdDate) / (1000 * 60 * 60 * 24));

        return `
            <div class="profile-content-panel">
                <div class="profile-content">
                    <div class="profile-section">
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">📊 基本信息</h4>
                            <div class="stats-list">
                                <div class="stats-item">
                                    <span class="stats-label">用户名</span>
                                    <span class="stats-value">${username}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">注册日期</span>
                                    <span class="stats-value">${formattedDate} ${formattedTime}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">使用天数</span>
                                    <span class="stats-value">${daysSinceRegistration} 天</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3 class="section-title">使用统计</h3>
                        
                        <!-- 管理成员列表 -->
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">👥 被管理成员 (${this.profileData.managed_users.length}个)</h4>
                            <div class="stats-list">
                                ${this.generateManagedUsersList()}
                            </div>
                        </div>

                        <!-- 任务统计 -->
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">📝 任务管理</h4>
                            <div class="stats-list">
                                <div class="stats-item highlight">
                                    <span class="stats-label">进行中任务</span>
                                    <span class="stats-value">${stats.active_todos || 0}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">重复任务</span>
                                    <span class="stats-value">${stats.repeat_todos || 0}</span>
                                </div>
                                <div class="stats-item">
                                    <span class="stats-label">一次性任务</span>
                                    <span class="stats-value">${stats.onetime_todos || 0}</span>
                                </div>
                                <div class="stats-item secondary">
                                    <span class="stats-label">已删除任务</span>
                                    <span class="stats-value">${stats.deleted_todos || 0}</span>
                                </div>
                                <div class="stats-item secondary">
                                    <span class="stats-label">历史任务总数</span>
                                    <span class="stats-value">${stats.total_todos || 0}</span>
                                </div>
                            </div>
                        </div>

                        <!-- 笔记统计 -->
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">📄 健康笔记 (总计${stats.total_notes || 0}个)</h4>
                            <div class="stats-list">
                                ${this.generateNotesStatsList()}
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <div class="stats-list-section">
                            <h4 class="stats-list-title">⚙️ 账户操作</h4>
                            <div class="action-buttons">
                                <button class="btn btn-success" id="refreshProfileBtn">
                                    <span class="btn-icon">🔄</span>
                                    刷新数据
                                </button>
                                <button class="btn btn-danger" id="logoutBtn">
                                    <span class="btn-icon">🚪</span>
                                    退出登录
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    },

    // 生成管理成员列表
    generateManagedUsersList() {
        if (!this.profileData.managed_users || this.profileData.managed_users.length === 0) {
            return '<div class="stats-item empty">暂无管理成员</div>';
        }

        return this.profileData.managed_users.map(user => {
            const linkStatus = user.is_linked ? '🔗已关联' : '⭕未关联';
            const linkUser = user.supervised_app_user ? ` (${user.supervised_app_user})` : '';
            
            return `
                <div class="stats-item user-item">
                    <div class="user-info">
                        <span class="user-name">${user.display_name} (${user.username})</span>
                        <span class="user-status">${linkStatus}${linkUser}</span>
                    </div>
                </div>
            `;
        }).join('');
    },

    // 生成笔记统计列表
    generateNotesStatsList() {
        if (!this.profileData.user_notes || this.profileData.user_notes.length === 0) {
            return '<div class="stats-item empty">暂无笔记数据</div>';
        }

        return this.profileData.user_notes.map(user => {
            return `
                <div class="stats-item">
                    <span class="stats-label">${user.display_name}</span>
                    <span class="stats-value">${user.notes_count}个</span>
                </div>
            `;
        }).join('');
    },

    // 绑定Profile页面事件
    bindProfileEvents() {
        // 刷新按钮
        const refreshBtn = document.getElementById('refreshProfileBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                this.renderProfilePanel();
            });
        }

        // 登出按钮
        const logoutBtn = document.getElementById('logoutBtn');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', () => {
                this.showLogoutConfirmation();
            });
        }
    },

    // 显示登出确认对话框
    showLogoutConfirmation() {
        const confirmHtml = `
            <div class="modal-overlay" id="logoutModal">
                <div class="modal-content logout-modal">
                    <div class="modal-header">
                        <h3>确认退出</h3>
                    </div>
                    <div class="modal-body">
                        <div class="logout-icon">🚪</div>
                        <p>您确定要退出登录吗？</p>
                        <p class="logout-note">退出后需要重新登录才能使用应用。</p>
                    </div>
                    <div class="modal-actions">
                        <button class="btn btn-secondary" id="cancelLogoutBtn">取消</button>
                        <button class="btn btn-danger" id="confirmLogoutBtn">确认退出</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', confirmHtml);
        
        // 绑定事件
        const modal = document.getElementById('logoutModal');
        const cancelBtn = document.getElementById('cancelLogoutBtn');
        const confirmBtn = document.getElementById('confirmLogoutBtn');
        
        // 取消按钮
        cancelBtn.addEventListener('click', () => {
            this.closeLogoutModal();
        });
        
        // 确认按钮
        confirmBtn.addEventListener('click', () => {
            this.performLogout();
        });
        
        // 点击背景关闭
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                this.closeLogoutModal();
            }
        });
    },

    // 关闭登出确认对话框
    closeLogoutModal() {
        const modal = document.getElementById('logoutModal');
        if (modal) {
            modal.remove();
        }
    },

    // 执行登出操作
    performLogout() {
        console.log('🚪 执行登出操作...');
        
        try {
            // 清除所有登录相关的localStorage数据
            localStorage.removeItem('wenting_current_app_user');
            localStorage.removeItem('wenting_login_time');
            localStorage.removeItem('wenting_current_user_id');
            localStorage.removeItem('wenting_current_module');
            
            console.log('✅ 登录数据已清除');
            
            // 关闭确认对话框
            this.closeLogoutModal();
            
            // 显示登出成功消息
            this.showLogoutMessage();
            
            // 延迟跳转到登录页面
            setTimeout(() => {
                window.location.href = 'login.html';
            }, 1500);
            
        } catch (error) {
            console.error('❌ 登出操作失败:', error);
            
            DialogUtils.showError('登出失败，请刷新页面重试', '登出错误');
        }
    },

    // 显示登出成功消息
    showLogoutMessage() {
        const messageEl = document.createElement('div');
        messageEl.className = 'logout-success-message';
        messageEl.innerHTML = `
            <div class="logout-success-content">
                <div class="success-icon">✅</div>
                <h3>退出成功</h3>
                <p>正在跳转到登录页面...</p>
            </div>
        `;
        
        document.body.appendChild(messageEl);
        
        // 3秒后自动移除消息
        setTimeout(() => {
            if (messageEl.parentNode) {
                messageEl.parentNode.removeChild(messageEl);
            }
        }, 3000);
    },

    // 获取当前用户名
    getCurrentAppUser() {
        return this.currentAppUser;
    },

    // 获取用户资料数据
    getProfileData() {
        return this.profileData;
    }
};

// 导出到全局
window.ProfileManager = ProfileManager;


// 天气管理模块
const WeatherManager = {
    weatherData: null,
    userLocation: null,
    autoUpdateTimer: null,
    locationReady: false,

    // Open-Meteo天气代码映射
    weatherCodeMap: {
        0: { condition: '晴朗', icon: '☀️' },
        1: { condition: '基本晴朗', icon: '🌤️' },
        2: { condition: '部分多云', icon: '⛅' },
        3: { condition: '阴天', icon: '☁️' },
        45: { condition: '雾', icon: '🌫️' },
        48: { condition: '冻雾', icon: '🌫️' },
        51: { condition: '细雨', icon: '🌦️' },
        53: { condition: '小雨', icon: '🌦️' },
        55: { condition: '中雨', icon: '🌧️' },
        61: { condition: '小雨', icon: '🌦️' },
        63: { condition: '中雨', icon: '🌧️' },
        65: { condition: '大雨', icon: '🌧️' },
        71: { condition: '小雪', icon: '🌨️' },
        73: { condition: '中雪', icon: '❄️' },
        75: { condition: '大雪', icon: '❄️' },
        80: { condition: '阵雨', icon: '🌦️' },
        81: { condition: '阵雨', icon: '🌦️' },
        82: { condition: '暴雨', icon: '⛈️' },
        95: { condition: '雷雨', icon: '⛈️' },
        96: { condition: '雷雨冰雹', icon: '⛈️' },
        99: { condition: '强雷雨冰雹', icon: '⛈️' }
    },

    async init() {
        console.log('WeatherManager 初始化开始 - 只使用用户实际位置');

        this.loadWeatherData();

        // 必须获取用户实际位置，不使用任何默认位置
        await this.getCurrentLocation();

        if (this.userLocation && this.locationReady) {
            console.log('✅ 用户位置获取成功，开始获取天气数据');
            this.fetchRealWeatherData();
            this.updateWeatherDisplay();
        } else {
            console.log('❌ 无法获取用户位置，天气功能不可用');
            this.showLocationError();
        }

        console.log('WeatherManager 初始化完成，用户位置:', this.userLocation);
    },

    // 清除位置缓存，强制重新获取
    clearLocationCache() {
        localStorage.removeItem('wenting_user_location');
        this.userLocation = null;
        this.locationReady = false;
        console.log('🗑️ 位置缓存已清除');
    },

    // 获取用户地理位置
    async getCurrentLocation() {
        try {
            if (!navigator.geolocation) {
                console.log('❌ 浏览器不支持地理位置，天气功能不可用');
                this.locationReady = false;
                return;
            }

            // 检查是否为HTTPS或localhost
            const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost';
            if (!isSecureContext) {
                console.log('⚠️ 非安全上下文，地理位置API不可用');
                this.locationReady = false;
                return;
            }

            console.log('🌍 请求用户地理位置权限...');
            
            // 显示位置权限请求提示
            this.showLocationPermissionPrompt();

            const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        console.log('✅ 用户授权地理位置成功');
                        this.hideLocationPermissionPrompt();
                        resolve(pos);
                    },
                    (error) => {
                        console.log('❌ 地理位置获取失败:', error.message);
                        this.hideLocationPermissionPrompt();
                        
                        if (error.code === error.PERMISSION_DENIED) {
                            console.log('用户拒绝了地理位置权限');
                        } else if (error.code === error.POSITION_UNAVAILABLE) {
                            console.log('位置信息不可用');
                        } else if (error.code === error.TIMEOUT) {
                            console.log('获取位置超时');
                        }
                        
                        // 不使用默认位置，直接失败
                        reject(error);
                    },
                    {
                        enableHighAccuracy: false, // 降低精度要求，提高成功率
                        timeout: 15000, // 增加超时时间
                        maximumAge: 600000 // 10分钟缓存
                    }
                );
            });

            // 使用用户的实际位置，不做任何地区限制
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            this.userLocation = {
                latitude: lat,
                longitude: lon,
                city: '获取中...'
            };
            this.locationReady = true;

            console.log('✅ 获取到用户实际位置:', this.userLocation);

            // 异步获取城市名称和天气数据
            this.getCityFromCoords(lat, lon).then(cityName => {
                this.userLocation.city = cityName;
                console.log('🏙️ 城市名称更新:', cityName);
                // 获取天气数据（此时城市名称已更新）
                this.fetchRealWeatherData();
            }).catch(() => {
                // 如果城市名称获取失败，仍然获取天气数据
                console.log('城市名称获取失败，使用坐标获取天气');
                this.fetchRealWeatherData();
            });

        } catch (error) {
            console.log('❌ 获取用户位置失败:', error.message);
            this.userLocation = null;
            this.locationReady = false;
        }
    },

    // 根据坐标获取城市名称
    async getCityFromCoords(lat, lon) {
        try {
            // 使用免费的反向地理编码服务获取城市名
            const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=zh`);
            if (response.ok) {
                const data = await response.json();
                const city = data.city || data.locality || data.principalSubdivision || '未知位置';
                console.log('🏙️ 获取到城市名:', city);
                return city;
            }
        } catch (error) {
            console.log('反向地理编码失败:', error);
        }

        // 如果反向地理编码失败，返回坐标
        return `${lat.toFixed(2)}°, ${lon.toFixed(2)}°`;
    },

    // 获取真实天气数据 - 渐进式获取，有多少显示多少
    async fetchRealWeatherData() {
        try {
            if (!this.userLocation || !this.locationReady) {
                console.log('❌ 没有用户位置信息，无法获取天气数据');
                this.showLocationError();
                return null;
            }

            const { latitude, longitude } = this.userLocation;

            // 尝试获取基础数据（温度、湿度、天气状况）
            let weatherData = await this.tryFetchWeatherData(latitude, longitude);
            
            if (weatherData) {
                this.updateWeather(weatherData);
                console.log('天气数据更新成功:', weatherData);
                return weatherData;
            } else {
                console.log('无法获取任何天气数据');
                return null;
            }

        } catch (error) {
            console.error('获取天气数据失败:', error);
            if (!this.userLocation || !this.locationReady) {
                this.showLocationError();
            }
            return null;
        }
    },

    // 获取天气数据 - API现在工作正常，直接获取完整数据
    async tryFetchWeatherData(latitude, longitude) {
        const cityName = this.userLocation?.city || '当前位置';
        
        try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m&timezone=auto`;
            console.log('正在获取天气数据...', url);
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`API请求失败: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('✅ 获取到完整天气数据:', data);
            return this.convertApiData(data, cityName);
            
        } catch (error) {
            console.log('❌ 天气数据获取失败:', error.message);
            return null;
        }
    },

    // 转换API数据格式
    convertApiData(apiData, cityName) {
        const current = apiData.current;
        const weatherCode = current.weather_code;
        const weatherInfo = this.weatherCodeMap[weatherCode] || { condition: '未知', icon: '❓' };

        return {
            location: cityName,
            icon: weatherInfo.icon,
            condition: weatherInfo.condition,
            temperature: Math.round(current.temperature_2m) + '°C',
            wind: {
                level: this.convertWindSpeed(current.wind_speed_10m),
                label: '风力'
            },
            humidity: {
                value: Math.round(current.relative_humidity_2m) + '%',
                label: '湿度'
            },
            lastUpdated: new Date().toISOString(),
            isError: false
        };
    },

    // 转换风速为等级
    convertWindSpeed(windSpeedKmh) {
        if (windSpeedKmh < 6) return '1级';
        if (windSpeedKmh < 12) return '2级';
        if (windSpeedKmh < 20) return '3级';
        if (windSpeedKmh < 29) return '4级';
        if (windSpeedKmh < 39) return '5级';
        if (windSpeedKmh < 50) return '6级';
        if (windSpeedKmh < 62) return '7级';
        if (windSpeedKmh < 75) return '8级';
        if (windSpeedKmh < 89) return '9级';
        if (windSpeedKmh < 103) return '10级';
        if (windSpeedKmh < 118) return '11级';
        return '12级';
    },



    // 显示位置权限请求提示
    showLocationPermissionPrompt() {
        const locationElement = Utils.$('.weather-location');
        if (locationElement) {
            locationElement.textContent = '请求位置权限...';
            locationElement.className = 'weather-location requesting';
            locationElement.title = '正在请求地理位置权限，请允许访问';
        }
    },

    // 隐藏位置权限请求提示
    hideLocationPermissionPrompt() {
        // 提示会在后续的updateWeatherDisplay中被更新
    },

    // 显示位置权限被拒绝的消息
    showLocationDeniedMessage() {
        // 显示一个临时提示消息
        this.showTemporaryMessage('位置权限被拒绝，点击位置区域可重新请求', 'warning');
    },

    // 请求位置权限
    async requestLocationPermission() {
        console.log('🌍 用户主动请求位置权限...');
        
        // 显示位置权限说明对话框
        this.showLocationPermissionDialog();
    },

    // 显示位置权限说明对话框
    showLocationPermissionDialog() {
        const modalHtml = `
            <div class="modal-overlay" id="locationPermissionModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>📍 位置权限请求</h3>
                        <button class="modal-close" onclick="WeatherManager.closeLocationPermissionDialog()">×</button>
                    </div>
                    <div class="location-permission-content">
                        <div class="permission-explanation">
                            <p>🌤️ 天气功能需要获取您的地理位置来提供准确的天气信息。</p>
                            <p>📱 点击"获取位置"后，浏览器会询问您是否允许访问位置信息。</p>
                            <p>🔒 您的位置信息仅用于获取天气数据，不会被存储或分享。</p>
                        </div>
                        <div class="permission-actions">
                            <button class="permission-btn allow" onclick="WeatherManager.startLocationRequest()">
                                📍 获取位置
                            </button>
                            <button class="permission-btn cancel" onclick="WeatherManager.closeLocationPermissionDialog()">
                                取消
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    },

    // 关闭位置权限对话框
    closeLocationPermissionDialog() {
        const modal = document.getElementById('locationPermissionModal');
        if (modal) {
            modal.remove();
        }
    },

    // 开始位置请求
    async startLocationRequest() {
        // 关闭对话框
        this.closeLocationPermissionDialog();
        
        // 显示请求中状态
        this.showLocationPermissionPrompt();
        
        try {
            // 重新获取位置
            await this.getCurrentLocation();
            
            if (this.userLocation && this.locationReady) {
                console.log('✅ 位置权限获取成功');
                this.fetchRealWeatherData();
                this.updateWeatherDisplay();
                this.showTemporaryMessage('位置权限获取成功！', 'success');
            }
        } catch (error) {
            console.log('❌ 位置权限请求失败:', error);
            this.showLocationError();
            this.showTemporaryMessage('位置权限被拒绝，请在浏览器设置中允许位置访问', 'error');
        }
    },

    // 显示临时消息
    showTemporaryMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.className = `weather-message weather-message-${type}`;
        messageEl.textContent = message;
        let backgroundColor = '#2196F3'; // 默认蓝色
        if (type === 'warning') backgroundColor = '#ff9800';
        if (type === 'success') backgroundColor = '#4CAF50';
        if (type === 'error') backgroundColor = '#f44336';
        
        messageEl.style.cssText = `
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: ${backgroundColor};
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10001;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        
        document.body.appendChild(messageEl);
        
        // 3秒后自动移除
        setTimeout(() => {
            if (messageEl.parentNode) {
                messageEl.style.opacity = '0';
                messageEl.style.transition = 'opacity 0.3s ease';
                setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 300);
            }
        }, 3000);
    },

    // 显示位置错误信息
    showLocationError() {
        console.log('显示位置权限错误信息');
        const errorData = {
            location: '位置未授权',
            icon: '❌',
            condition: '需要位置权限',
            temperature: '--°C',
            wind: {
                level: '--',
                label: '风力'
            },
            humidity: {
                value: '--%',
                label: '湿度'
            },
            lastUpdated: new Date().toISOString(),
            isError: true
        };

        this.updateWeather(errorData);

        // 直接更新位置显示，并添加点击事件
        const locationElement = Utils.$('.weather-location');
        if (locationElement) {
            locationElement.textContent = '点击授权位置';
            locationElement.className = 'weather-location error clickable';
            locationElement.title = '点击请求地理位置权限';
            
            // 添加点击事件来请求位置权限
            locationElement.style.cursor = 'pointer';
            locationElement.onclick = () => {
                this.requestLocationPermission();
            };
        }
    },

    // 加载天气数据
    loadWeatherData() {
        const savedWeather = localStorage.getItem('wenting_weather');
        if (savedWeather) {
            this.weatherData = JSON.parse(savedWeather);
            // 检查数据是否过期（超过30分钟）
            if (this.weatherData.lastUpdated) {
                const lastUpdate = new Date(this.weatherData.lastUpdated);
                const now = new Date();
                const diffMinutes = (now - lastUpdate) / (1000 * 60);

                if (diffMinutes > 30) {
                    console.log('天气数据已过期，将重新获取');
                    this.fetchRealWeatherData();
                }
            }
        } else {
            this.weatherData = Utils.deepClone(APP_CONFIG.weather);
        }
    },

    // 保存天气数据
    saveWeatherData() {
        localStorage.setItem('wenting_weather', JSON.stringify(this.weatherData));
    },

    // 更新天气显示（主入口）
    updateWeatherDisplay() {
        console.log('🔄 updateWeatherDisplay 被调用');
        console.log('更新天气显示，数据:', this.weatherData);
        
        // 检查天气数据
        if (!this._validateWeatherData()) {
            return;
        }

        // 获取DOM元素
        const elements = this._getWeatherElements();
        
        // 更新各个部分
        this._updateBasicWeatherInfo(elements);
        this._updateWindInfo(elements);
        this._updateHumidityInfo(elements);
        this._updateLocationInfo(elements);
    },

    // 验证天气数据
    _validateWeatherData() {
        if (!this.weatherData) {
            console.log('没有天气数据');
            if (!this.userLocation || !this.locationReady) {
                this.showLocationError();
            }
            return false;
        }
        return true;
    },

    // 获取天气相关DOM元素
    _getWeatherElements() {
        const elements = {
            icon: Utils.$('.weather-icon'),
            condition: Utils.$('.weather-condition'),
            temp: Utils.$('.weather-temp'),
            windValue: Utils.$('.weather-wind-value'),
            windLabel: Utils.$('.weather-wind-label'),
            humidityValue: Utils.$('.weather-humidity-value'),
            humidityLabel: Utils.$('.weather-humidity-label'),
            location: Utils.$('.weather-location')
        };
        
        console.log('🔍 调试：location元素:', elements.location);
        console.log('🔍 调试：weatherData.location:', this.weatherData.location);
        console.log('🔍 调试：userLocation:', this.userLocation);
        console.log('🔍 调试：locationReady:', this.locationReady);
        
        return elements;
    },

    // 更新基础天气信息
    _updateBasicWeatherInfo(elements) {
        if (elements.icon) {
            elements.icon.textContent = this.weatherData.icon;
        }

        if (elements.condition) {
            elements.condition.textContent = this.weatherData.condition;
            // 如果是备用数据，添加提示
            if (this.weatherData.isFallback) {
                elements.condition.title = '网络连接问题，显示备用数据';
            }
        }

        if (elements.temp) {
            elements.temp.textContent = this.weatherData.temperature;
        }
    },

    // 更新风力信息
    _updateWindInfo(elements) {
        if (elements.windValue) {
            elements.windValue.textContent = this.weatherData.wind.level;
        }

        if (elements.windLabel) {
            elements.windLabel.textContent = this.weatherData.wind.label;
        }
    },

    // 更新湿度信息
    _updateHumidityInfo(elements) {
        if (elements.humidityValue) {
            elements.humidityValue.textContent = this.weatherData.humidity.value;
        }

        if (elements.humidityLabel) {
            elements.humidityLabel.textContent = this.weatherData.humidity.label;
        }
    },

    // 更新位置信息
    _updateLocationInfo(elements) {
        console.log('🔍 开始更新位置显示');
        if (!elements.location) {
            console.log('❌ 未找到location元素');
            return;
        }

        console.log('✅ 找到location元素');
        
        if (this.weatherData.isError) {
            this._setLocationError(elements.location);
        } else if (this.weatherData.location) {
            this._setLocationFromWeatherData(elements.location);
        } else if (this.userLocation && this.locationReady) {
            this._setLocationFromUserData(elements.location);
        } else {
            this._setLocationLoading(elements.location);
        }
    },

    // 设置位置错误状态
    _setLocationError(locationElement) {
        console.log('❌ 显示错误状态');
        locationElement.textContent = '位置未授权';
        locationElement.className = 'weather-location error';
    },

    // 使用天气数据设置位置
    _setLocationFromWeatherData(locationElement) {
        console.log('🏙️ 使用天气数据中的位置:', this.weatherData.location);
        locationElement.textContent = this.weatherData.location;
        locationElement.className = 'weather-location';
        
        // 设置提示信息
        if (this.userLocation && this.userLocation.latitude && this.userLocation.longitude) {
            locationElement.title = `纬度: ${this.userLocation.latitude.toFixed(4)}, 经度: ${this.userLocation.longitude.toFixed(4)}`;
        } else {
            locationElement.title = '基于天气数据的位置';
        }
        console.log('✅ 位置已更新为:', locationElement.textContent);
    },

    // 使用用户数据设置位置
    _setLocationFromUserData(locationElement) {
        console.log('📍 使用用户位置数据:', this.userLocation.city);
        locationElement.textContent = this.userLocation.city || '当前位置';
        locationElement.className = 'weather-location';
        locationElement.title = `纬度: ${this.userLocation.latitude.toFixed(4)}, 经度: ${this.userLocation.longitude.toFixed(4)}`;
    },

    // 设置定位中状态
    _setLocationLoading(locationElement) {
        console.log('⏳ 显示定位中状态');
        locationElement.textContent = '定位中...';
        locationElement.className = 'weather-location loading';
    },

    // 更新天气数据
    updateWeather(newWeatherData) {
        this.weatherData = { ...this.weatherData, ...newWeatherData };
        this.saveWeatherData();
        this.updateWeatherDisplay();
    },

    // 手动刷新天气
    async refreshWeather() {
        console.log('手动刷新天气数据...');

        // 添加加载状态
        const weatherBar = Utils.$('.weather-bar');
        const weatherIcon = Utils.$('.weather-icon');

        if (weatherBar) {
            weatherBar.classList.add('loading');
        }
        if (weatherIcon) {
            weatherIcon.classList.add('loading');
        }

        try {
            await this.fetchRealWeatherData();
        } catch (error) {
            console.error('刷新天气失败:', error);
        } finally {
            // 移除加载状态
            setTimeout(() => {
                if (weatherBar) {
                    weatherBar.classList.remove('loading');
                }
                if (weatherIcon) {
                    weatherIcon.classList.remove('loading');
                }
            }, 300); // 延迟一下让用户看到反馈
        }
    },

    // 定时更新天气
    startAutoUpdate(interval = 30 * 60 * 1000) {
        console.log('启动天气自动更新，间隔:', interval / 60000, '分钟');

        // 清除之前的定时器，防止重复创建
        if (this.autoUpdateTimer) {
            clearInterval(this.autoUpdateTimer);
        }

        this.autoUpdateTimer = setInterval(() => {
            console.log('自动更新天气数据...');
            this.fetchRealWeatherData();
        }, interval);
    },

    // 停止自动更新
    stopAutoUpdate() {
        if (this.autoUpdateTimer) {
            clearInterval(this.autoUpdateTimer);
            this.autoUpdateTimer = null;
            console.log('天气自动更新已停止');
        }
    },

    // 根据天气代码获取天气信息（保持兼容性）
    getWeatherIcon(condition) {
        const iconMap = {
            '晴朗': '☀️',
            '多云': '⛅',
            '阴天': '☁️',
            '小雨': '🌦️',
            '大雨': '🌧️',
            '雷雨': '⛈️',
            '雪': '❄️',
            '雾': '🌫️'
        };

        return iconMap[condition] || '☀️';
    },


};

// 暴露WeatherManager到全局作用域，供其他模块使用
window.WeatherManager = WeatherManager;



// 主应用程序
const App = {
    // 防重复调用标志
    _refreshingAfterLink: false,
    
    init() {
        // 等待DOM加载完成
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                this.initializeApp();
            });
        } else {
            this.initializeApp();
        }
    },

    // 初始化应用
    async initializeApp() {
        console.log('雯婷应用启动中...');
        
        try {
            // 按顺序初始化各个模块
            await this.initializeModules();
            
            // 绑定全局事件
            this.bindGlobalEvents();
            
            console.log('雯婷应用启动完成');
        } catch (error) {
            console.error('应用初始化失败:', error);
        }
    },

    // 初始化模块
    async initializeModules() {
        // 首先初始化设备管理器
        if (window.DeviceManager) {
            await DeviceManager.init();
        }
        
        // 确保 ApiClient 已加载
        if (typeof window.ApiClient === 'undefined') {
            console.error('❌ ApiClient 未加载，请检查脚本加载顺序');
            return;
        }
        
        // 初始化全局用户状态管理器
        if (window.GlobalUserState) {
            GlobalUserState.init();
        }
        
        // 初始化日期管理器
        DateManager.init();
        
        // 初始化天气管理器（等待地理位置获取完成）
        if (window.WeatherManager) {
            await WeatherManager.init();
            // 启动天气自动更新（30分钟间隔）
            WeatherManager.startAutoUpdate();
        } else {
            console.error('❌ WeatherManager未加载');
        }
        
        // 初始化用户管理器（异步，需要等待完成）
        await UserManager.init();
        
        // 初始化TODO管理器（最后初始化，因为它依赖用户管理器）
        await TodoManager.init();
        
        // 初始化Notes管理器
        if (window.NotesManager) {
            await NotesManager.init();
        }
        
        // 初始化Profile管理器
        if (window.ProfileManager) {
            await ProfileManager.init();
        }
        
        // 设置默认模块为todo
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('todo');
            // 绑定全局用户选择器事件
            GlobalUserState.bindUserSelectorEvents();
        }
        
        // 初始化WebSocket连接
        if (window.WebSocketClient) {
            try {
                await WebSocketClient.init();
                console.log('✅ WebSocket连接已建立');
                
                // 🔥 关键修复：确保注册消息在用户信息准备好后发送
                this.ensureWebSocketRegistration();
            } catch (error) {
                console.error('⚠️ WebSocket连接失败，但应用将继续使用HTTP模式:', error);
            }
        }
        
        // 完成加载，显示应用界面
        if (window.LoadingManager) {
            LoadingManager.completeLoading();
            
            // 监听应用容器显示事件，然后初始化用户界面
            this.waitForAppContainerVisible();
        } else {
            console.log('⚠️ LoadingManager不存在，直接初始化用户界面');
            // 延迟一下确保DOM渲染完成
            setTimeout(() => {
                this.initializeUserInterface();
            }, 100);
        }
    },

    // 等待应用容器显示
    waitForAppContainerVisible() {
        console.log('⏳ 等待应用容器显示...');
        
        const checkAppContainer = () => {
            const appContainer = document.getElementById('appContainer');
            const loadingScreen = document.getElementById('loadingScreen');
            
            console.log('🔍 检查应用容器状态:');
            console.log('  - appContainer存在:', !!appContainer);
            console.log('  - appContainer显示:', appContainer?.style.display !== 'none');
            console.log('  - loadingScreen存在:', !!loadingScreen);
            console.log('  - loadingScreen显示:', loadingScreen?.style.display !== 'none');
            
            if (appContainer && appContainer.style.display !== 'none' && 
                (!loadingScreen || loadingScreen.style.display === 'none')) {
                console.log('✅ 应用容器已显示，开始初始化用户界面');
                this.initializeUserInterface();
            } else {
                console.log('⏳ 应用容器还未显示，继续等待...');
                setTimeout(checkAppContainer, 100);
            }
        };
        
        // 开始检查
        setTimeout(checkAppContainer, 500); // 给LoadingManager一些时间开始动画
    },

    // 初始化用户界面
    async initializeUserInterface() {
        console.log('🎨 开始初始化用户界面');
        console.log('🔍 调试信息:');
        console.log('  - TodoManager存在:', !!window.TodoManager);
        console.log('  - TodoManager.currentUser:', window.TodoManager?.currentUser);
        console.log('  - UserManager存在:', !!window.UserManager);
        console.log('  - UserManager.users数量:', window.UserManager?.users?.length || 0);
        console.log('  - GlobalUserState存在:', !!window.GlobalUserState);
        console.log('  - GlobalUserState.currentUserId:', window.GlobalUserState?.currentUserId);
        console.log('  - 当前模块:', window.GlobalUserState?.getCurrentModule());
        
        if (!window.TodoManager) {
            console.error('❌ TodoManager未初始化');
            return;
        }

        // 检查是否有用户数据存在
        if (window.UserManager && window.UserManager.users && window.UserManager.users.length > 0) {
            // 确保当前用户已设置
            if (!TodoManager.currentUser) {
                console.log('⚠️ 当前用户未设置，重新设置默认用户');
                TodoManager.setDefaultUser();
            }
            
            console.log('🎯 当前用户ID:', TodoManager.currentUser);
            console.log('🎯 当前模块:', GlobalUserState ? GlobalUserState.getCurrentModule() : 'unknown');
            
            // 首先渲染用户标签
            if (window.UserManager) {
                console.log('🔄 开始渲染用户标签...');
                window.UserManager.renderUserTabs();
                console.log('✅ 用户标签渲染完成');
            }
            
            // 然后更新用户选择器UI
            if (window.GlobalUserState) {
                console.log('🔄 开始更新用户选择器UI...');
                GlobalUserState.updateUserSelectorUI();
                console.log('✅ 用户选择器UI更新完成');
            }
            
            // 最后渲染TODO内容（如果当前模块是todo）
            if (window.GlobalUserState && GlobalUserState.getCurrentModule() === 'todo') {
                console.log('🔄 开始加载并渲染TODO内容');
                console.log('🔍 TODO数据调试:');
                console.log('  - TodoManager.todos:', TodoManager.todos);
                console.log('  - 当前用户的TODO数据:', TodoManager.todos[TodoManager.currentUser]);
                
                // 通过触发用户切换事件来加载TODO，确保与用户点击切换的行为一致
                if (TodoManager.currentUser) {
                    console.log('🎯 通过全局状态触发用户切换事件来初始化TODO显示');
                    
                    // 临时设置为null，确保setCurrentUser会触发事件
                    const targetUserId = TodoManager.currentUser;
                    GlobalUserState.currentUserId = null;
                    GlobalUserState.setCurrentUser(targetUserId);
                    
                    console.log('✅ 强制触发用户切换事件完成');
                } else {
                    console.warn('⚠️ 当前用户未设置，无法加载TODO');
                }
            } else {
                console.log('⚠️ 当前模块不是todo，跳过TODO渲染');
            }
        } else {
            console.log('🎨 没有用户，显示空用户状态');
            TodoManager.showEmptyUserState();
        }
    },

    // 绑定全局事件
    bindGlobalEvents() {
        // 绑定添加用户按钮事件
        const addUserBtn = document.getElementById('addUserBtn');
        if (addUserBtn) {
            addUserBtn.addEventListener('click', () => {
                if (window.UserManager && typeof UserManager.addUser === 'function') {
                    UserManager.addUser();
                } else {
                    console.error('UserManager.addUser 方法不可用');
                }
            });
        }
        
        // 底部导航点击效果 - 使用事件委托确保正确绑定
        document.addEventListener('click', (e) => {
            const navItem = e.target.closest('.nav-item');
            if (navItem) {
                const label = navItem.querySelector('.nav-label')?.textContent;
                console.log('导航到：', label);
                
                // 显示进度条（针对Todo和Notes页面切换）
                if ((label === 'Todo' || label === 'Notes') && window.DateManager) {
                    window.DateManager.showLoadingProgress();
                }
                
                // 这里可以添加路由逻辑
                this.handleNavigation(label);
            }
        });

        // 天气栏点击处理
        const weatherBar = Utils.$('.weather-bar');
        if (weatherBar) {
            weatherBar.addEventListener('click', (e) => {
                if (!window.WeatherManager) {
                    console.error('❌ WeatherManager未加载');
                    return;
                }
                
                // 如果点击的是位置区域且位置未授权，请求位置权限
                const locationElement = e.target.closest('.weather-location');
                if (locationElement && locationElement.classList.contains('error')) {
                    console.log('用户点击位置未授权区域，请求位置权限');
                    WeatherManager.requestLocationPermission();
                } else {
                    console.log('用户点击天气栏，刷新天气数据');
                    WeatherManager.refreshWeather();
                }
            });
            
            // 添加悬停提示
            weatherBar.style.cursor = 'pointer';
            weatherBar.title = '点击刷新天气数据，位置未授权时点击可请求权限';
        }

        // 全局错误处理
        window.addEventListener('error', (event) => {
            console.error('全局错误:', event.error);
        });

        // 页面可见性变化处理
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // 页面变为可见时，更新当前时间和天气
                if (window.DateManager) {
                    DateManager.updateCurrentDate();
                }
                
                // 检查天气数据是否需要更新
                if (window.WeatherManager && WeatherManager.weatherData?.lastUpdated) {
                    const lastUpdate = new Date(WeatherManager.weatherData.lastUpdated);
                    const now = new Date();
                    const diffMinutes = (now - lastUpdate) / (1000 * 60);
                    
                    // 如果超过15分钟，刷新天气
                    if (diffMinutes > 15) {
                        console.log('页面重新激活，刷新天气数据');
                        WeatherManager.fetchRealWeatherData();
                    }
                }
            }
        });

        // 在线/离线状态处理
        window.addEventListener('online', () => {
            console.log('网络连接恢复，刷新天气数据');
            if (window.WeatherManager) {
                WeatherManager.fetchRealWeatherData();
            }
        });

        window.addEventListener('offline', () => {
            console.log('网络连接断开，将使用缓存数据');
        });

        // 设备ID更新处理
        window.addEventListener('deviceIdUpdated', (event) => {
            console.log('🔄 设备ID已更新:', event.detail.deviceId);
            
            // 延迟重新加载用户数据，让设备ID生效
            setTimeout(async () => {
                try {
                    if (window.UserManager && typeof UserManager.loadUsers === 'function') {
                        console.log('🔄 重新加载用户数据...');
                        await UserManager.loadUsers();
                        console.log('✅ 用户数据重新加载完成');
                    }
                } catch (error) {
                    console.error('❌ 重新加载用户数据失败:', error);
                }
            }, 1000);
        });

        // WebSocket消息处理将在WebSocketClient初始化后处理
        // 这些处理器现在通过WebSocketClient的handleMessage方法处理
        console.log('🔌 Link功能WebSocket处理器已准备');
    },

    // 处理导航
    handleNavigation(page) {
        switch (page) {
            case 'Todo':
                // 显示Todo页面
                this.showTodoPage();
                break;
            case 'Notes':
                // 显示Notes页面
                this.showNotesPage();
                break;
            case 'Link':
                // 显示Link页面（在SPA内切换）
                this.showLinkPage();
                break;
            case 'Profile':
                // 显示Profile页面
                this.showProfilePage();
                break;
            default:
                console.log('未知导航目标:', page);
        }
    },

    // 显示Todo页面
    async showTodoPage() {
        console.log('切换到Todo页面');
        
        // 恢复左侧边栏显示
        if (window.ProfileManager) {
            ProfileManager.showLeftSidebar();
        }
        
        // 设置全局状态为todo模块
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('todo');
        }
        
        if (window.TodoManager) {
            const currentUser = GlobalUserState ? GlobalUserState.getCurrentUser() : TodoManager.currentUser;
            console.log('渲染TODO页面，用户:', currentUser);
            
            // 检查用户是否存在于UserManager中
            if (currentUser && window.UserManager && window.UserManager.users) {
                const userExists = UserManager.users.find(u => u.id === currentUser);
                if (!userExists) {
                    console.log('⚠️ 当前用户不在用户列表中，可能是新关联的用户，重新加载用户数据...');
                    try {
                        await UserManager.loadUsersFromAPI();
                        console.log('✅ 用户数据重新加载完成');
                    } catch (error) {
                        console.error('❌ 重新加载用户数据失败:', error);
                    }
                }
            }
            
            // 确保TODO数据已加载
            if (currentUser && (!TodoManager.todos[currentUser] || TodoManager.todos[currentUser].length === 0)) {
                console.log('🔄 TODO数据未加载，正在加载...');
                try {
                    await TodoManager.loadTodosFromAPI();
                    console.log('✅ TODO数据加载完成');
                } catch (error) {
                    console.error('❌ TODO数据加载失败:', error);
                }
            }
            
            TodoManager.renderTodoPanel(currentUser);
            
            // 隐藏进度条 - 延长显示时间让用户看到效果
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 600);
        } else {
            console.error('TodoManager未初始化');
            // 即使出错也隐藏进度条
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 300);
        }
    },

    // 显示Notes页面（优化版，避免重复初始化）
    async showNotesPage() {
        console.log('切换到Notes页面');
        
        try {
            this._initializeNotesPageUI();
            
            if (window.NotesManager) {
                await this._handleNotesManagerAvailable();
            } else {
                this._showNotesPlaceholder();
            }
        } catch (error) {
            this._handleNotesPageError(error);
        }
    },

    // 初始化Notes页面UI
    _initializeNotesPageUI() {
        if (window.ProfileManager) {
            ProfileManager.showLeftSidebar();
        }
        
        if (window.GlobalUserState) {
            GlobalUserState.setCurrentModule('notes');
        }
    },

    // 处理NotesManager可用的情况
    async _handleNotesManagerAvailable() {
        await this._ensureNotesManagerOnline();
        
        const currentUser = this._getCurrentUserForNotes();
        console.log('切换到Notes页面，当前用户:', currentUser);
        
        await this._ensureUserDataValid(currentUser);
        await this._ensureNotesDataLoaded(currentUser);
        
        NotesManager.renderNotesPanel(currentUser);
        this._hideLoadingProgressDelayed(600);
    },

    // 确保NotesManager在线
    async _ensureNotesManagerOnline() {
        if (NotesManager.isOnline === false) {
            NotesManager.isOnline = await ApiClient.testConnection();
        }
    },

    // 获取当前用户
    _getCurrentUserForNotes() {
        return GlobalUserState ? 
               GlobalUserState.getCurrentUser() : 
               NotesManager.currentUser;
    },

    // 确保用户数据有效
    async _ensureUserDataValid(currentUser) {
        if (currentUser && window.UserManager && window.UserManager.users) {
            const userExists = UserManager.users.find(u => u.id === currentUser);
            if (!userExists) {
                await this._reloadUserData();
            }
        }
    },

    // 重新加载用户数据
    async _reloadUserData() {
        console.log('⚠️ 当前用户不在用户列表中，可能是新关联的用户，重新加载用户数据...');
        try {
            await UserManager.loadUsersFromAPI();
            console.log('✅ 用户数据重新加载完成');
        } catch (error) {
            console.error('❌ 重新加载用户数据失败:', error);
        }
    },

    // 确保Notes数据已加载
    async _ensureNotesDataLoaded(currentUser) {
        if (this._shouldLoadNotesData(currentUser)) {
            await this._loadNotesData();
        }
    },

    // 检查是否需要加载Notes数据
    _shouldLoadNotesData(currentUser) {
        return currentUser && 
               (!NotesManager.notes[currentUser] || 
                NotesManager.notes[currentUser].length === 0);
    },

    // 加载Notes数据
    async _loadNotesData() {
        console.log('🔄 Notes数据未加载，正在加载...');
        try {
            await NotesManager.loadNotesFromAPI();
            console.log('✅ Notes数据加载完成');
        } catch (error) {
            console.error('❌ Notes数据加载失败:', error);
        }
    },

    // 显示Notes占位符
    _showNotesPlaceholder() {
        const contentArea = Utils.$('#contentArea');
        if (contentArea) {
            contentArea.innerHTML = `
                <div class="notes-content-panel">
                    <div class="notes-placeholder">
                        <h3>Notes 功能</h3>
                        <p>正在加载笔记功能...</p>
                    </div>
                </div>
            `;
        }
        this._hideLoadingProgressDelayed(600);
    },

    // 处理Notes页面错误
    _handleNotesPageError(error) {
        console.error('加载Notes页面失败:', error);
        this._hideLoadingProgressDelayed(300);
    },

    // 延迟隐藏加载进度
    _hideLoadingProgressDelayed(delay) {
        setTimeout(() => {
            if (window.DateManager) window.DateManager.hideLoadingProgress();
        }, delay);
    },

    // 显示Profile页面
    async showProfilePage() {
        console.log('切换到Profile页面');
        
        try {
            // 设置全局状态为profile模块
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentModule('profile');
            }
            
            if (window.ProfileManager) {
                // 检查是否已初始化
                if (!ProfileManager.currentAppUser) {
                    console.log('首次加载Profile，开始初始化');
                    await ProfileManager.init();
                }
                
                // 渲染Profile页面
                await ProfileManager.renderProfilePanel();
                
                // 延长显示时间让用户看到效果
                setTimeout(() => {
                    if (window.DateManager) window.DateManager.hideLoadingProgress();
                }, 600);
            } else {
                console.error('❌ ProfileManager未加载');
                
                // 显示错误占位内容
                const contentArea = document.getElementById('contentArea');
                if (contentArea) {
                    contentArea.innerHTML = `
                        <div class="profile-content-panel">
                            <div class="profile-error">
                                <div class="error-icon">❌</div>
                                <h3>加载失败</h3>
                                <p>Profile功能未正确加载</p>
                            </div>
                        </div>
                    `;
                }
                
                // 即使出错也要隐藏进度条
                setTimeout(() => {
                    if (window.DateManager) window.DateManager.hideLoadingProgress();
                }, 300);
            }
        } catch (error) {
            console.error('加载Profile页面失败:', error);
            
            // 显示错误状态
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="profile-content-panel">
                        <div class="profile-error">
                            <div class="error-icon">❌</div>
                            <h3>加载失败</h3>
                            <p>${error.message}</p>
                            <button class="btn btn-primary" onclick="App.showProfilePage()">重试</button>
                        </div>
                    </div>
                `;
            }
            
            // 即使出错也要隐藏进度条
            setTimeout(() => {
                if (window.DateManager) window.DateManager.hideLoadingProgress();
            }, 300);
        }
    },

    // 显示Link页面
    async showLinkPage() {
        console.log('切换到Link页面');
        
        try {
            // 恢复左侧边栏显示
            if (window.ProfileManager) {
                ProfileManager.showLeftSidebar();
            }
            
            // 设置全局状态为link模块
            if (window.GlobalUserState) {
                GlobalUserState.setCurrentModule('link');
            }
            
            // 创建Link页面的内容
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="content-panel">
                        <!-- Link状态显示区 -->
                        <div class="link-status-area" id="linkStatusArea">
                            <div class="link-status-loading">
                                <div class="loading-spinner"></div>
                                <p>正在检查关联状态...</p>
                            </div>
                        </div>
                        
                        <!-- Link内容区域 -->
                        <div class="link-content-area">
                            <!-- 用户信息显示区 -->
                            <div class="user-info-display" id="userInfoDisplay">
                                <div class="empty-state">
                                    <div class="empty-icon">👤</div>
                                    <p>请从左侧选择一个用户</p>
                                    <p class="empty-subtitle">查看用户的详细信息</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                console.log('✅ Link页面HTML已创建');
            }
            
            // 初始化Link页面的事件监听
            this.initializeLinkPageEvents();
            
            // 检查并显示Link连接状态
            setTimeout(async () => {
                await this.displayLinkConnectionStatus();
                this.displayDefaultUserInLink();
            }, 100);
            
            console.log('✅ Link页面加载完成');
            
        } catch (error) {
            console.error('加载Link页面失败:', error);
            
            // 显示错误状态
            const contentArea = document.getElementById('contentArea');
            if (contentArea) {
                contentArea.innerHTML = `
                    <div class="content-panel">
                        <div class="link-error">
                            <div class="error-icon">❌</div>
                            <h3>加载失败</h3>
                            <p>${error.message}</p>
                            <button class="btn btn-primary" onclick="App.showLinkPage()">重试</button>
                        </div>
                    </div>
                `;
            }
        }
    },
    
    // 初始化Link页面事件监听
    initializeLinkPageEvents() {
        console.log('🎨 初始化Link页面事件监听...');
        
        // 监听用户选择事件
        const handleUserSelected = (event) => {
            const selectedUser = event.detail;
            console.log('👤 [SPA Link] 接收到用户选择事件:', selectedUser);
            this.displayUserInfoInLink(selectedUser);
        };
        
        // 移除旧的监听器（避免重复绑定）
        document.removeEventListener('userSelected', handleUserSelected);
        // 添加新的监听器
        document.addEventListener('userSelected', handleUserSelected);
        
        console.log('✅ Link页面事件监听初始化完成');
    },
    
    // 显示Link连接状态
    async displayLinkConnectionStatus() {
        try {
            console.log('🔍 [Link] 检查连接状态...');
            
            const linkStatusArea = document.getElementById('linkStatusArea');
            if (!linkStatusArea) return;
            
            const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            if (!currentAppUser) {
                linkStatusArea.innerHTML = `
                    <div class="link-status-error">
                        <div class="status-icon">❌</div>
                        <h3>未登录</h3>
                        <p>请先登录后查看关联状态</p>
                    </div>
                `;
                return;
            }
            
            // 检查用户的关联关系
            let response;
            try {
                if (window.WebSocketClient && window.WebSocketClient.isConnected) {
                    console.log('🔍 [Link] 使用WebSocket检查连接状态...');
                    response = await window.WebSocketClient.links.checkLinkStatus(currentAppUser);
                } else {
                    console.log('🔍 [Link] WebSocket未连接，使用HTTP模式...');
                    // HTTP降级模式
                    const apiResponse = await fetch(`/api/links/user/${currentAppUser}/status`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
                        }
                    });
                    
                    if (!apiResponse.ok) {
                        throw new Error(`HTTP ${apiResponse.status}: ${apiResponse.statusText}`);
                    }
                    
                    const data = await apiResponse.json();
                    response = { success: true, data: data };
                }
            } catch (error) {
                console.error('❌ [Link] 检查连接状态失败:', error);
                
                // 显示更详细的错误信息
                let errorMessage = '无法获取关联状态';
                if (error.message.includes('请求超时')) {
                    errorMessage = 'WebSocket请求超时，请检查网络连接';
                } else if (error.message.includes('HTTP')) {
                    errorMessage = `服务器错误: ${error.message}`;
                }
                
                linkStatusArea.innerHTML = `
                    <div class="link-status-error">
                        <div class="status-icon">⚠️</div>
                        <h3>检查失败</h3>
                        <p>${errorMessage}</p>
                        <button class="btn btn-secondary" onclick="App.displayLinkConnectionStatus()" style="margin-top: 10px;">重试</button>
                    </div>
                `;
                return;
            }
            
            if (response.success && response.data.links && response.data.links.length > 0) {
                // 有关联关系，显示连接状态
                const links = response.data.links;
                console.log('✅ [Link] 找到关联关系:', links);
                
                linkStatusArea.innerHTML = `
                    <div class="link-status-connected">
                        <div class="status-icon">🔗</div>
                        <h3>已建立关联</h3>
                        <div class="link-connections">
                            ${links.map(link => `
                                <div class="link-connection-item">
                                    <div class="connection-info">
                                        <span class="connection-partner">${link.manager_username || link.linked_username}</span>
                                        <span class="connection-user">${link.username}</span>
                                    </div>
                                    <div class="connection-status">
                                        <span class="status-badge active">活跃</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <p class="link-description">您可以在左侧看到关联用户，点击Todo或Notes查看共享数据</p>
                    </div>
                `;
            } else {
                // 没有关联关系
                linkStatusArea.innerHTML = `
                    <div class="link-status-empty">
                        <div class="status-icon">🔗</div>
                        <h3>暂无关联</h3>
                        <p>您还没有与其他用户建立关联关系</p>
                        <p class="link-hint">当其他用户向您发送关联邀请时，您会收到通知</p>
                    </div>
                `;
            }
            
        } catch (error) {
            console.error('❌ [Link] 显示连接状态失败:', error);
        }
    },
    
    // 在Link页面显示用户信息
    displayUserInfoInLink(user) {
        console.log('🎨 [SPA Link] 显示用户信息:', user);
        console.log('🔍 [SPA Link] 检查 userInfoDisplay 元素是否存在...');
        
        const userInfoDisplay = document.getElementById('userInfoDisplay');
        console.log('🔍 [SPA Link] userInfoDisplay 元素:', userInfoDisplay);
        
        if (userInfoDisplay && user) {
            userInfoDisplay.innerHTML = `
                <div class="selected-user-info">
                    <div class="user-avatar" style="background-color: ${user.avatar_color}">
                        ${user.display_name.charAt(0)}
                    </div>
                    <h3>${user.display_name}</h3>
                    <div class="user-details">
                        <div class="link-detail-item">
                            <span class="detail-label">用户名:</span>
                            <span class="detail-value">${user.username}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">显示名称:</span>
                            <span class="detail-value">${user.display_name}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">邮箱:</span>
                            <span class="detail-value">${user.email || '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">手机号:</span>
                            <span class="detail-value">${user.phone || '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">性别:</span>
                            <span class="detail-value">${user.gender === 'male' ? '男' : user.gender === 'female' ? '女' : user.gender === 'other' ? '其他' : '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">生日:</span>
                            <span class="detail-value">${user.birthday ? new Date(user.birthday).toLocaleDateString() : '未设置'}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">头像颜色:</span>
                            <span class="detail-value">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: ${user.avatar_color}; border-radius: 50%; vertical-align: middle; margin-right: 8px;"></span>
                                ${user.avatar_color}
                            </span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">创建时间:</span>
                            <span class="detail-value">${new Date(user.created_at).toLocaleString()}</span>
                        </div>
                        <div class="link-detail-item">
                            <span class="detail-label">最后更新:</span>
                            <span class="detail-value">${new Date(user.updated_at).toLocaleString()}</span>
                        </div>
                    </div>
                    
                    <!-- Link功能区域 -->
                    <div class="link-function-area" id="linkFunctionArea">
                        <div class="link-section-title">用户关联</div>
                        <div class="link-content" id="linkContent-${user.id}">
                            <div class="loading-link">正在检查关联状态...</div>
                        </div>
                    </div>
                </div>
            `;
            
            console.log('✅ [SPA Link] 用户信息已更新');
            
            // 延迟加载Link功能内容
            setTimeout(() => {
                this.loadLinkFunctionContent(user);
            }, 100);
        } else {
            console.error('❌ [SPA Link] userInfoDisplay元素未找到或用户为空');
        }
    },
    
    // 加载Link功能内容
    async loadLinkFunctionContent(user) {
        try {
            console.log('🔗 [SPA Link] 加载用户关联功能:', user.id);
            
            const linkContentEl = this._getLinkContentElement(user.id);
            if (!linkContentEl) return;
            
            const currentAppUser = this._getCurrentAppUser();
            if (!currentAppUser) {
                linkContentEl.innerHTML = '<div class="link-error">用户未登录</div>';
                return;
            }
            
            await this._loadAndRenderLinkStatus(user, currentAppUser, linkContentEl);
            console.log('✅ [SPA Link] 关联功能界面已加载');
        } catch (error) {
            console.error('❌ [SPA Link] 加载关联功能失败:', error);
            this._renderErrorState(user.id, '加载关联功能失败');
        }
    },

    // 获取关联内容元素
    _getLinkContentElement(userId) {
        const linkContentEl = document.getElementById(`linkContent-${userId}`);
        if (!linkContentEl) {
            console.error('❌ [SPA Link] 找不到关联内容容器');
            return null;
        }
        return linkContentEl;
    },

    // 获取当前应用用户
    _getCurrentAppUser() {
        return window.GlobalUserState ? 
               window.GlobalUserState.getAppUserId() : 
               localStorage.getItem('wenting_current_app_user');
    },

    // 加载并渲染关联状态
    async _loadAndRenderLinkStatus(user, currentAppUser, linkContentEl) {
        try {
            console.log('🔍 [SPA Link] 正在检查用户关联状态...');
            
            const response = await this._fetchLinkStatus(currentAppUser);
            const allLinks = this._parseLinkResponse(response);
            
            if (response.success && allLinks.length > 0) {
                this.renderLinkedUserInterface(user, allLinks, linkContentEl);
            } else {
                this.renderLinkInputInterface(user, linkContentEl);
            }
        } catch (error) {
            console.error('❌ [SPA Link] 检查关联状态失败:', error);
            this._logLinkStatusError(error, currentAppUser, user);
            this.renderLinkInputInterface(user, linkContentEl);
        }
    },

    // 获取关联状态
    async _fetchLinkStatus(currentAppUser) {
        if (window.WebSocketClient && window.WebSocketClient.isConnected) {
            return await window.WebSocketClient.links.checkLinkStatus(currentAppUser);
        } else {
            return await this._fetchLinkStatusViaHTTP(currentAppUser);
        }
    },

    // 通过HTTP获取关联状态
    async _fetchLinkStatusViaHTTP(currentAppUser) {
        const apiResponse = await fetch(`/api/links/user/${currentAppUser}/status`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
            }
        });
        
        if (!apiResponse.ok) {
            throw new Error(`HTTP ${apiResponse.status}: ${apiResponse.statusText}`);
        }
        
        const data = await apiResponse.json();
        return { success: true, data: data };
    },

    // 解析关联响应数据
    _parseLinkResponse(response) {
        console.log('🔗 [SPA Link] 用户关联状态:', response);
        
        let allLinks = [];
        if (response.data?.links) {
            if (Array.isArray(response.data.links)) {
                // 新格式：直接是数组
                allLinks = response.data.links;
                console.log('🔍 [Debug] 使用新格式数组:', allLinks.length);
            } else if (response.data.links.asManager || response.data.links.asLinked) {
                // 旧格式：合并asManager和asLinked
                allLinks = this._mergeLegacyLinkFormats(response.data.links);
            }
        }
        
        console.log('🔍 [Debug] 最终合并的links数组:', allLinks);
        return allLinks;
    },

    // 合并旧格式的关联数据
    _mergeLegacyLinkFormats(links) {
        const allLinks = [];
        if (links.asManager) {
            allLinks.push(...links.asManager);
        }
        if (links.asLinked) {
            allLinks.push(...links.asLinked);
        }
        console.log('🔍 [Debug] 使用旧格式对象，合并后数组长度:', allLinks.length);
        return allLinks;
    },

    // 记录关联状态错误日志
    _logLinkStatusError(error, currentAppUser, user) {
        console.error('❌ [Debug] 错误详情:', error.message);
        console.error('❌ [Debug] 当前用户:', currentAppUser);
        console.error('❌ [Debug] 被选中用户:', user);
    },

    // 渲染错误状态
    _renderErrorState(userId, errorMessage) {
        const linkContentEl = document.getElementById(`linkContent-${userId}`);
        if (linkContentEl) {
            linkContentEl.innerHTML = `<div class="link-error">${errorMessage}</div>`;
        }
    },
    
    // 渲染关联输入界面
    renderLinkInputInterface(user, container) {
        container.innerHTML = `
            <div class="link-input-area">
                <div class="link-description">
                    将 <strong>${user.display_name}</strong> 的健康数据与其他用户关联，实现数据同步。
                </div>
                <div class="link-input-group">
                    <input type="text" 
                           id="linkUserInput-${user.id}" 
                           class="link-user-input" 
                           placeholder="输入要关联的用户名（如：whiteblade）"
                           maxlength="10">
                    <button id="linkUserBtn-${user.id}" 
                            class="link-user-btn btn-primary" 
                            onclick="App.sendLinkRequest(${user.id})">
                        发送关联
                    </button>
                </div>
                <div class="link-tips">
                    💡 提示：关联后双方都能管理 ${user.display_name} 的健康数据，数据会实时同步。
                </div>
            </div>
        `;
    },
    
    // 渲染已关联用户界面
    renderLinkedUserInterface(user, links, container) {
        const currentAppUser = localStorage.getItem('wenting_current_app_user');
        const linkInfo = links[0]; // 取第一个关联关系
        
        // 确定对方用户
        const linkedUser = linkInfo.manager_app_user === currentAppUser ? 
                          linkInfo.linked_app_user : linkInfo.manager_app_user;
        const isManager = linkInfo.manager_app_user === currentAppUser;
        
        container.innerHTML = `
            <div class="link-linked-area">
                <div class="link-description">
                    <strong>${user.display_name}</strong> 的健康数据已与其他用户关联。
                </div>
                
                <!-- 第一行：关联状态和用户信息 -->
                <div class="link-info-row">
                    <div class="link-status-badge success">✓ 已关联</div>
                    <div class="link-partner-info">
                        <span class="partner-label">关联用户:</span>
                        <span class="partner-name">${linkedUser}</span>
                    </div>
                </div>
                
                <!-- 第二行：角色和时间信息 -->
                <div class="link-info-row">
                    <div class="link-role-info">
                        <span class="role-label">您的角色:</span>
                        <span class="role-badge ${isManager ? 'manager' : 'linked'}">${isManager ? '管理员' : '关联用户'}</span>
                    </div>
                    <div class="link-time-info">
                        <span class="time-label">关联时间:</span>
                        <span class="time-value">${new Date(linkInfo.created_at).toLocaleDateString()}</span>
                    </div>
                </div>
                
                <!-- 第三行：操作按钮 -->
                <div class="link-actions-row">
                    <button class="link-unlink-btn" 
                            onclick="App.confirmUnlink(${user.id}, ${linkInfo.id}, '${linkedUser}')">
                        🔗 取消关联
                    </button>
                </div>
                
                <div class="link-tips">
                    💡 取消关联后，对方将无法继续管理 ${user.display_name} 的健康数据
                </div>
            </div>
        `;
    },
    
    // 发送关联请求（主入口）
    async sendLinkRequest(supervisedUserId) {
        try {
            console.log('🔗 [SPA Link] 发送关联请求，被监管用户ID:', supervisedUserId);
            
            // 获取并验证表单元素
            const elements = this._getLinkRequestElements(supervisedUserId);
            if (!elements) return;
            
            // 验证输入并获取目标用户名
            const targetUsername = this._validateLinkInput(elements.inputEl);
            if (!targetUsername) return;
            
            // 获取并验证被监管用户信息
            const supervisedUser = this._getSupervisedUser(supervisedUserId);
            if (!supervisedUser) return;
            
            // 发送邀请
            await this._sendInvitation(elements, targetUsername, supervisedUserId, supervisedUser);
            
        } catch (error) {
            console.error('❌ [SPA Link] 发送关联请求失败:', error);
            this.showLinkNotification('error', '发送关联请求失败');
            this._resetButtonState(supervisedUserId);
        }
    },

    // 获取关联请求相关DOM元素
    _getLinkRequestElements(supervisedUserId) {
        const inputEl = document.getElementById(`linkUserInput-${supervisedUserId}`);
        const btnEl = document.getElementById(`linkUserBtn-${supervisedUserId}`);
        
        if (!inputEl || !btnEl) {
            console.error('❌ [SPA Link] 找不到输入元素');
            return null;
        }
        
        return { inputEl, btnEl };
    },

    // 验证关联输入
    _validateLinkInput(inputEl) {
        const targetUsername = inputEl.value.trim();
        
        if (!targetUsername) {
            this.showLinkNotification('error', '请输入要关联的用户名');
            return null;
        }
        
        // 验证用户名格式
        if (!/^[a-z0-9]{1,10}$/.test(targetUsername)) {
            this.showLinkNotification('error', '用户名格式不正确，只能包含小写字母和数字，长度1-10字符');
            return null;
        }
        
        // 检查是否尝试关联自己
        const currentAppUser = this._getCurrentAppUser();
        if (targetUsername === currentAppUser) {
            this.showLinkNotification('error', '不能关联自己');
            return null;
        }
        
        return targetUsername;
    },


    // 获取被监管用户信息
    _getSupervisedUser(supervisedUserId) {
        const supervisedUser = window.UserManager?.users?.find(u => u.id === supervisedUserId);
        if (!supervisedUser) {
            this.showLinkNotification('error', '找不到被监管用户信息');
            return null;
        }
        return supervisedUser;
    },

    // 发送邀请
    async _sendInvitation(elements, targetUsername, supervisedUserId, supervisedUser) {
        const { inputEl, btnEl } = elements;
        
        // 设置加载状态
        this._setButtonLoading(btnEl, '检查用户...');
        
        try {
            btnEl.textContent = '发送邀请...';
            
            // 发送邀请
            const invitationResponse = await this._sendInvitationRequest(targetUsername, supervisedUserId, supervisedUser);
            console.log('📨 [SPA Link] 邀请发送结果:', invitationResponse);
            
            // 处理响应
            this._handleInvitationResponse(invitationResponse, targetUsername, inputEl);
            
        } catch (error) {
            console.error('❌ [SPA Link] WebSocket请求失败:', error);
            this.showLinkNotification('error', error.message || '发送请求失败');
        } finally {
            // 重置按钮
            this._resetButton(btnEl);
        }
    },

    // 发送邀请请求
    async _sendInvitationRequest(targetUsername, supervisedUserId, supervisedUser) {
        const currentAppUser = this._getCurrentAppUser();
        const message = `${currentAppUser} 想要与您关联 ${supervisedUser.display_name} 的健康数据`;
        
        if (window.WebSocketClient && window.WebSocketClient.isConnected) {
            return await window.WebSocketClient.links.sendInvitation(targetUsername, supervisedUserId, message);
        } else {
            return await this._sendInvitationViaHTTP(targetUsername, supervisedUserId, message);
        }
    },

    // 通过HTTP发送邀请
    async _sendInvitationViaHTTP(targetUsername, supervisedUserId, message) {
        const apiResponse = await fetch('/api/links/requests', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
            },
            body: JSON.stringify({
                toAppUser: targetUsername,
                supervisedUserId: supervisedUserId,
                message: message
            })
        });
        
        return { success: apiResponse.ok, data: await apiResponse.json() };
    },

    // 处理邀请响应
    _handleInvitationResponse(invitationResponse, targetUsername, inputEl) {
        if (invitationResponse.success) {
            const message = invitationResponse.isOverride 
                ? `邀请已更新并重新发送给 ${targetUsername}` 
                : `关联邀请已发送给 ${targetUsername}`;
            this.showLinkNotification('success', message);
            inputEl.value = '';
        } else {
            this._handleInvitationError(invitationResponse, targetUsername);
        }
    },

    // 处理邀请错误
    _handleInvitationError(invitationResponse, targetUsername) {
        if (invitationResponse.error === 'TARGET_USER_OFFLINE') {
            this.showLinkNotification('warning', `${targetUsername} 当前不在线，请稍后再试或通过其他方式联系对方`);
        } else {
            this.showLinkNotification('error', invitationResponse.message || invitationResponse.error || '发送邀请失败');
        }
    },

    // 设置按钮加载状态
    _setButtonLoading(btnEl, text) {
        btnEl.disabled = true;
        btnEl.textContent = text;
    },

    // 重置按钮状态
    _resetButton(btnEl) {
        btnEl.disabled = false;
        btnEl.textContent = '发送关联';
    },

    // 重置按钮状态（通过ID查找）
    _resetButtonState(supervisedUserId) {
        const btnEl = document.getElementById(`linkUserBtn-${supervisedUserId}`);
        if (btnEl) {
            this._resetButton(btnEl);
        }
    },
    
    // 发送WebSocket消息并等待响应
    async sendWebSocketMessage(message) {
        return new Promise((resolve, reject) => {
            // 检查WebSocket连接 - 修复对象名称不一致问题
            if (!window.WebSocketClient || !window.WebSocketClient.isConnected) {
                reject(new Error('WebSocket未连接'));
                return;
            }
            
            // 生成消息ID用于匹配响应
            const messageId = Date.now().toString();
            message.messageId = messageId;
            message.timestamp = Date.now();
            
            // 设置响应监听器
            const responseType = `${message.type}_RESPONSE`;
            const timeoutId = setTimeout(() => {
                reject(new Error('请求超时'));
            }, 10000); // 10秒超时
            
            const handleResponse = (event) => {
                try {
                    const response = JSON.parse(event.data);
                    if (response.type === responseType && response.messageId === messageId) {
                        clearTimeout(timeoutId);
                        window.WebSocketClient.ws.removeEventListener('message', handleResponse);
                        resolve(response);
                    }
                } catch (e) {
                    // 忽略解析错误
                }
            };
            
            // 监听响应
            window.WebSocketClient.ws.addEventListener('message', handleResponse);
            
            // 发送消息
            try {
                window.WebSocketClient.ws.send(JSON.stringify(message));
            } catch (error) {
                clearTimeout(timeoutId);
                window.WebSocketClient.ws.removeEventListener('message', handleResponse);
                reject(error);
            }
        });
    },
    
    // 显示Link通知
    showLinkNotification(type, message) {
        console.log(`🔔 [SPA Link] 显示${type}通知:`, message);
        
        // 创建通知元素
        const notification = document.createElement('div');
        notification.className = `link-notification link-notification-${type}`;
        notification.innerHTML = `
            <div class="link-notification-content">
                <div class="link-notification-icon">
                    ${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}
                </div>
                <div class="link-notification-message">${message}</div>
                <button class="link-notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
            </div>
        `;
        
        // 添加到页面
        document.body.appendChild(notification);
        
        // 自动消失
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    },
    
    // 显示数据同步通知（更详细的提示）
    showDataSyncNotification(type, message) {
        console.log(`🔄 [数据同步] 显示${type}通知:`, message);
        
        // 创建更详细的通知元素
        const notification = document.createElement('div');
        notification.className = `data-sync-notification data-sync-notification-${type}`;
        notification.innerHTML = `
            <div class="data-sync-notification-content">
                <div class="data-sync-notification-header">
                    <div class="data-sync-notification-icon">
                        ${type === 'success' ? '🎉' : type === 'info' ? '📊' : type === 'warning' ? '⚠️' : '❌'}
                    </div>
                    <div class="data-sync-notification-title">数据同步通知</div>
                    <button class="data-sync-notification-close" onclick="this.parentElement.parentElement.parentElement.remove()">×</button>
                </div>
                <div class="data-sync-notification-body">
                    <p>${message}</p>
                    <div class="data-sync-details">
                        <small>📝 这意味着TODO项目、健康笔记等数据已完成同步</small>
                    </div>
                </div>
            </div>
        `;
        
        // 添加到页面
        document.body.appendChild(notification);
        
        // 较长的显示时间，因为包含重要信息
        setTimeout(() => {
            if (notification.parentElement) {
                notification.classList.add('data-sync-fade-out');
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 500);
            }
        }, 8000);
    },
    
    // 显示关联邀请对话框
    showLinkInvitationDialog(invitationData) {
        console.log('🔔 [SPA Link] 显示关联邀请对话框:', invitationData);
        
        const { fromUser, supervisedUserName, message, timestamp, expiresIn } = invitationData;
        
        // 创建模态对话框
        const modal = document.createElement('div');
        modal.className = 'link-invitation-modal';
        modal.innerHTML = `
            <div class="link-invitation-dialog">
                <div class="link-invitation-header">
                    <div class="link-invitation-icon">🔗</div>
                    <h3>关联邀请</h3>
                </div>
                <div class="link-invitation-body">
                    <div class="link-invitation-from">
                        来自：<strong>${fromUser}</strong>
                    </div>
                    <div class="link-invitation-target">
                        关联用户：<strong>${supervisedUserName}</strong>
                    </div>
                    <div class="link-invitation-message">
                        ${message}
                    </div>
                    <div class="link-invitation-time">
                        ${new Date(timestamp).toLocaleString()}
                    </div>
                </div>
                <div class="link-invitation-actions">
                    <button class="btn btn-success" onclick="App.respondToLinkInvitation('accept', '${fromUser}', '${supervisedUserName}', ${invitationData.requestId})">
                        接受
                    </button>
                    <button class="btn btn-secondary" onclick="App.respondToLinkInvitation('reject', '${fromUser}', '${supervisedUserName}', ${invitationData.requestId})">
                        拒绝
                    </button>
                </div>
                <div class="link-invitation-expire">
                    邀请将在 ${Math.floor(expiresIn / 60000)} 分钟后过期
                </div>
            </div>
        `;
        
        // 添加到页面
        document.body.appendChild(modal);
        
        // 自动过期处理
        setTimeout(() => {
            if (modal.parentElement) {
                modal.remove();
                console.log('⏰ [SPA Link] 关联邀请已过期');
            }
        }, expiresIn);
    },
    
    // 响应关联邀请
    async respondToLinkInvitation(action, fromUser, supervisedUserName, requestId) {
        try {
            console.log(`📝 [SPA Link] 响应关联邀请: ${action}`, { fromUser, supervisedUserName, requestId });
            
            const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            if (!currentAppUser) {
                this.showLinkNotification('error', '用户未登录');
                return;
            }
            
            // 发送响应
            let response;
            try {
                if (window.WebSocketClient && window.WebSocketClient.isConnected) {
                    if (action === 'accept') {
                        response = await window.WebSocketClient.links.acceptInvitation(requestId);
                    } else {
                        response = await window.WebSocketClient.links.rejectInvitation(requestId);
                    }
                } else {
                    // HTTP降级模式
                    const apiResponse = await fetch(`/api/links/requests/${requestId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
                        },
                        body: JSON.stringify({
                            action: action,
                            appUser: currentAppUser
                        })
                    });
                    response = { success: apiResponse.ok, data: await apiResponse.json() };
                }
            } catch (error) {
                response = { success: false, error: error.message };
            }
            
            console.log('📨 [SPA Link] 邀请响应结果:', response);
            
            if (response.success) {
                if (action === 'accept') {
                    this.showLinkNotification('success', `已接受与 ${fromUser} 的关联邀请，正在刷新数据...`);
                    
                    // 🔥 修复：不在这里调用 refreshApplicationAfterLink，让 WebSocket 的 LINK_ESTABLISHED 消息处理
                    console.log('✅ [Link] 邀请接受成功，等待 WebSocket LINK_ESTABLISHED 消息触发数据刷新');
                    
                } else {
                    this.showLinkNotification('info', `已拒绝与 ${fromUser} 的关联邀请`);
                }
            } else {
                this.showLinkNotification('error', response.error || '处理邀请失败');
            }
            
            // 关闭对话框
            const modal = document.querySelector('.link-invitation-modal');
            if (modal) {
                modal.remove();
            }
            
        } catch (error) {
            console.error('❌ [SPA Link] 响应邀请失败:', error);
            this.showLinkNotification('error', '响应邀请失败');
        }
    },
    
    // Link成功后刷新应用数据
    async refreshApplicationAfterLink() {
        if (this._isDuplicateRefreshCall()) return;
        
        this._refreshingAfterLink = true;
        
        try {
            console.log('🔄 [Link] 开始刷新应用数据...');
            
            await this._refreshUserData();
            await this._refreshApplicationData();
            await this._navigateToLinkPage();
            await this._ensureDefaultUser();
            
            this.showLinkNotification('success', '关联建立成功！已自动跳转到Link页面查看连接状态');
            console.log('✅ [Link] 应用数据刷新完成');
            
        } catch (error) {
            console.error('❌ [Link] 刷新应用数据失败:', error);
            this.showLinkNotification('error', '数据刷新失败，请手动刷新页面');
        } finally {
            this._refreshingAfterLink = false;
        }
    },

    // 检查是否为重复刷新调用
    _isDuplicateRefreshCall() {
        if (this._refreshingAfterLink) {
            console.log('⚠️ [Link] 数据刷新已在进行中，跳过重复调用');
            return true;
        }
        return false;
    },

    // 刷新用户数据
    async _refreshUserData() {
        if (window.UserManager && typeof UserManager.loadUsersFromAPI === 'function') {
            console.log('🔄 [Link] 重新加载用户数据...');
            await UserManager.loadUsersFromAPI();
            console.log('✅ [Link] 用户数据重新加载完成，用户数量:', UserManager.users?.length || 0);
            
            this._logLoadedUserData();
        }
        
        this._updateUserInterface();
    },

    // 记录加载的用户数据
    _logLoadedUserData() {
        if (UserManager.users && UserManager.users.length > 0) {
            console.log('🔍 [Link] 加载的用户数据:', UserManager.users.map(u => ({ 
                id: u.id, 
                username: u.username, 
                app_user_id: u.app_user_id 
            })));
        }
    },

    // 更新用户界面
    _updateUserInterface() {
        if (window.UserManager && typeof UserManager.renderUserTabs === 'function') {
            console.log('🔄 [Link] 重新渲染用户标签...');
            UserManager.renderUserTabs();
            console.log('✅ [Link] 用户标签重新渲染完成');
        }
        
        if (window.GlobalUserState) {
            console.log('🔄 [Link] 更新全局用户状态...');
            GlobalUserState.updateUserSelectorUI();
            console.log('✅ [Link] 全局用户状态更新完成');
        }
    },

    // 刷新应用数据
    async _refreshApplicationData() {
        await this._refreshTodoData();
        await this._refreshNotesData();
    },

    // 刷新TODO数据
    async _refreshTodoData() {
        if (window.TodoManager) {
            console.log('🔄 [Link] 重新加载TODO数据...');
            await TodoManager.loadTodosFromAPI();
            console.log('✅ [Link] TODO数据重新加载完成');
        }
    },

    // 刷新Notes数据
    async _refreshNotesData() {
        if (window.NotesManager) {
            console.log('🔄 [Link] 重新加载Notes数据...');
            await NotesManager.loadNotesFromAPI();
            console.log('✅ [Link] Notes数据重新加载完成');
        }
    },

    // 导航到Link页面
    async _navigateToLinkPage() {
        console.log('🔄 [Link] 自动跳转到Link页面...');
        await this.showLinkPage();
    },

    // 确保有默认用户
    async _ensureDefaultUser() {
        if (UserManager.users && UserManager.users.length > 0 && window.GlobalUserState) {
            const currentUser = GlobalUserState.getCurrentUser();
            const userExists = UserManager.users.find(u => u.id === currentUser);
            
            if (!currentUser || !userExists) {
                this._setDefaultUser();
            } else {
                console.log('✅ [Link] 当前用户有效:', currentUser);
            }
        }
    },

    // 设置默认用户
    _setDefaultUser() {
        const firstUser = UserManager.users[0];
        console.log('🔄 [Link] 设置默认用户:', firstUser.username, 'ID:', firstUser.id);
        GlobalUserState.setCurrentUser(firstUser.id);
        
        setTimeout(() => {
            this._activateUserTab(firstUser);
        }, 500);
    },

    // 激活用户标签
    _activateUserTab(user) {
        const userTab = document.querySelector(`[data-user-id="${user.id}"]`);
        if (userTab) {
            document.querySelectorAll('.user-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            userTab.classList.add('active');
            console.log('✅ [Link] 用户标签已选中:', user.username);
        }
    },
    
    // 处理数据同步更新
    handleDataSyncUpdate(syncData) {
        try {
            console.log('🔄 [数据同步] 处理同步更新:', syncData);
            
            // 正确解构嵌套的数据结构
            const { table, operation, data } = syncData.data || syncData;
            
            // 显示同步通知
            this.showDataSyncOperationNotification(operation, table, data);
            
            // 根据数据类型刷新相应的界面
            if (table === 'todos' && window.TodoManager) {
                console.log('🔄 [数据同步] 刷新TODO数据');
                
                // 获取当前用户和日期
                const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : null;
                const currentDate = window.DateManager ? DateManager.selectedDate : new Date();
                
                if (currentUserId) {
                    // 清除缓存并重新加载数据
                    const dateStr = currentDate.toISOString().split('T')[0];
                    const cacheKey = `${currentUserId}_${dateStr}`;
                    if (TodoManager.todoCache) {
                        TodoManager.todoCache.delete(cacheKey);
                        console.log('🧹 [数据同步] 清除TODO缓存:', cacheKey);
                    }
                    
                    // 延迟一下再刷新，确保服务器数据已同步
                    setTimeout(async () => {
                        try {
                            await TodoManager.loadTodosForDate(currentDate, currentUserId);
                            console.log('✅ [数据同步] TODO数据刷新完成');
                        } catch (error) {
                            console.error('❌ [数据同步] TODO数据刷新失败:', error);
                        }
                    }, 500);
                }
                
            } else if (table === 'notes' && window.NotesManager) {
                console.log('🔄 [数据同步] 刷新Notes数据');
                
                const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : null;
                if (currentUserId) {
                    setTimeout(async () => {
                        try {
                            await NotesManager.loadNotesFromAPI();
                            if (GlobalUserState.getCurrentModule() === 'notes') {
                                NotesManager.renderNotesPanel(currentUserId);
                            }
                            console.log('✅ [数据同步] Notes数据刷新完成');
                        } catch (error) {
                            console.error('❌ [数据同步] Notes数据刷新失败:', error);
                        }
                    }, 500);
                }
            }
            
        } catch (error) {
            console.error('❌ [数据同步] 处理同步更新失败:', error);
        }
    },
    
    // 显示数据同步操作通知
    showDataSyncOperationNotification(operation, table, data = {}) {
        const tableNames = {
            'todos': 'TODO',
            'notes': 'Notes'
        };
        
        const operationNames = {
            'create': '新增',
            'update': '更新', 
            'delete': '删除',
            'complete': '完成',
            'uncomplete': '取消完成'
        };
        
        const tableName = tableNames[table] || table;
        const operationName = operationNames[operation] || operation;
        const itemTitle = data.title ? `"${data.title}"` : '';
        
        // 创建同步通知
        const notification = document.createElement('div');
        notification.className = 'data-sync-notification';
        notification.innerHTML = `
            <div class="data-sync-content">
                <div class="data-sync-icon">🔄</div>
                <div class="data-sync-message">
                    关联用户${operationName}了${tableName}${itemTitle}，正在同步...
                </div>
            </div>
        `;
        
        // 添加到页面
        document.body.appendChild(notification);
        
        // 显示动画
        setTimeout(() => notification.classList.add('show'), 100);
        
        // 自动消失
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentElement) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, 3000);
    },
    
    // 确认取消关联
    confirmUnlink(supervisedUserId, linkId, linkedUser) {
        console.log('🔗 [SPA Link] 确认取消关联:', { supervisedUserId, linkId, linkedUser });
        
        // 创建确认对话框
        const modal = document.createElement('div');
        modal.className = 'link-unlink-modal';
        modal.innerHTML = `
            <div class="link-unlink-dialog">
                <div class="link-unlink-header">
                    <div class="link-unlink-icon">⚠️</div>
                    <h3>确认取消关联</h3>
                </div>
                <div class="link-unlink-body">
                    <p>您确定要取消与 <strong>${linkedUser}</strong> 的关联关系吗？</p>
                    <div class="link-unlink-warning">
                        ⚠️ 取消关联后：
                        <ul>
                            <li>对方将无法继续管理该用户的健康数据</li>
                            <li>数据同步将停止</li>
                            <li>需要重新发送邀请才能恢复关联</li>
                        </ul>
                    </div>
                </div>
                <div class="link-unlink-actions">
                    <button class="btn btn-danger" onclick="App.executeUnlink(${supervisedUserId}, ${linkId}, '${linkedUser}')">
                        确认取消
                    </button>
                    <button class="btn btn-secondary" onclick="this.parentElement.parentElement.parentElement.remove()">
                        取消
                    </button>
                </div>
            </div>
        `;
        
        // 添加到页面
        document.body.appendChild(modal);
    },
    
    // 执行取消关联
    async executeUnlink(supervisedUserId, linkId, linkedUser) {
        try {
            console.log('🔗 [SPA Link] 执行取消关联:', { supervisedUserId, linkId, linkedUser });
            
            const currentAppUser = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : localStorage.getItem('wenting_current_app_user');
            if (!currentAppUser) {
                this.showLinkNotification('error', '用户未登录');
                return;
            }
            
            // 发送取消关联请求
            let response;
            try {
                if (window.WebSocketClient && window.WebSocketClient.isConnected) {
                    response = await window.WebSocketClient.links.cancelLink(linkId);
                } else {
                    // HTTP降级模式
                    const apiResponse = await fetch(`/api/links/${linkId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Device-ID': window.DeviceManager?.getCurrentDeviceId() || 'unknown'
                        },
                        body: JSON.stringify({
                            appUser: currentAppUser
                        })
                    });
                    const responseData = await apiResponse.json();
                    response = { success: apiResponse.ok, data: responseData };
                }
            } catch (error) {
                response = { success: false, error: error.message };
            }
            
            console.log('🔗 [SPA Link] 取消关联结果:', response);
            
            if (response.success) {
                this.showLinkNotification('success', `已取消与 ${linkedUser} 的关联`);
                
                // 关闭确认对话框
                const modal = document.querySelector('.link-unlink-modal');
                if (modal) {
                    modal.remove();
                }
                
                // 重新加载用户数据和Link页面
                setTimeout(async () => {
                    try {
                        // 重新加载用户数据
                        if (window.UserManager) {
                            await UserManager.loadUsersFromAPI();
                        }
                        
                        // 重新加载Link功能内容，显示发送关联界面
                        const user = window.UserManager?.users?.find(u => u.id === supervisedUserId);
                        if (user) {
                            this.displayUserInfoInLink(user);
                        }
                        
                        // 重新检查关联状态
                        await this.displayLinkConnectionStatus();
                    } catch (error) {
                        console.error('重新加载数据失败:', error);
                    }
                }, 1000);
                
            } else {
                this.showLinkNotification('error', response.data?.message || response.error || '取消关联失败');
            }
            
        } catch (error) {
            console.error('❌ [SPA Link] 取消关联失败:', error);
            this.showLinkNotification('error', '取消关联失败');
        }
    },

    // 处理Link状态变更通知
    handleLinkStatusChange(type, data) {
        console.log(`🔗 [SPA Link] 处理Link状态变更:`, type, data);
        
        switch (type) {
            case 'LINK_INVITATION_ACCEPTED':
                this.showLinkNotification('success', `${data.acceptedBy} 接受了您的关联邀请`);
                break;
                
            case 'LINK_INVITATION_REJECTED':
                this.showLinkNotification('info', `${data.rejectedBy} 拒绝了您的关联邀请`);
                break;
                
            case 'LINK_ESTABLISHED':
                this.showLinkNotification('success', `与 ${data.linkedUser} 的关联已建立`);
                
                // 如果有数据同步提示，显示详细通知
                if (data.syncMessage) {
                    setTimeout(() => {
                        this.showDataSyncNotification('info', data.syncMessage);
                    }, 2000);
                }
                
                // 如果当前在Link页面，刷新显示
                if (document.querySelector('.link-content-area')) {
                    setTimeout(async () => {
                        try {
                            // 重新加载用户数据
                            if (window.UserManager) {
                                await UserManager.loadUsersFromAPI();
                            }
                            
                            // 重新检查关联状态
                            await this.displayLinkConnectionStatus();
                            
                            // 如果有选中的用户，重新显示该用户信息
                            const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                            if (currentUser) {
                                const user = window.UserManager?.users?.find(u => u.id === currentUser);
                                if (user) {
                                    this.displayUserInfoInLink(user);
                                }
                            }
                        } catch (error) {
                            console.error('处理关联建立通知时重新加载数据失败:', error);
                        }
                    }, 1000);
                }
                break;
                
            case 'LINK_ACCEPTED':
                this.showLinkNotification('success', `${data.acceptedBy} 接受了您的关联邀请`);
                
                // 🔥 修复：像取消关联一样，先检查是否在Link页面
                if (document.querySelector('.link-content-area')) {
                    // 如果当前在Link页面，直接更新页面状态（和LINK_CANCELLED保持一致）
                    console.log('✅ [Link] 发起方当前在Link页面，直接更新页面状态');
                    setTimeout(async () => {
                        try {
                            // 重新加载用户数据
                            if (window.UserManager) {
                                await UserManager.loadUsersFromAPI();
                            }
                            
                            // 重新检查关联状态
                            await this.displayLinkConnectionStatus();
                            
                            // 如果有选中的用户，重新显示该用户信息
                            const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                            console.log('🔍 [Link] LINK_ACCEPTED 处理 - 当前选中用户ID:', currentUser);
                            console.log('🔍 [Link] LINK_ACCEPTED 处理 - 可用用户列表:', window.UserManager?.users?.map(u => ({id: u.id, username: u.username})));
                            
                            if (currentUser) {
                                const user = window.UserManager?.users?.find(u => u.id === currentUser);
                                console.log('🔍 [Link] LINK_ACCEPTED 处理 - 找到的用户:', user);
                                if (user) {
                                    console.log('🔄 [Link] LINK_ACCEPTED 处理 - 开始调用 displayUserInfoInLink...');
                                    this.displayUserInfoInLink(user);
                                } else {
                                    console.error('❌ [Link] LINK_ACCEPTED 处理 - 没有找到对应的用户对象');
                                }
                            } else {
                                console.error('❌ [Link] LINK_ACCEPTED 处理 - 当前没有选中的用户');
                            }
                        } catch (error) {
                            console.error('处理关联接受通知时更新Link页面失败:', error);
                        }
                    }, 1000);
                } else {
                    // 如果不在Link页面，跳转到Link页面
                    console.log('✅ [Link] 发起方不在Link页面，跳转并刷新应用数据');
                    setTimeout(async () => {
                        await this.refreshApplicationAfterLink();
                    }, 1000);
                }
                
                // 显示数据同步完成提示
                if (data.syncMessage) {
                    setTimeout(() => {
                        this.showDataSyncNotification('success', data.syncMessage);
                    }, 3000); // 延迟一点避免与页面操作冲突
                }
                break;
                
            case 'LINK_CANCELLED':
                this.showLinkNotification('warning', `${data.cancelledBy} 已取消关联关系`);
                // 如果当前在Link页面，刷新页面显示发送关联界面
                if (document.querySelector('.link-content-area')) {
                    setTimeout(async () => {
                        try {
                            // 重新加载用户数据
                            if (window.UserManager) {
                                await UserManager.loadUsersFromAPI();
                            }
                            
                            // 重新检查关联状态
                            await this.displayLinkConnectionStatus();
                            
                            // 如果有选中的用户，重新显示该用户信息
                            const currentUser = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;
                            if (currentUser) {
                                const user = window.UserManager?.users?.find(u => u.id === currentUser);
                                if (user) {
                                    this.displayUserInfoInLink(user);
                                }
                            }
                        } catch (error) {
                            console.error('处理关联取消通知时重新加载数据失败:', error);
                        }
                    }, 1000);
                }
                break;
                
            default:
                console.log('⚠️ [SPA Link] 未处理的Link状态类型:', type);
        }
    },
    
    // 显示默认选中用户的信息
    displayDefaultUserInLink() {
        console.log('🔍 [SPA Link] 检查默认选中用户...');
        
        const currentUserId = window.GlobalUserState ? GlobalUserState.getCurrentUser() : null;
        if (currentUserId && window.UserManager && window.UserManager.users) {
            const selectedUser = window.UserManager.users.find(user => user.id === currentUserId);
            if (selectedUser) {
                console.log('👤 [SPA Link] 找到默认用户，显示信息:', selectedUser.username);
                this.displayUserInfoInLink(selectedUser);
            } else {
                console.log('⚠️ [SPA Link] 未找到默认用户对象');
            }
        } else {
            console.log('ℹ️ [SPA Link] 没有默认用户或用户管理器未就绪');
        }
    },

    // 应用状态管理
    getState() {
        return {
            currentUser: TodoManager.currentUser,
            selectedDate: DateManager.selectedDate,
            todos: TodoManager.todos,
            users: UserManager.users,
            weather: WeatherManager.weatherData
        };
    },

    // 重置应用
    reset() {
        DialogUtils.showWarning('重置功能已禁用，应用完全依赖服务器数据。', '功能提示');
    },

    // 导出数据
    exportData() {
        const data = {
            version: '1.0',
            exportTime: new Date().toISOString(),
            ...this.getState()
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `wenting_backup_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
    },

    // 导入数据
    importData(fileInput) {
        const file = fileInput.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                
                if (data.version && data.todos) {
                    // 导入数据
                    if (data.todos) TodoManager.todos = data.todos;
                    if (data.users) UserManager.users = data.users;
                    if (data.weather) WeatherManager.weatherData = data.weather;
                    
                    // 保存数据
                    TodoManager.saveTodos();
                    UserManager.saveUsers();
                    WeatherManager.saveWeatherData();
                    
                    DialogUtils.showSuccess('数据导入成功！页面将刷新。').then(() => {
                        location.reload();
                    });
                } else {
                    DialogUtils.showError('无效的备份文件格式', '导入失败');
                }
            } catch (error) {
                DialogUtils.showError('导入失败：' + error.message, '导入失败');
            }
        };
        reader.readAsText(file);
    },

    // 🔥 新增：确保WebSocket注册的方法
    ensureWebSocketRegistration() {
        let attempts = 0;
        const MAX_ATTEMPTS = 10;
        const CHECK_INTERVAL = 500; // 500ms

        const tryRegistration = () => {
            attempts++;
            console.log(`🔄 [WebSocket] 尝试注册 (${attempts}/${MAX_ATTEMPTS})`);

            const deviceId = window.DeviceManager ? window.DeviceManager.getCurrentDeviceId() : null;
            const appUserId = window.GlobalUserState ? window.GlobalUserState.getAppUserId() : null;
            const userId = window.GlobalUserState ? window.GlobalUserState.getCurrentUser() : null;

            console.log('🔍 [WebSocket] 注册信息检查:', { deviceId, appUserId, userId });

            if (deviceId && appUserId) {
                console.log('✅ [WebSocket] 注册信息完整，发送注册消息');
                WebSocketClient.sendRegistrationMessage();
                return;
            }

            if (attempts < MAX_ATTEMPTS) {
                console.log(`⏳ [WebSocket] 注册信息不完整，${CHECK_INTERVAL}ms后重试...`);
                setTimeout(tryRegistration, CHECK_INTERVAL);
            } else {
                console.error('❌ [WebSocket] 达到最大重试次数，注册失败');
                console.log('💡 [WebSocket] 请检查用户登录状态和设备ID生成');
            }
        };

        // 立即尝试一次，然后根据需要重试
        tryRegistration();
    }
};

// 启动应用
App.init();

// 将App暴露到全局，方便调试
window.App = App;

// 调试方法：清除位置缓存并重新获取
window.debugClearLocation = function() {
    console.log('🔧 调试：清除位置缓存并重新获取');
    WeatherManager.clearLocationCache();
    WeatherManager.getCurrentLocation().then(() => {
        WeatherManager.fetchRealWeatherData();
        WeatherManager.updateWeatherDisplay();
    });
};
